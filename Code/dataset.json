[
    {
        "idx": "9",
        "vuln_id": "APACHE-COMMONS-001",
        "desc": "[]",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "a080293da69f3fe3d11d5214432e1469ee195870",
        "method_before": "    private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath();\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }",
        "method_after": "    private void expand(ArchiveEntrySupplier supplier, EntryWriter writer, File targetDirectory)\n        throws IOException {\n        String targetDirPath = targetDirectory.getCanonicalPath() + File.separatorChar;\n        ArchiveEntry nextEntry = supplier.getNextReadableEntry();\n        while (nextEntry != null) {\n            File f = new File(targetDirectory, nextEntry.getName());\n            if (!f.getCanonicalPath().startsWith(targetDirPath)) {\n                throw new IOException(\"expanding \" + nextEntry.getName()\n                    + \" would create file outside of \" + targetDirectory);\n            }\n            if (nextEntry.isDirectory()) {\n                if (!f.isDirectory() && !f.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + f);\n                }\n            } else {\n                File parent = f.getParentFile();\n                if (!parent.isDirectory() && !parent.mkdirs()) {\n                    throw new IOException(\"failed to create directory \" + parent);\n                }\n                try (OutputStream o = Files.newOutputStream(f.toPath())) {\n                    writer.writeEntryDataTo(nextEntry, o);\n                }\n            }\n            nextEntry = supplier.getNextReadableEntry();\n        }\n    }"
    },
    {
        "idx": "19",
        "vuln_id": "CVE-2007-5461",
        "desc": "Absolute path traversal vulnerability in Apache Tomcat 4.0.0 through 4.0.6, 4.1.0, 5.0.0, 5.5.0 through 5.5.25, and 6.0.0 through 6.0.14, under certain configurations, allows remote authenticated users to read arbitrary files via a WebDAV write request that specifies an entity with a SYSTEM tag.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "901292cf9d7d8225f8a3b96c7583e2bd8b41772d",
        "method_before": "    protected DocumentBuilder getDocumentBuilder()\n        throws ServletException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch(ParserConfigurationException e) {\n            throw new ServletException\n                (sm.getString(\"webdavservlet.jaxpfailed\"));\n        }\n        return documentBuilder;\n    }",
        "method_after": "    protected DocumentBuilder getDocumentBuilder()\n        throws ServletException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setExpandEntityReferences(false);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch(ParserConfigurationException e) {\n            throw new ServletException\n                (sm.getString(\"webdavservlet.jaxpfailed\"));\n        }\n        return documentBuilder;\n    }"
    },
    {
        "idx": "64",
        "vuln_id": "CVE-2010-4172",
        "desc": "Multiple cross-site scripting (XSS) vulnerabilities in the Manager application in Apache Tomcat 6.0.12 through 6.0.29 and 7.0.0 through 7.0.4 allow remote attackers to inject arbitrary web script or HTML via the (1) orderBy or (2) sort parameter to sessionsList.jsp, or unspecified input to (3) sessionDetail.jsp or (4) java/org/apache/catalina/manager/JspHelper.java, related to use of untrusted web applications.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "5971f9392edc6d70808b2599b062b050fcd11d23",
        "method_before": "    private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return locale.toString();//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }",
        "method_after": "    private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return escapeXml(locale.toString());//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }"
    },
    {
        "idx": "78",
        "vuln_id": "CVE-2011-1419",
        "desc": "['Apache Tomcat 7.x before 7.0.11, when web.xml has no security constraints, does not follow ServletSecurity annotations, which allows remote attackers to bypass intended access restrictions via HTTP requests to a web application.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1088.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat",
        "commit": "0ff4905158b77787a7f3aca55c9dec93456665dc",
        "method_before": "    protected synchronized void authenticatorConfig() {\n\n        // Does this Context require an Authenticator?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0))\n            return;\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null)\n            return;\n        \n        if (!(context instanceof ContainerBase)) {\n            return;     // Cannot install a Valve even if it would be needed\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve)\n                customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n        if (authenticator == null) {\n            // Load our mapping properties if necessary\n            if (authenticators == null) {\n                try {\n                    InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                    if( is!=null ) {\n                        authenticators = new Properties();\n                        authenticators.load(is);\n                    } else {\n                        log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"));\n                        ok=false;\n                        return;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"), e);\n                    ok = false;\n                    return;\n                }\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = null;\n            authenticatorName =\n                    authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null && context instanceof ContainerBase) {\n            Pipeline pipeline = ((ContainerBase) context).getPipeline();\n            if (pipeline != null) {\n                ((ContainerBase) context).getPipeline().addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n\n    }",
        "method_after": "    protected synchronized void authenticatorConfig() {\n\n        // Always need an authenticator to support @ServletSecurity annotations\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null)\n            return;\n        \n        if (!(context instanceof ContainerBase)) {\n            return;     // Cannot install a Valve even if it would be needed\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve)\n                customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n        if (authenticator == null) {\n            // Load our mapping properties if necessary\n            if (authenticators == null) {\n                try {\n                    InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                    if( is!=null ) {\n                        authenticators = new Properties();\n                        authenticators.load(is);\n                    } else {\n                        log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"));\n                        ok=false;\n                        return;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"), e);\n                    ok = false;\n                    return;\n                }\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = null;\n            authenticatorName =\n                    authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null && context instanceof ContainerBase) {\n            Pipeline pipeline = ((ContainerBase) context).getPipeline();\n            if (pipeline != null) {\n                ((ContainerBase) context).getPipeline().addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n\n    }"
    },
    {
        "idx": "129",
        "vuln_id": "CVE-2012-1621",
        "desc": "Multiple cross-site scripting (XSS) vulnerabilities in Apache Open For Business Project (aka OFBiz) 10.04.x before 10.04.02 allow remote attackers to inject arbitrary web script or HTML via (1) a parameter array in freemarker templates, the (2) contentId or (3) mapKey parameter in a cms event request, which are not properly handled in an error message, or unspecified input in (4) an ajax request to the getServerError function in checkoutProcess.js or (5) a Webslinger component request.  NOTE: some of these details are obtained from third party information.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/apache/ofbiz",
        "commit": "ea604f84e4a21fe081d66bbdab454b1e8a7d09b3"
    },
    {
        "idx": "205",
        "vuln_id": "CVE-2013-4378",
        "desc": "Cross-site scripting (XSS) vulnerability in HtmlSessionInformationsReport.java in JavaMelody 1.46 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted X-Forwarded-For header.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/javamelody/javamelody",
        "commit": "aacbc46151ff4ac1ca34ce0899c2a6113071c66e",
        "method_before": "\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"'>\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"</a>\");\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getLastAccess()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getAge()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\n\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getAttributeCount()));\n\t\twrite(nextColumnAlignCenter);\n\t\tif (session.isSerializable()) {\n\t\t\twrite(\"#oui#\");\n\t\t} else {\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\n\t\t}\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getSerializedSize()));\n\t\tfinal String nextColumn = \"</td><td>\";\n\t\twrite(nextColumn);\n\t\tfinal String remoteAddr = session.getRemoteAddr();\n\t\tif (remoteAddr == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\twrite(remoteAddr);\n\t\t}\n\t\twrite(nextColumnAlignCenter);\n\t\twriteCountry(session);\n\t\tif (displayUser) {\n\t\t\twrite(nextColumn);\n\t\t\tfinal String remoteUser = session.getRemoteUser();\n\t\t\tif (remoteUser == null) {\n\t\t\t\twrite(\"&nbsp;\");\n\t\t\t} else {\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n\t\t\t}\n\t\t}\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\n\t\twrite(A_HREF_PART_SESSIONS);\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\t\twrite(urlEncode(session.getId()));\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\t\twrite(\"</a>\");\n\t\twrite(\"</td>\");\n\t}",
        "method_after": "\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"'>\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"</a>\");\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getLastAccess()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getAge()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\n\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getAttributeCount()));\n\t\twrite(nextColumnAlignCenter);\n\t\tif (session.isSerializable()) {\n\t\t\twrite(\"#oui#\");\n\t\t} else {\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\n\t\t}\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getSerializedSize()));\n\t\tfinal String nextColumn = \"</td><td>\";\n\t\twrite(nextColumn);\n\t\tfinal String remoteAddr = session.getRemoteAddr();\n\t\tif (remoteAddr == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\twrite(htmlEncodeButNotSpace(remoteAddr));\n\t\t}\n\t\twrite(nextColumnAlignCenter);\n\t\twriteCountry(session);\n\t\tif (displayUser) {\n\t\t\twrite(nextColumn);\n\t\t\tfinal String remoteUser = session.getRemoteUser();\n\t\t\tif (remoteUser == null) {\n\t\t\t\twrite(\"&nbsp;\");\n\t\t\t} else {\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n\t\t\t}\n\t\t}\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\n\t\twrite(A_HREF_PART_SESSIONS);\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\t\twrite(urlEncode(session.getId()));\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\t\twrite(\"</a>\");\n\t\twrite(\"</td>\");\n\t}"
    },
    {
        "idx": "227",
        "vuln_id": "CVE-2014-0035",
        "desc": "The SymmetricBinding in Apache CXF before 2.6.13 and 2.7.x before 2.7.10, when EncryptBeforeSigning is enabled and the UsernameToken policy is set to an EncryptedSupportingToken, transmits the UsernameToken in cleartext, which allows remote attackers to obtain sensitive information by sniffing the network.",
        "cwe_id": "CWE-310",
        "cwe_name": "Cryptographic Issues",
        "repo": "https://github.com/apache/cxf",
        "commit": "5df3f72f1a26b7c9ac2888ab65e41f4105706580",
        "method_before": "    private void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            if (encryptionToken != null) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken \n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isEncryptSignature() \n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n                    \n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys \n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }",
        "method_after": "    private void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            if (encryptionToken != null) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken \n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isEncryptSignature() \n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n                    \n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys \n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }"
    },
    {
        "idx": "269",
        "vuln_id": "CVE-2014-2059",
        "desc": "Directory traversal vulnerability in the CLI job creation (hudson/cli/CreateJobCommand.java) in Jenkins before 1.551 and LTS before 1.532.2 allows remote authenticated users to overwrite arbitrary files via the job name.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "ad38d8480f20ce3cbf8fec3e2003bc83efda4f7d",
        "method_before": "    protected int run() throws Exception {\n        Jenkins h = Jenkins.getInstance();\n        h.checkPermission(Item.CREATE);\n\n        if (h.getItemByFullName(name)!=null) {\n            stderr.println(\"Job '\"+name+\"' already exists\");\n            return -1;\n        }\n\n        ModifiableTopLevelItemGroup ig = h;\n        int i = name.lastIndexOf('/');\n        if (i > 0) {\n            String group = name.substring(0, i);\n            Item item = h.getItemByFullName(group);\n            if (item == null) {\n                throw new IllegalArgumentException(\"Unknown ItemGroup \" + group);\n            }\n\n            if (item instanceof ModifiableTopLevelItemGroup) {\n                ig = (ModifiableTopLevelItemGroup) item;\n            } else {\n                throw new IllegalArgumentException(\"Can't create job from CLI in \" + group);\n            }\n            name = name.substring(i + 1);\n        }\n\n        ig.createProjectFromXML(name, stdin);\n        return 0;\n    }",
        "method_after": "    protected int run() throws Exception {\n        Jenkins h = Jenkins.getInstance();\n        h.checkPermission(Item.CREATE);\n\n        if (h.getItemByFullName(name)!=null) {\n            stderr.println(\"Job '\"+name+\"' already exists\");\n            return -1;\n        }\n\n        ModifiableTopLevelItemGroup ig = h;\n        int i = name.lastIndexOf('/');\n        if (i > 0) {\n            String group = name.substring(0, i);\n            Item item = h.getItemByFullName(group);\n            if (item == null) {\n                throw new IllegalArgumentException(\"Unknown ItemGroup \" + group);\n            }\n\n            if (item instanceof ModifiableTopLevelItemGroup) {\n                ig = (ModifiableTopLevelItemGroup) item;\n            } else {\n                throw new IllegalArgumentException(\"Can't create job from CLI in \" + group);\n            }\n            name = name.substring(i + 1);\n        }\n\n        Jenkins.checkGoodName(name);\n        ig.createProjectFromXML(name, stdin);\n        return 0;\n    }"
    },
    {
        "idx": "274",
        "vuln_id": "CVE-2014-2066",
        "desc": "Session fixation vulnerability in Jenkins before 1.551 and LTS before 1.532.2 allows remote attackers to hijack web sessions via vectors involving the \"override\" of Jenkins cookies.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "8ac74c350779921598f9d5edfed39dd35de8842a",
        "method_before": "        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession();\n    }",
        "method_after": "        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession().invalidate();\n        request.getSession();\n    }"
    },
    {
        "idx": "276",
        "vuln_id": "CVE-2014-2068",
        "desc": "The doIndex function in hudson/util/RemotingDiagnostics.java in CloudBees Jenkins before 1.551 and LTS before 1.532.2 allows remote authenticated users with the ADMINISTER permission to obtain sensitive information via vectors related to heapDump.",
        "cwe_id": "CWE-264",
        "cwe_name": "Permissions, Privileges, and Access Controls",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "0530a6645aac10fec005614211660e98db44b5eb",
        "method_before": "        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.ADMINISTER);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }",
        "method_after": "        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.RUN_SCRIPTS);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }"
    },
    {
        "idx": "363",
        "vuln_id": "CVE-2015-6748",
        "desc": "Cross-site scripting (XSS) vulnerability in jsoup before 1.8.3.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/jhy/jsoup",
        "commit": "4edb78991f8d0bf87dafde5e01ccd8922065c9b2"
    },
    {
        "idx": "379",
        "vuln_id": "CVE-2016-0768",
        "desc": "PostgreSQL PL/Java after 9.0 does not honor access controls on large objects.",
        "cwe_id": "CWE-284",
        "cwe_name": "Improper Access Control",
        "repo": "https://github.com/tada/pljava",
        "commit": "675254b0f17b76f05e72cba2e3b8d3e548ae7a43",
        "method_before": "\tprivate static void languages( Connection c, Statement s)\n\tthrows SQLException\n\t{\n\t\tSavepoint p = null;\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE java IS '\" +\n\t\t\t\t\"Trusted/sandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE javau IS '\" +\n\t\t\t\t\"Untrusted/unsandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\t}",
        "method_after": "\tprivate static void languages( Connection c, Statement s)\n\tthrows SQLException\n\t{\n\t\tSavepoint p = null;\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE java IS '\" +\n\t\t\t\t\"Trusted/sandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\ts.execute(\"REVOKE USAGE ON LANGUAGE java FROM PUBLIC\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE javau IS '\" +\n\t\t\t\t\"Untrusted/unsandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\t}"
    },
    {
        "idx": "427",
        "vuln_id": "CVE-2016-4438",
        "desc": "The REST plugin in Apache Struts 2 2.3.19 through 2.3.28.1 allows remote attackers to execute arbitrary code via a crafted expression.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/apache/struts",
        "commit": "76eb8f38a33ad0f1f48464ee1311559c8d52dd6d"
    },
    {
        "idx": "454",
        "vuln_id": "CVE-2016-5394",
        "desc": "In the XSS Protection API module before 1.0.12 in Apache Sling, the encoding done by the XSSAPI.encodeForJSString() method is not restrictive enough and for some input patterns allows script tags to pass through unencoded, leading to potential XSS vulnerabilities.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/apache/sling",
        "commit": "7d2365a248943071a44d8495655186e4f14ea294"
    },
    {
        "idx": "527",
        "vuln_id": "CVE-2016-8747",
        "desc": "An information disclosure issue was discovered in Apache Tomcat 8.5.7 to 8.5.9 and 9.0.0.M11 to 9.0.0.M15 in reverse-proxy configurations. Http11InputBuffer.java allows remote attackers to read data that was intended to be associated with a different request.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/apache/tomcat",
        "commit": "452c8094a665ef6375530e81c033da4eeb2e4865",
        "method_before": "    void nextRequest() {\n        request.recycle();\n\n        // Copy leftover bytes to the beginning of the buffer\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n        }\n        // Always reset pos to zero\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n    }",
        "method_after": "    void nextRequest() {\n        request.recycle();\n\n        // Copy leftover bytes to the beginning of the buffer\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n            byteBuffer.flip();\n        }\n        // Always reset pos to zero\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n    }"
    },
    {
        "idx": "560",
        "vuln_id": "CVE-2017-12197",
        "desc": "It was found that libpam4j up to and including 1.8 did not properly validate user accounts when authenticating. A user with a valid password for a disabled account would be able to bypass security restrictions and possibly access sensitive information.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/letonez/libpam4j",
        "commit": "84f32f4001fc6bdcc125ccc959081de022d18b6d",
        "method_before": "    public UnixUser authenticate(String username, String password) throws PAMException {\n        this.password = password;\n        try {\n            check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n            check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n            check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n            // several different error code seem to be used to represent authentication failures\n//            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n\n            PointerByReference r = new PointerByReference();\n            check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n            String userName = r.getValue().getString(0);\n            passwd pwd = libc.getpwnam(userName);\n            if(pwd==null)\n                throw new PAMException(\"Authentication succeeded but no user information is available\");\n            return new UnixUser(userName,pwd);\n        } finally {\n            this.password = null;\n        }\n    }",
        "method_after": "    public UnixUser authenticate(String username, String password) throws PAMException {\n        this.password = password;\n        try {\n            check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n            check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n            check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n\n            PointerByReference r = new PointerByReference();\n            check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n            String userName = r.getValue().getString(0);\n            passwd pwd = libc.getpwnam(userName);\n            if(pwd==null)\n                throw new PAMException(\"Authentication succeeded but no user information is available\");\n            return new UnixUser(userName,pwd);\n        } finally {\n            this.password = null;\n        }\n    }"
    },
    {
        "idx": "607",
        "vuln_id": "CVE-2017-18349",
        "desc": "parseObject in Fastjson before 1.2.25, as used in FastjsonEngine in Pippo 1.11.0 and other products, allows remote attackers to execute arbitrary code via a crafted JSON request, as demonstrated by a crafted rmi:// URI in the dataSourceName field of HTTP POST data to the Pippo /json URI, which is mishandled in AjaxApplication.java.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/alibaba/fastjson",
        "commit": "f5903fa56497c00ed0703ac875b511f9bd5f1d8e"
    },
    {
        "idx": "611",
        "vuln_id": "CVE-2017-2670",
        "desc": "It was found in Undertow before 1.3.28 that with non-clean TCP close, the Websocket server gets into infinite loop on every IO thread, effectively causing DoS.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/undertow-io/undertow",
        "commit": "9bfe9fbbb595d51157b61693f072895f7dbadd1d",
        "method_before": "    void resumeReadsInternal(boolean wakeup) {\n        synchronized (lock) {\n            boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n            state |= STATE_READS_RESUMED;\n            if (!alreadyResumed || wakeup) {\n                if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                    state |= STATE_IN_LISTENER_LOOP;\n                    getFramedChannel().runInIoThread(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                boolean moreData;\n                                do {\n                                    ChannelListener<? super R> listener = getReadListener();\n                                    if (listener == null || !isReadResumed()) {\n                                        return;\n                                    }\n                                    ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                    //if writes are shutdown or we become active then we stop looping\n                                    //we stop when writes are shutdown because we can't flush until we are active\n                                    //although we may be flushed as part of a batch\n                                    moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                }\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);\n                            } finally {\n                                state &= ~STATE_IN_LISTENER_LOOP;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }",
        "method_after": "    void resumeReadsInternal(boolean wakeup) {\n        synchronized (lock) {\n            boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n            state |= STATE_READS_RESUMED;\n            if (!alreadyResumed || wakeup) {\n                if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                    state |= STATE_IN_LISTENER_LOOP;\n                    getFramedChannel().runInIoThread(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                boolean moreData;\n                                do {\n                                    ChannelListener<? super R> listener = getReadListener();\n                                    if (listener == null || !isReadResumed()) {\n                                        return;\n                                    }\n                                    ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                    //if writes are shutdown or we become active then we stop looping\n                                    //we stop when writes are shutdown because we can't flush until we are active\n                                    //although we may be flushed as part of a batch\n                                    moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                }\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);\n                            } finally {\n                                state &= ~STATE_IN_LISTENER_LOOP;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }"
    },
    {
        "idx": "612",
        "vuln_id": "CVE-2017-3154",
        "desc": "Error responses from Apache Atlas versions 0.6.0-incubating and 0.7.0-incubating included stack trace, exposing excessive information.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/apache/atlas",
        "commit": "0dcfd21bbfaac6f037f46b7aaaab0e5546fd2a7"
    },
    {
        "idx": "727",
        "vuln_id": "CVE-2018-1000110",
        "desc": "An improper authorization vulnerability exists in Jenkins Git Plugin version 3.7.0 and earlier in GitStatus.java that allows an attacker with network access to obtain a list of nodes and users.",
        "cwe_id": "CWE-863",
        "cwe_name": "Incorrect Authorization",
        "repo": "https://github.com/jenkinsci/git-plugin",
        "commit": "a3d3a7eb7f75bfe97a0291e3b6d074aafafa86c9",
        "method_before": "    public String getSearchUrl() {\n        return getUrlName();\n    }"
    },
    {
        "idx": "743",
        "vuln_id": "CVE-2018-1000820",
        "desc": "neo4j-contrib neo4j-apoc-procedures version before commit 45bc09c contains a XML External Entity (XXE) vulnerability in XML Parser that can result in Disclosure of confidential data, denial of service, SSRF, port scanning. This vulnerability appears to have been fixed in after commit 45bc09c.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/neo4j-contrib/neo4j-apoc-procedures",
        "commit": "45bc09c8bd7f17283e2a7e85ce3f02cb4be4fd1a"
    },
    {
        "idx": "864",
        "vuln_id": "CVE-2018-1324",
        "desc": "A specially crafted ZIP archive can be used to cause an infinite loop inside of Apache Commons Compress' extra field parser used by the ZipFile and ZipArchiveInputStream classes in versions 1.11 to 1.15. This can be used to mount a denial of service attack against services that use Compress' zip package.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "2a2f1dc48e22a34ddb72321a4db211da91aa933b",
        "method_before": "    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }",
        "method_after": "    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (long i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }"
    },
    {
        "idx": "906",
        "vuln_id": "CVE-2018-17202",
        "desc": "Certain input files could make the code to enter into an infinite loop when Apache Sanselan 0.97-incubator was used to parse them, which could be used in a DoS attack. Note that Apache Sanselan (incubating) was renamed to Apache Commons Imaging.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-imaging",
        "commit": "6a79d35d6654d895d0a4b73b3a9282ec9aaeeb06",
        "method_before": "    private int extend(int v, final int t) {\n        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n        int vt = (1 << (t - 1));\n        while (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }",
        "method_after": "    private int extend(int v, final int t) {\n        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n        int vt = (1 << (t - 1));\n        if (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }"
    },
    {
        "idx": "922",
        "vuln_id": "CVE-2018-1999044",
        "desc": "A denial of service vulnerability exists in Jenkins 2.137 and earlier, 2.121.2 and earlier in CronTab.java that allows attackers with Overall/Read permission to have a request handling thread enter an infinite loop.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "e5046911c57e60a1d6d8aca9b21bd9093b0f3763",
        "method_before": "        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,i-offset);\n        }",
        "method_after": "        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n        }"
    },
    {
        "idx": "927",
        "vuln_id": "CVE-2018-20157",
        "desc": "The data import functionality in OpenRefine through 3.1 allows an XML External Entity (XXE) attack through a crafted (zip) file, allowing attackers to read arbitrary files.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/OpenRefine/OpenRefine",
        "commit": "6a0d7d56e4ffb420316ce7849fde881344fbf881",
        "method_before": "    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }",
        "method_after": "    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }"
    },
    {
        "idx": "995",
        "vuln_id": "CVE-2019-0225",
        "desc": "A specially crafted url could be used to access files under the ROOT directory of the application on Apache JSPWiki 2.9.0 to 2.11.0.M2, which could be used by an attacker to obtain registered users' details.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/apache/jspwiki",
        "commit": "88d89d6523802c044cfcb7930cba40d8eeb21da2",
        "method_before": "    public String getForwardPage( HttpServletRequest request )\n    {\n        return request.getPathInfo();\n    }",
        "method_after": "    public String getForwardPage( HttpServletRequest request )\n    {\n        return \"Wiki.jsp\";\n    }"
    },
    {
        "idx": "1047",
        "vuln_id": "CVE-2019-17513",
        "desc": "An issue was discovered in Ratpack before 1.7.5. Due to a misuse of the Netty library class DefaultHttpHeaders, there is no validation that headers lack HTTP control characters. Thus, if untrusted data is used to construct HTTP headers with Ratpack, HTTP Response Splitting can occur.",
        "cwe_id": "CWE-74",
        "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
        "repo": "https://github.com/ratpack/ratpack",
        "commit": "efb910d38a96494256f36675ef0e5061097dd77d",
        "method_before": "  private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }",
        "method_after": "  private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders();\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }"
    },
    {
        "idx": "1076",
        "vuln_id": "CVE-2019-3888",
        "desc": "A vulnerability was found in Undertow web server before 2.0.21. An information exposure of plain text credentials through log files because Connectors.executeRootHandler:402 logs the HttpServerExchange object at ERROR level using UndertowLogger.REQUEST_LOGGER.undertowRequestFailed(t, exchange)",
        "cwe_id": "CWE-532",
        "cwe_name": "Insertion of Sensitive Information into Log File",
        "repo": "https://github.com/undertow-io/undertow",
        "commit": "9bf05b765e222dd106fee9b46314061b18b7275e"
    },
    {
        "idx": "1101",
        "vuln_id": "CVE-2020-11998",
        "desc": "['A regression has been introduced in the commit preventing JMX re-bind. By passing an empty environment map to RMIConnectorServer, instead of the map that contains the authentication credentials, it leaves ActiveMQ open to the following attack: https://docs.oracle.com/javase/8/docs/technotes/guides/management/agent.html \"A remote client could create a javax.management.loading.MLet MBean and use it to create new MBeans from arbitrary URLs, at least if there is no security manager. In other words, a rogue remote client could make your Java application execute arbitrary code.\" Mitigation: Upgrade to Apache ActiveMQ 5.15.13']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/activemq",
        "commit": "aa8900ca70e6f9422490c1a03627400375d3ff83",
        "method_before": "    private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        final Map<String,Object> env = new HashMap<>();\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, env, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }",
        "method_after": "    private void createConnector(MBeanServer mbeanServer) throws MalformedObjectNameException, IOException {\n        // Create the NamingService, needed by JSR 160\n        try {\n            if (registry == null) {\n                LOG.debug(\"Creating RMIRegistry on port {}\", connectorPort);\n                registry = new JmxRegistry(connectorPort);\n            }\n\n            namingServiceObjectName = ObjectName.getInstance(\"naming:type=rmiregistry\");\n\n            // Do not use the createMBean as the mx4j jar may not be in the\n            // same class loader than the server\n            Class<?> cl = Class.forName(\"mx4j.tools.naming.NamingService\");\n            mbeanServer.registerMBean(cl.newInstance(), namingServiceObjectName);\n\n            // set the naming port\n            Attribute attr = new Attribute(\"Port\", Integer.valueOf(connectorPort));\n            mbeanServer.setAttribute(namingServiceObjectName, attr);\n        } catch(ClassNotFoundException e) {\n            LOG.debug(\"Probably not using JRE 1.4: {}\", e.getLocalizedMessage());\n        } catch (Throwable e) {\n            LOG.debug(\"Failed to create local registry. This exception will be ignored.\", e);\n        }\n\n        // Create the JMXConnectorServer\n        String rmiServer = \"\";\n        if (rmiServerPort != 0) {\n            // This is handy to use if you have a firewall and need to force JMX to use fixed ports.\n            rmiServer = \"\"+getConnectorHost()+\":\" + rmiServerPort;\n        }\n\n        server = new RMIJRMPServerImpl(connectorPort, null, null, environment);\n\n        final String serviceURL = \"service:jmx:rmi://\" + rmiServer + \"/jndi/rmi://\" +getConnectorHost()+\":\" + connectorPort + connectorPath;\n        final JMXServiceURL url = new JMXServiceURL(serviceURL);\n\n        connectorServer = new RMIConnectorServer(url, environment, server, ManagementFactory.getPlatformMBeanServer());\n        LOG.debug(\"Created JMXConnectorServer {}\", connectorServer);\n    }"
    },
    {
        "idx": "1110",
        "vuln_id": "CVE-2020-1695",
        "desc": "A flaw was found in all resteasy 3.x.x versions prior to 3.12.0.Final and all resteasy 4.x.x versions prior to 4.6.0.Final, where an improper input validation results in returning an illegal header that integrates into the server's response. This flaw may result in an injection, which leads to unexpected behavior when the HTTP response is constructed.",
        "cwe_id": "CWE-20",
        "cwe_name": "Other",
        "repo": "https://github.com/resteasy/Resteasy",
        "commit": "acf15f2a8067f7e4cf5838342cecfa0b78a174fb",
        "method_before": "   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }",
        "method_after": "   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n            case '\\n':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }"
    },
    {
        "idx": "1112",
        "vuln_id": "CVE-2020-1698",
        "desc": "A flaw was found in keycloak in versions before 9.0.0. A logged exception in the HttpMethod class may leak the password given as parameter. The highest threat from this vulnerability is to data confidentiality.",
        "cwe_id": "CWE-532",
        "cwe_name": "Insertion of Sensitive Information into Log File",
        "repo": "https://github.com/keycloak/keycloak",
        "commit": "62c9e1577618470832ede22dcedd46cba15b1836",
        "method_before": "    public R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n    }",
        "method_after": "    public R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder.getMethod() + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n    }"
    },
    {
        "idx": "1135",
        "vuln_id": "CVE-2020-4070",
        "desc": "In CSS Validator less than or equal to commit 54d68a1, there is a cross-site scripting vulnerability in handling URIs. A user would have to click on a specifically crafted validator link to trigger it. This has been patched in commit e5c09a9.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/w3c/css-validator",
        "commit": "e5c09a9119167d3064db786d5f00d730b584a53b",
        "method_before": "    public void parseURL(ApplContext ac, URL url, String title,\n                         String kind, String media,\n                         int origin) {\n        boolean doneref = false;\n        URL ref = ac.getReferrer();\n        setWarningLevel(ac.getWarningLevel());\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseURL(\" + url + \", \"\n                    + title + \", \"\n                    + kind + \", \" + media + \", \"\n                    + origin + \")\");\n        }\n        if (kind != null) {\n            kind = kind.trim().toLowerCase();\n            if (!kind.equals(\"stylesheet\") && !kind.equals(\"alternate stylesheet\")) {\n                return;\n            }\n        }\n        try {\n            ac.setOrigin(origin);\n//\t    if (cssFouffa == null) {\n            cssFouffa = new CssFouffa(ac, url);\n            cssFouffa.addListener(this);\n//\t    } else {\n//\t\tcssFouffa.ReInit(ac, url);\n//\t    }\n\n            //\t    cssFouffa.setResponse(res);\n\n            // removed plh 2001-03-08\n            // cssFouffa.setOrigin(origin);\n            //\t    cssFouffa.setDefaultMedium(defaultmedium);\n            //\t    cssFouffa.doConfig();\n            if (media == null) {\n                if (ac.getCssVersion() != CssVersion.CSS1) {\n                    if (ac.getMedium() == null) {\n                        media = \"all\";\n                    } else {\n                        media = ac.getMedium();\n                    }\n                }\n            }\n            AtRuleMedia m = AtRuleMedia.getInstance(ac.getCssVersion());\n            try {\n                if (media != null) {\n                    addMedias(m, media, ac);\n                }\n                cssFouffa.setAtRule(m);\n            } catch (org.w3c.css.util.InvalidParamException e) {\n                Errors er = new Errors();\n                er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                        -1, e));\n                notifyErrors(er);\n                return;\n            }\n            ac.setReferrer(url);\n            doneref = true;\n            cssFouffa.parseStyle();\n        } catch (Exception e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(Messages.escapeString(url.toString()),\n                    -1, e));\n            notifyErrors(er);\n        } finally {\n            if (doneref) {\n                ac.setReferrer(ref);\n            }\n        }\n    }",
        "method_after": "    public void parseURL(ApplContext ac, URL url, String title,\n                         String kind, String media,\n                         int origin) {\n        boolean doneref = false;\n        URL ref = ac.getReferrer();\n        setWarningLevel(ac.getWarningLevel());\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseURL(\" + url + \", \"\n                    + title + \", \"\n                    + kind + \", \" + media + \", \"\n                    + origin + \")\");\n        }\n        if (kind != null) {\n            kind = kind.trim().toLowerCase();\n            if (!kind.equals(\"stylesheet\") && !kind.equals(\"alternate stylesheet\")) {\n                return;\n            }\n        }\n        try {\n            ac.setOrigin(origin);\n//\t    if (cssFouffa == null) {\n            cssFouffa = new CssFouffa(ac, url);\n            cssFouffa.addListener(this);\n//\t    } else {\n//\t\tcssFouffa.ReInit(ac, url);\n//\t    }\n\n            //\t    cssFouffa.setResponse(res);\n\n            // removed plh 2001-03-08\n            // cssFouffa.setOrigin(origin);\n            //\t    cssFouffa.setDefaultMedium(defaultmedium);\n            //\t    cssFouffa.doConfig();\n            if (media == null) {\n                if (ac.getCssVersion() != CssVersion.CSS1) {\n                    if (ac.getMedium() == null) {\n                        media = \"all\";\n                    } else {\n                        media = ac.getMedium();\n                    }\n                }\n            }\n            AtRuleMedia m = AtRuleMedia.getInstance(ac.getCssVersion());\n            try {\n                if (media != null) {\n                    addMedias(m, media, ac);\n                }\n                cssFouffa.setAtRule(m);\n            } catch (org.w3c.css.util.InvalidParamException e) {\n                Errors er = new Errors();\n                er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                        -1, e));\n                notifyErrors(er);\n                return;\n            }\n            ac.setReferrer(url);\n            doneref = true;\n            cssFouffa.parseStyle();\n        } catch (Exception e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(Messages.escapeString(url.toString()),\n                    -1, new Exception(Messages.escapeString(e.getMessage()))));\n            notifyErrors(er);\n        } finally {\n            if (doneref) {\n                ac.setReferrer(ref);\n            }\n        }\n    }"
    },
    {
        "idx": "1153",
        "vuln_id": "CVE-2020-7622",
        "desc": "[\"This affects the package io.jooby:jooby-netty before 1.6.9, from 2.0.0 and before 2.2.1. The DefaultHttpHeaders is set to false which means it does not validates that the header isn't being abused for HTTP Response Splitting.\"]",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/jooby-project/jooby",
        "commit": "b66e3342cf95205324023cfdf2cb5811e8a6dcf4"
    },
    {
        "idx": "1357",
        "vuln_id": "CVE-2017-2609",
        "desc": "jenkins before versions 2.44, 2.32.2 is vulnerable to an information disclosure vulnerability in search suggestions (SECURITY-385). The autocomplete feature on the search box discloses the names of the views in its suggestions, including the ones for which the current user does not have access to.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "13905d8224899ba7332fe9af4e330ea96a2ae319"
    },
    {
        "idx": "1429",
        "vuln_id": "CVE-2018-18927",
        "desc": "An issue was discovered in PublicCMS V4.0. It allows XSS by modifying the page_list \"attached\" attribute (which typically has 'class=\"icon-globe icon-large\"' in its value), as demonstrated by an 'UPDATE sys_module SET attached = \"[XSS]\" WHERE id=\"page_list\"' statement.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/sanluan/PublicCMS",
        "commit": "2b411dc2821c69539138aaf7632b938b659a58fa"
    },
    {
        "idx": "1453",
        "vuln_id": "CVE-2019-11065",
        "desc": "['Gradle versions from 1.4 to 5.3.1 use an insecure HTTP URL to download dependencies when the built-in JavaScript or CoffeeScript Gradle plugins are used. Dependency artifacts could have been maliciously compromised by a MITM attack against the ajax.googleapis.com web site.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/gradle/gradle",
        "commit": "7ee79e7e41ec0d4cdb206dc849b2c5b7be7b1854"
    },
    {
        "idx": "1495",
        "vuln_id": "CVE-2019-16370",
        "desc": "The PGP signing plugin in Gradle before 6.0 relies on the SHA-1 algorithm, which might allow an attacker to replace an artifact with a different one that has the same SHA-1 message digest, a related issue to CVE-2005-4900.",
        "cwe_id": "CWE-327",
        "cwe_name": "Use of a Broken or Risky Cryptographic Algorithm",
        "repo": "https://github.com/gradle/gradle",
        "commit": "425b2b7a50cd84106a77cdf1ab665c89c6b14d2f"
    },
    {
        "idx": "1506",
        "vuln_id": "CVE-2019-17091",
        "desc": "faces/context/PartialViewContextImpl.java in Eclipse Mojarra, as used in Mojarra for Eclipse EE4J before 2.3.10 and Mojarra JavaServer Faces before 2.2.20, allows Reflected XSS because a client window field is mishandled.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/eclipse-ee4j/mojarra",
        "commit": "8f70f2bd024f00ecd5b3dcca45df73edda29dcee"
    },
    {
        "idx": "1523",
        "vuln_id": "CVE-2019-20363",
        "desc": "An XSS issue was discovered in Ignite Realtime Openfire 4.4.4 via alias to Manage Store Contents.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/igniterealtime/Openfire",
        "commit": "b6f758241f3fdd57b48c527a695512f33e26eb74"
    },
    {
        "idx": "1561",
        "vuln_id": "CVE-2020-21522",
        "desc": "An issue was discovered in halo V1.1.3. A Zip Slip Directory Traversal Vulnerability in the backend,the attacker can overwrite some files, such as ftl files, .bashrc files in the user directory, and finally get the permissions of the operating system.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/halo-dev/halo",
        "commit": "d59877a9ce82b53ec27c7f012a5703280e2cfd4f",
        "method_before": "    public static void checkDirectoryTraversal(@NonNull Path parentPath, @NonNull Path pathToCheck) {\n        Assert.notNull(parentPath, \"Parent path must not be null\");\n        Assert.notNull(pathToCheck, \"Path to check must not be null\");\n\n        if (pathToCheck.startsWith(parentPath.normalize())) {\n            return;\n        }\n\n        throw new ForbiddenException(\"\u4f60\u6ca1\u6709\u6743\u9650\u8bbf\u95ee \" + pathToCheck).setErrorData(pathToCheck);\n    }",
        "method_after": "    public static void checkDirectoryTraversal(@NonNull Path parentPath, @NonNull Path pathToCheck) {\n        Assert.notNull(parentPath, \"Parent path must not be null\");\n        Assert.notNull(pathToCheck, \"Path to check must not be null\");\n\n        if (pathToCheck.normalize().startsWith(parentPath)) {\n            return;\n        }\n\n        throw new ForbiddenException(\"\u4f60\u6ca1\u6709\u6743\u9650\u8bbf\u95ee \" + pathToCheck).setErrorData(pathToCheck);\n    }"
    },
    {
        "idx": "1569",
        "vuln_id": "CVE-2020-26217",
        "desc": "XStream before version 1.4.14 is vulnerable to Remote Code Execution.The vulnerability may allow a remote attacker to run arbitrary shell commands only by manipulating the processed input stream. Only users who rely on blocklists are affected. Anyone using XStream's Security Framework allowlist is not affected. The linked advisory provides code workarounds for users who cannot upgrade. The issue is fixed in version 1.4.14.",
        "cwe_id": "CWE-78",
        "cwe_name": "Improper Neutralization of Special Elements used in an OS Command ('OS Command Injection')",
        "repo": "https://github.com/x-stream/xstream",
        "commit": "0fec095d534126931c99fd38e9c6d41f5c685c1a"
    },
    {
        "idx": "1617",
        "vuln_id": "unknown-106",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "dd10265436ea8b2fe35f1a8b09bc7390acbea269",
        "method_before": "    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"Security checking request \" +\n                request.getMethod() + \" \" + request.getRequestURI());\n        LoginConfig config = this.context.getLoginConfig();\n\n        // Have we got a cached authenticated Principal to record?\n        if (cache) {\n            Principal principal = request.getUserPrincipal();\n            if (principal == null) {\n                Session session = request.getSessionInternal(false);\n                if (session != null) {\n                    principal = session.getPrincipal();\n                    if (principal != null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"We have cached auth type \" +\n                                session.getAuthType() +\n                                \" for principal \" +\n                                session.getPrincipal());\n                        request.setAuthType(session.getAuthType());\n                        request.setUserPrincipal(principal);\n                    }\n                }\n            }\n        }\n\n        // Special handling for form-based logins to deal with the case\n        // where the login form (and therefore the \"j_security_check\" URI\n        // to which it submits) might be outside the secured area\n        String contextPath = this.context.getPath();\n        String requestURI = request.getDecodedRequestURI();\n        if (requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION)) {\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled())\n                    log.debug(\" Failed authenticate() test ??\" + requestURI );\n                return;\n            }\n        }\n\n        // The Servlet may specify security constraints through annotations.\n        // Ensure that they have been processed before constraints are checked\n        Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; \n        if (wrapper.getServlet() != null) {\n            wrapper.load();\n        }\n\n        Realm realm = this.context.getRealm();\n        // Is this request URI subject to a security constraint?\n        SecurityConstraint [] constraints\n            = realm.findSecurityConstraints(request, this.context);\n       \n        if ((constraints == null) /* &&\n            (!Constants.FORM_METHOD.equals(config.getAuthMethod())) */ ) {\n            if (log.isDebugEnabled())\n                log.debug(\" Not subject to any constraint\");\n            getNext().invoke(request, response);\n            return;\n        }\n\n        // Make sure that constrained resources are not cached by web proxies\n        // or browsers as caching can provide a security hole\n        if (disableProxyCaching && \n            // FIXME: Disabled for Mozilla FORM support over SSL \n            // (improper caching issue)\n            //!request.isSecure() &&\n            !\"POST\".equalsIgnoreCase(request.getMethod())) {\n            if (securePagesWithPragma) {\n                // FIXME: These cause problems with downloading office docs\n                // from IE under SSL and may not be needed for newer Mozilla\n                // clients.\n                response.setHeader(\"Pragma\", \"No-cache\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n            } else {\n                response.setHeader(\"Cache-Control\", \"private\");\n            }\n            response.setHeader(\"Expires\", DATE_ONE);\n        }\n\n        int i;\n        // Enforce any user data constraint for this security constraint\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling hasUserDataPermission()\");\n        }\n        if (!realm.hasUserDataPermission(request, response,\n                                         constraints)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed hasUserDataPermission() test\");\n            }\n            /*\n             * ASSERT: Authenticator already set the appropriate\n             * HTTP status code, so we do not have to do anything special\n             */\n            return;\n        }\n\n        // Since authenticate modifies the response on failure,\n        // we have to check for allow-from-all first.\n        boolean authRequired = true;\n        for(i=0; i < constraints.length && authRequired; i++) {\n            if(!constraints[i].getAuthConstraint()) {\n                authRequired = false;\n            } else if(!constraints[i].getAllRoles()) {\n                String [] roles = constraints[i].findAuthRoles();\n                if(roles == null || roles.length == 0) {\n                    authRequired = false;\n                }\n            }\n        }\n             \n        if(authRequired) {  \n            if (log.isDebugEnabled()) {\n                log.debug(\" Calling authenticate()\");\n            }\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\" Failed authenticate() test\");\n                }\n                /*\n                 * ASSERT: Authenticator already set the appropriate\n                 * HTTP status code, so we do not have to do anything\n                 * special\n                 */\n                return;\n            } \n            \n        }\n    \n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling accessControl()\");\n        }\n        if (!realm.hasResourcePermission(request, response,\n                                         constraints,\n                                         this.context)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed accessControl() test\");\n            }\n            /*\n             * ASSERT: AccessControl method has already set the\n             * appropriate HTTP status code, so we do not have to do\n             * anything special\n             */\n            return;\n        }\n    \n        // Any and all specified constraints have been satisfied\n        if (log.isDebugEnabled()) {\n            log.debug(\" Successfully passed all security constraints\");\n        }\n        getNext().invoke(request, response);\n\n    }",
        "method_after": "    public void invoke(Request request, Response response)\n        throws IOException, ServletException {\n\n        if (log.isDebugEnabled())\n            log.debug(\"Security checking request \" +\n                request.getMethod() + \" \" + request.getRequestURI());\n        LoginConfig config = this.context.getLoginConfig();\n\n        // Have we got a cached authenticated Principal to record?\n        if (cache) {\n            Principal principal = request.getUserPrincipal();\n            if (principal == null) {\n                Session session = request.getSessionInternal(false);\n                if (session != null) {\n                    principal = session.getPrincipal();\n                    if (principal != null) {\n                        if (log.isDebugEnabled())\n                            log.debug(\"We have cached auth type \" +\n                                session.getAuthType() +\n                                \" for principal \" +\n                                session.getPrincipal());\n                        request.setAuthType(session.getAuthType());\n                        request.setUserPrincipal(principal);\n                    }\n                }\n            }\n        }\n\n        // Special handling for form-based logins to deal with the case\n        // where the login form (and therefore the \"j_security_check\" URI\n        // to which it submits) might be outside the secured area\n        String contextPath = this.context.getPath();\n        String requestURI = request.getDecodedRequestURI();\n        if (requestURI.startsWith(contextPath) &&\n            requestURI.endsWith(Constants.FORM_ACTION)) {\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled())\n                    log.debug(\" Failed authenticate() test ??\" + requestURI );\n                return;\n            }\n        }\n\n        // The Servlet may specify security constraints through annotations.\n        // Ensure that they have been processed before constraints are checked\n        Wrapper wrapper = (Wrapper) request.getMappingData().wrapper; \n        if (wrapper.getServlet() == null) {\n            wrapper.load();\n        }\n\n        Realm realm = this.context.getRealm();\n        // Is this request URI subject to a security constraint?\n        SecurityConstraint [] constraints\n            = realm.findSecurityConstraints(request, this.context);\n       \n        if ((constraints == null) /* &&\n            (!Constants.FORM_METHOD.equals(config.getAuthMethod())) */ ) {\n            if (log.isDebugEnabled())\n                log.debug(\" Not subject to any constraint\");\n            getNext().invoke(request, response);\n            return;\n        }\n\n        // Make sure that constrained resources are not cached by web proxies\n        // or browsers as caching can provide a security hole\n        if (disableProxyCaching && \n            // FIXME: Disabled for Mozilla FORM support over SSL \n            // (improper caching issue)\n            //!request.isSecure() &&\n            !\"POST\".equalsIgnoreCase(request.getMethod())) {\n            if (securePagesWithPragma) {\n                // FIXME: These cause problems with downloading office docs\n                // from IE under SSL and may not be needed for newer Mozilla\n                // clients.\n                response.setHeader(\"Pragma\", \"No-cache\");\n                response.setHeader(\"Cache-Control\", \"no-cache\");\n            } else {\n                response.setHeader(\"Cache-Control\", \"private\");\n            }\n            response.setHeader(\"Expires\", DATE_ONE);\n        }\n\n        int i;\n        // Enforce any user data constraint for this security constraint\n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling hasUserDataPermission()\");\n        }\n        if (!realm.hasUserDataPermission(request, response,\n                                         constraints)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed hasUserDataPermission() test\");\n            }\n            /*\n             * ASSERT: Authenticator already set the appropriate\n             * HTTP status code, so we do not have to do anything special\n             */\n            return;\n        }\n\n        // Since authenticate modifies the response on failure,\n        // we have to check for allow-from-all first.\n        boolean authRequired = true;\n        for(i=0; i < constraints.length && authRequired; i++) {\n            if(!constraints[i].getAuthConstraint()) {\n                authRequired = false;\n            } else if(!constraints[i].getAllRoles()) {\n                String [] roles = constraints[i].findAuthRoles();\n                if(roles == null || roles.length == 0) {\n                    authRequired = false;\n                }\n            }\n        }\n             \n        if(authRequired) {  \n            if (log.isDebugEnabled()) {\n                log.debug(\" Calling authenticate()\");\n            }\n            if (!authenticate(request, response, config)) {\n                if (log.isDebugEnabled()) {\n                    log.debug(\" Failed authenticate() test\");\n                }\n                /*\n                 * ASSERT: Authenticator already set the appropriate\n                 * HTTP status code, so we do not have to do anything\n                 * special\n                 */\n                return;\n            } \n            \n        }\n    \n        if (log.isDebugEnabled()) {\n            log.debug(\" Calling accessControl()\");\n        }\n        if (!realm.hasResourcePermission(request, response,\n                                         constraints,\n                                         this.context)) {\n            if (log.isDebugEnabled()) {\n                log.debug(\" Failed accessControl() test\");\n            }\n            /*\n             * ASSERT: AccessControl method has already set the\n             * appropriate HTTP status code, so we do not have to do\n             * anything special\n             */\n            return;\n        }\n    \n        // Any and all specified constraints have been satisfied\n        if (log.isDebugEnabled()) {\n            log.debug(\" Successfully passed all security constraints\");\n        }\n        getNext().invoke(request, response);\n\n    }"
    },
    {
        "idx": "1618",
        "vuln_id": "unknown-107",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/eXist-db/exist",
        "commit": "d20c37b2193f413c34f3e0d277ca125a3315a258"
    },
    {
        "idx": "1624",
        "vuln_id": "unknown-112",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/spring-projects/spring-security-oauth",
        "commit": "34c814d6f96daeba5c5765058b85bf3d095b9696",
        "method_before": "\tprotected boolean redirectMatches(String requestedRedirect, String redirectUri) {\n\t\ttry {\n\t\t\tURL req = new URL(requestedRedirect);\n\t\t\tURL reg = new URL(redirectUri);\n\n\t\t\tif (reg.getProtocol().equals(req.getProtocol()) && hostMatches(reg.getHost(), req.getHost())) {\n\t\t\t\treturn req.getPath().startsWith(reg.getPath());\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException e) {\n\t\t}\n\t\treturn requestedRedirect.equals(redirectUri);\n\t}",
        "method_after": "\tprotected boolean redirectMatches(String requestedRedirect, String redirectUri) {\n\t\ttry {\n\t\t\tURL req = new URL(requestedRedirect);\n\t\t\tURL reg = new URL(redirectUri);\n\n\t\t\tif (reg.getProtocol().equals(req.getProtocol()) && hostMatches(reg.getHost(), req.getHost())) {\n\t\t\t\treturn StringUtils.cleanPath(req.getPath()).startsWith(StringUtils.cleanPath(reg.getPath()));\n\t\t\t}\n\t\t}\n\t\tcatch (MalformedURLException e) {\n\t\t}\n\t\treturn requestedRedirect.equals(redirectUri);\n\t}"
    },
    {
        "idx": "1630",
        "vuln_id": "unknown-118",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/gradle/gradle",
        "commit": "2a76ae8066fb187f772672c85954793654637204",
        "method_before": "        public ConnectionWorker(RemoteConnection<Message> connection) {\n            this.connection = connection;\n        }\n\n        public void run() {\n            try {\n                receiveAndHandleCommand();\n            } finally {\n                onFinishHandling(connection);\n            }\n        }\n\n        private void receiveAndHandleCommand() {\n            try {\n                DefaultDaemonConnection daemonConnection = new DefaultDaemonConnection(connection, executorFactory);\n                try {\n                    Command command = receiveCommand(daemonConnection);\n                    if (command != null) {\n                        handleCommand(command, daemonConnection);\n                    }\n                } finally {\n                    daemonConnection.stop();\n                }\n            } finally {\n                connection.stop();\n            }\n        }\n\n        private Command receiveCommand(DaemonConnection daemonConnection) {\n            try {\n                Command command = (Command) daemonConnection.receive(120, TimeUnit.SECONDS);\n                LOGGER.info(\"Received command: {}.\", command);\n                return command;\n            } catch (Throwable e) {\n                LOGGER.warn(String.format(\"Unable to receive command from %s. Dispatching the failure to the daemon client\", connection), e);\n                daemonConnection.completed(new Failure(e));\n                return null;\n            }\n        }",
        "method_after": "        public ConnectionWorker(RemoteConnection<Message> connection) {\n            this.connection = connection;\n        }\n\n        public void run() {\n            try {\n                receiveAndHandleCommand();\n            } finally {\n                onFinishHandling(connection);\n            }\n        }\n\n        private void receiveAndHandleCommand() {\n            try {\n                DefaultDaemonConnection daemonConnection = new DefaultDaemonConnection(connection, executorFactory);\n                try {\n                    Command command = receiveCommand(daemonConnection);\n                    if (command != null) {\n                        handleCommand(command, daemonConnection);\n                    }\n                } finally {\n                    daemonConnection.stop();\n                }\n            } finally {\n                connection.stop();\n            }\n        }\n\n        private Command receiveCommand(DaemonConnection daemonConnection) {\n            try {\n                Command command = (Command) daemonConnection.receive(120, TimeUnit.SECONDS);\n                LOGGER.info(\"Received command: {}.\", command);\n                return command;\n            } catch (Throwable e) {\n                LOGGER.warn(String.format(\"Unable to receive command from %s. Discarding connection.\", connection), e);\n                return null;\n            }\n        }"
    },
    {
        "idx": "1651",
        "vuln_id": "unknown-137",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/halo-dev/halo",
        "commit": "568e48733fc3e325bf5592a05d609e665f5ad71e",
        "method_before": "    public static Element getRootElement(FileInputStream fileInputStream) {\n        try {\n            SAXReader saxReader = new SAXReader();\n            Document document = saxReader.read(fileInputStream);\n            return document.getRootElement();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not get root element\");\n        }\n    }",
        "method_after": "    public static Element getRootElement(FileInputStream fileInputStream) {\n        try {\n            SAXReader saxReader = new SAXReader();\n            Document document = saxReader.read(fileInputStream);\n            saxReader.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n            return document.getRootElement();\n        } catch (Exception e) {\n            throw new RuntimeException(\"can not get root element\");\n        }\n    }"
    },
    {
        "idx": "1660",
        "vuln_id": "unknown-145",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "66a560d71743a41667d09d8632973db4ca2c0541"
    },
    {
        "idx": "1671",
        "vuln_id": "unknown-155",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/gradle/gradle",
        "commit": "f50bb2513f8880f75db2c2b3f1badbae856f6f85",
        "method_before": "    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA1));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }",
        "method_after": "    public PGPSignatureGenerator createSignatureGenerator() {\n        try {\n            PGPSignatureGenerator generator = new PGPSignatureGenerator(new BcPGPContentSignerBuilder(secretKey.getPublicKey().getAlgorithm(), PGPUtil.SHA512));\n            generator.init(PGPSignature.BINARY_DOCUMENT, privateKey);\n            return generator;\n        } catch (PGPException e) {\n            throw UncheckedException.throwAsUncheckedException(e);\n        }\n    }"
    },
    {
        "idx": "1674",
        "vuln_id": "unknown-158",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "1e7b31e24801777f4de45d565f6a20a5377dd22c",
        "method_before": "    protected DocumentBuilder getDocumentBuilder()\n        throws ServletException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch(ParserConfigurationException e) {\n            throw new ServletException\n                (sm.getString(\"webdavservlet.jaxpfailed\"));\n        }\n        return documentBuilder;\n    }",
        "method_after": "    protected DocumentBuilder getDocumentBuilder()\n        throws ServletException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setExpandEntityReferences(false);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch(ParserConfigurationException e) {\n            throw new ServletException\n                (sm.getString(\"webdavservlet.jaxpfailed\"));\n        }\n        return documentBuilder;\n    }"
    },
    {
        "idx": "1692",
        "vuln_id": "unknown-174",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "69a8a72283c3395ece8b899cf8562e126de97a27"
    },
    {
        "idx": "1694",
        "vuln_id": "unknown-176",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/igniterealtime/Openfire",
        "commit": "3a6976f0607808f5f5a33540a39f780895dbdb8b",
        "method_before": "    public static void setCookie(HttpServletRequest request, HttpServletResponse response,\n            String name, String value, int maxAge)\n    {\n        // Check to make sure the new value is not null (appservers like Tomcat\n        // 4 blow up if the value is null).\n        if (value == null) {\n            value = \"\";\n        }\n        String path = request.getContextPath() == null ? \"/\" : request.getContextPath();\n        if (\"\".equals(path)) {\n            path = \"/\";\n        }\n        Cookie cookie = new Cookie(name, value);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n        response.addCookie(cookie);\n    }",
        "method_after": "    public static void setCookie(HttpServletRequest request, HttpServletResponse response,\n            String name, String value, int maxAge)\n    {\n        // Check to make sure the new value is not null (appservers like Tomcat\n        // 4 blow up if the value is null).\n        if (value == null) {\n            value = \"\";\n        }\n        String path = request.getContextPath() == null ? \"/\" : request.getContextPath();\n        if (\"\".equals(path)) {\n            path = \"/\";\n        }\n        Cookie cookie = new Cookie(name, value);\n        cookie.setMaxAge(maxAge);\n        cookie.setPath(path);\n        cookie.setHttpOnly(true);\n        response.addCookie(cookie);\n    }"
    },
    {
        "idx": "1707",
        "vuln_id": "unknown-188",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "2f0f80a6c36d6875c64f8c857e2e26661a3865d4",
        "method_before": "    private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return locale.toString();//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }",
        "method_after": "    private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return escapeXml(locale.toString());//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }"
    },
    {
        "idx": "1716",
        "vuln_id": "unknown-196",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "6295aac1f04faa22dff23bb95e42ecad9f9033e0",
        "method_before": "    public static User get(String id, boolean create) {\n        if(id==null)\n            return null;\n        id = id.replace('\\\\', '_').replace('/', '_');\n        \n        synchronized(byName) {\n            User u = byName.get(id);\n            if(u==null && create) {\n                u = new User(id);\n                byName.put(id,u);\n            }\n            return u;\n        }\n    }",
        "method_after": "    public static User get(String id, boolean create) {\n        if(id==null)\n            return null;\n        id = id.replace('\\\\', '_').replace('/', '_').replace('<','_');\n        \n        synchronized(byName) {\n            User u = byName.get(id);\n            if(u==null && create) {\n                u = new User(id);\n                byName.put(id,u);\n            }\n            return u;\n        }\n    }"
    },
    {
        "idx": "1726",
        "vuln_id": "unknown-204",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/SonarSource/sonarqube",
        "commit": "09534faa716dc27bdcc9597cbe27cbae672267f5",
        "method_before": "  public void handle(Request request, Response response) throws Exception {\n    Date timestamp = request.paramAsDateTime(TS_PARAM);\n    if (timestamp != null && timestamp.after(server.getStartedAt())) {\n      response.stream().setStatus(HTTP_NOT_MODIFIED).output().close();\n      return;\n    }\n    String localeParam = request.mandatoryParam(LOCALE_PARAM);\n    Locale locale = Locale.forLanguageTag(localeParam);\n    checkArgument(!locale.getISO3Language().isEmpty(), \"'%s' cannot be parsed as a BCP47 language tag\", localeParam);\n\n    try (JsonWriter json = response.newJsonWriter()) {\n      json.beginObject();\n      json.prop(\"effectiveLocale\", i18n.getEffectiveLocale(locale).toLanguageTag());\n      json.name(\"messages\");\n      json.beginObject();\n      i18n.getPropertyKeys().forEach(messageKey -> json.prop(messageKey, i18n.message(locale, messageKey, messageKey)));\n      json.endObject();\n      json.endObject();\n    }\n  }",
        "method_after": "  public void handle(Request request, Response response) throws Exception {\n    Date timestamp = request.paramAsDateTime(TS_PARAM);\n    if (timestamp != null && timestamp.after(server.getStartedAt())) {\n      response.stream().setStatus(HTTP_NOT_MODIFIED).output().close();\n      return;\n    }\n    String localeParam = request.mandatoryParam(LOCALE_PARAM);\n    Locale locale = Locale.forLanguageTag(localeParam);\n    checkArgument(!locale.getISO3Language().isEmpty(), \"Locale cannot be parsed as a BCP47 language tag\");\n\n    try (JsonWriter json = response.newJsonWriter()) {\n      json.beginObject();\n      json.prop(\"effectiveLocale\", i18n.getEffectiveLocale(locale).toLanguageTag());\n      json.name(\"messages\");\n      json.beginObject();\n      i18n.getPropertyKeys().forEach(messageKey -> json.prop(messageKey, i18n.message(locale, messageKey, messageKey)));\n      json.endObject();\n      json.endObject();\n    }\n  }"
    },
    {
        "idx": "1728",
        "vuln_id": "unknown-206",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/struts",
        "commit": "f420f28466cb82915defc4e12466b298c275abaf"
    },
    {
        "idx": "1733",
        "vuln_id": "unknown-210",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/opennetworkinglab/onos",
        "commit": "ebb9315a4aed6c691ff1a7e44d0d169a93362203",
        "method_before": "    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"sage: onos-lib-gen <input-deps.json> <output-workspace.bzl>\");\n            System.exit(5);\n        }\n\n        // Parse args\n        String jsonFilePath = args[0];\n        String outputWorkspaceFilePath = args[1];\n\n        // Load and parse input JSON file\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n        ObjectNode json = (ObjectNode) mapper.reader()\n                .readTree(new FileInputStream(jsonFilePath));\n\n        // Traverse dependencies and build a dependency graph (DAG)\n        org.onosproject.libgen.BazelLibGenerator generator = new org.onosproject.libgen.BazelLibGenerator(json).resolve();\n\n        // Write the output workspace file\n        generator.write(outputWorkspaceFilePath);\n        System.out.printf(\"\\nFinish writing %s\\n\", outputWorkspaceFilePath);\n    }",
        "method_after": "    public static void main(String[] args) throws Exception {\n        if (args.length < 2) {\n            System.err.println(\"usage: onos-lib-gen <input-deps.json> <output-workspace.bzl>\");\n            System.exit(5);\n        }\n\n        // Parse args\n        String jsonFilePath = args[0];\n        String outputWorkspaceFilePath = args[1];\n\n        // Load and parse input JSON file\n        ObjectMapper mapper = new ObjectMapper();\n        mapper.configure(JsonParser.Feature.ALLOW_COMMENTS, true);\n        ObjectNode json = (ObjectNode) mapper.reader()\n                .readTree(new FileInputStream(jsonFilePath));\n\n        // Traverse dependencies and build a dependency graph (DAG)\n        org.onosproject.libgen.BazelLibGenerator generator = new org.onosproject.libgen.BazelLibGenerator(json).resolve();\n\n        // Write the output workspace file\n        generator.write(outputWorkspaceFilePath);\n        System.out.printf(\"\\nFinish writing %s\\n\", outputWorkspaceFilePath);\n    }"
    },
    {
        "idx": "1749",
        "vuln_id": "unknown-225",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/OHDSI/WebAPI",
        "commit": "b033bd61c7a1572b48342e3cde2b816844295b8b",
        "method_before": "  public static void insertInclusionRules(CohortDefinition cohortDef, Source source, int designHash,\n                                          String targetSchema, String sessionId, JdbcTemplate jdbcTemplate) {\n    final String oracleTempSchema = SourceUtils.getTempQualifier(source);\n    String deleteSql = String.format(\"DELETE FROM %s.cohort_inclusion WHERE cohort_definition_id = %d;\", targetSchema, cohortDef.getId());\n    String translatedDeleteSql = SqlTranslate.translateSql(deleteSql, source.getSourceDialect(), sessionId, oracleTempSchema);\n    Arrays.stream(SqlSplit.splitSql(translatedDeleteSql)).forEach(jdbcTemplate::execute);\n\n    String insertSql = StringUtils.replace(\"INSERT INTO @target_schema.cohort_inclusion (cohort_definition_id, design_hash, rule_sequence, name, description) VALUES (?,?,?,?,?)\", \"@target_schema\", targetSchema);\n    String translatedInsertSql = SqlTranslate.translateSql(insertSql, source.getSourceDialect(), sessionId, oracleTempSchema);\n    List<InclusionRule> inclusionRules = cohortDef.getExpression().inclusionRules;\n    for (int i = 0; i< inclusionRules.size(); i++)\n    {\n      InclusionRule r = inclusionRules.get(i);\n      jdbcTemplate.update(translatedInsertSql, new Object[] { cohortDef.getId(), designHash, i, r.name, r.description});\n    }\n  }",
        "method_after": "  public static void insertInclusionRules(CohortDefinition cohortDef, Source source, int designHash,\n                                          String targetSchema, String sessionId, JdbcTemplate jdbcTemplate) {\n    final String oracleTempSchema = SourceUtils.getTempQualifier(source);\n    String deleteSql = String.format(\"DELETE FROM %s.cohort_inclusion WHERE cohort_definition_id = %d\", targetSchema, cohortDef.getId());\n    String translatedDeleteSql = SqlTranslate.translateSql(deleteSql, source.getSourceDialect(), sessionId, oracleTempSchema);\n    Arrays.stream(SqlSplit.splitSql(translatedDeleteSql)).forEach(jdbcTemplate::execute);\n\n    String insertSql = StringUtils.replace(\"INSERT INTO @target_schema.cohort_inclusion (cohort_definition_id, design_hash, rule_sequence, name, description) VALUES (?,?,?,?,?)\", \"@target_schema\", targetSchema);\n    String translatedInsertSql = SqlTranslate.translateSql(insertSql, source.getSourceDialect(), sessionId, oracleTempSchema);\n    List<InclusionRule> inclusionRules = cohortDef.getExpression().inclusionRules;\n    for (int i = 0; i< inclusionRules.size(); i++)\n    {\n      InclusionRule r = inclusionRules.get(i);\n      jdbcTemplate.update(translatedInsertSql, new Object[] { cohortDef.getId(), designHash, i, r.name, r.description});\n    }\n  }"
    },
    {
        "idx": "1759",
        "vuln_id": "unknown-234",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/qpid-broker-j",
        "commit": "1d6a129a97d3eb29c8c53b6becac9702c674fb50",
        "method_before": "    public SaltAndPasswordKeys getSaltAndPasswordKeys(final String username)\n    {\n        ManagedUser user = getUser(username);\n\n        final byte[] salt;\n        final byte[] storedKey;\n        final byte[] serverKey;\n        final int iterationCount;\n        final SaslException exception;\n\n        if(user == null)\n        {\n            // don't disclose that the user doesn't exist, just generate random data so the failure is indistinguishable\n            // from the \"wrong password\" case.\n            salt = generateSalt();\n            storedKey = null;\n            serverKey = null;\n            iterationCount = -1;\n            exception = new SaslException(\"Authentication Failed\");\n        }\n        else\n        {\n            updateStoredPasswordFormatIfNecessary(user);\n            final String[] passwordFields = user.getPassword().split(\",\");\n            salt = Strings.decodeBase64(passwordFields[PasswordField.SALT.ordinal()]);\n            storedKey = Strings.decodeBase64(passwordFields[PasswordField.STORED_KEY.ordinal()]);\n            serverKey = Strings.decodeBase64(passwordFields[PasswordField.SERVER_KEY.ordinal()]);\n            iterationCount = Integer.parseInt(passwordFields[PasswordField.ITERATION_COUNT.ordinal()]);\n            exception = null;\n        }\n\n        return new SaltAndPasswordKeys()\n        {\n            @Override\n            public byte[] getSalt()\n            {\n                return salt;\n            }\n\n            @Override\n            public byte[] getStoredKey() throws SaslException\n            {\n                if(storedKey == null)\n                {\n                    throw exception;\n                }\n                return storedKey;\n            }\n\n            @Override\n            public byte[] getServerKey() throws SaslException\n            {\n                if(serverKey == null)\n                {\n                    throw exception;\n                }\n                return serverKey;\n            }\n\n            @Override\n            public int getIterationCount() throws SaslException\n            {\n                if(iterationCount < 0)\n                {\n                    throw exception;\n                }\n                return iterationCount;\n            }\n        };\n    }",
        "method_after": "    public SaltAndPasswordKeys getSaltAndPasswordKeys(final String username)\n    {\n        ManagedUser user = getUser(username);\n\n        final byte[] salt;\n        final byte[] storedKey;\n        final byte[] serverKey;\n        final int iterationCount;\n        final SaslException exception;\n\n        if(user == null)\n        {\n            // don't disclose that the user doesn't exist, just generate random data so the failure is indistinguishable\n            // from the \"wrong password\" case.\n            salt = generateSalt();\n            storedKey = null;\n            serverKey = null;\n            iterationCount = getIterationCount();\n            exception = new SaslException(\"Authentication Failed\");\n        }\n        else\n        {\n            updateStoredPasswordFormatIfNecessary(user);\n            final String[] passwordFields = user.getPassword().split(\",\");\n            salt = Strings.decodeBase64(passwordFields[PasswordField.SALT.ordinal()]);\n            storedKey = Strings.decodeBase64(passwordFields[PasswordField.STORED_KEY.ordinal()]);\n            serverKey = Strings.decodeBase64(passwordFields[PasswordField.SERVER_KEY.ordinal()]);\n            iterationCount = Integer.parseInt(passwordFields[PasswordField.ITERATION_COUNT.ordinal()]);\n            exception = null;\n        }\n\n        return new SaltAndPasswordKeys()\n        {\n            @Override\n            public byte[] getSalt()\n            {\n                return salt;\n            }\n\n            @Override\n            public byte[] getStoredKey() throws SaslException\n            {\n                if(storedKey == null)\n                {\n                    throw exception;\n                }\n                return storedKey;\n            }\n\n            @Override\n            public byte[] getServerKey() throws SaslException\n            {\n                if(serverKey == null)\n                {\n                    throw exception;\n                }\n                return serverKey;\n            }\n\n            @Override\n            public int getIterationCount() throws SaslException\n            {\n                if(iterationCount < 0)\n                {\n                    throw exception;\n                }\n                return iterationCount;\n            }\n        };\n    }"
    },
    {
        "idx": "1773",
        "vuln_id": "unknown-247",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/cloudfoundry-incubator/credhub",
        "commit": "18a81dd0fc1362d172e4c15af9d52ced45bec16e"
    },
    {
        "idx": "1780",
        "vuln_id": "unknown-253",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/eclipse-ee4j/mojarra",
        "commit": "a3fa9573789ed5e867c43ea38374f4dbd5a8f81f",
        "method_before": "    private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.write(window.getId());\n            writer.endUpdate();\n        }\n    }",
        "method_after": "    private void renderState(FacesContext context) throws IOException {\n        // Get the view state and write it to the response..\n        PartialViewContext pvc = context.getPartialViewContext();\n        PartialResponseWriter writer = pvc.getPartialResponseWriter();\n        String viewStateId = Util.getViewStateId(context);\n\n        writer.startUpdate(viewStateId);\n        String state = context.getApplication().getStateManager().getViewState(context);\n        writer.write(state);\n        writer.endUpdate();\n\n        ClientWindow window = context.getExternalContext().getClientWindow();\n        if (null != window) {\n            String clientWindowId = Util.getClientWindowId(context);\n            writer.startUpdate(clientWindowId);\n            writer.writeText(window.getId(), null);\n            writer.endUpdate();\n        }\n    }"
    },
    {
        "idx": "1788",
        "vuln_id": "unknown-260",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "b1d1047a4c0a7754cabf57ac0303f92e4e77ef58",
        "method_before": "    protected synchronized void authenticatorConfig() {\n\n        // Does this Context require an Authenticator?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0))\n            return;\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null)\n            return;\n        \n        if (!(context instanceof ContainerBase)) {\n            return;     // Cannot install a Valve even if it would be needed\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve)\n                customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n        if (authenticator == null) {\n            // Load our mapping properties if necessary\n            if (authenticators == null) {\n                try {\n                    InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                    if( is!=null ) {\n                        authenticators = new Properties();\n                        authenticators.load(is);\n                    } else {\n                        log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"));\n                        ok=false;\n                        return;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"), e);\n                    ok = false;\n                    return;\n                }\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = null;\n            authenticatorName =\n                    authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null && context instanceof ContainerBase) {\n            Pipeline pipeline = ((ContainerBase) context).getPipeline();\n            if (pipeline != null) {\n                ((ContainerBase) context).getPipeline().addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n\n    }",
        "method_after": "    protected synchronized void authenticatorConfig() {\n\n        // Always need an authenticator to support @ServletSecurity annotations\n        LoginConfig loginConfig = context.getLoginConfig();\n        if (loginConfig == null) {\n            loginConfig = DUMMY_LOGIN_CONFIG;\n            context.setLoginConfig(loginConfig);\n        }\n\n        // Has an authenticator been configured already?\n        if (context.getAuthenticator() != null)\n            return;\n        \n        if (!(context instanceof ContainerBase)) {\n            return;     // Cannot install a Valve even if it would be needed\n        }\n\n        // Has a Realm been configured for us to authenticate against?\n        if (context.getRealm() == null) {\n            log.error(sm.getString(\"contextConfig.missingRealm\"));\n            ok = false;\n            return;\n        }\n\n        /*\n         * First check to see if there is a custom mapping for the login\n         * method. If so, use it. Otherwise, check if there is a mapping in\n         * org/apache/catalina/startup/Authenticators.properties.\n         */\n        Valve authenticator = null;\n        if (customAuthenticators != null) {\n            authenticator = (Valve)\n                customAuthenticators.get(loginConfig.getAuthMethod());\n        }\n        if (authenticator == null) {\n            // Load our mapping properties if necessary\n            if (authenticators == null) {\n                try {\n                    InputStream is=this.getClass().getClassLoader().getResourceAsStream(\"org/apache/catalina/startup/Authenticators.properties\");\n                    if( is!=null ) {\n                        authenticators = new Properties();\n                        authenticators.load(is);\n                    } else {\n                        log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"));\n                        ok=false;\n                        return;\n                    }\n                } catch (IOException e) {\n                    log.error(sm.getString(\n                                \"contextConfig.authenticatorResources\"), e);\n                    ok = false;\n                    return;\n                }\n            }\n\n            // Identify the class name of the Valve we should configure\n            String authenticatorName = null;\n            authenticatorName =\n                    authenticators.getProperty(loginConfig.getAuthMethod());\n            if (authenticatorName == null) {\n                log.error(sm.getString(\"contextConfig.authenticatorMissing\",\n                                 loginConfig.getAuthMethod()));\n                ok = false;\n                return;\n            }\n\n            // Instantiate and install an Authenticator of the requested class\n            try {\n                Class<?> authenticatorClass = Class.forName(authenticatorName);\n                authenticator = (Valve) authenticatorClass.newInstance();\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(sm.getString(\n                                    \"contextConfig.authenticatorInstantiate\",\n                                    authenticatorName),\n                          t);\n                ok = false;\n            }\n        }\n\n        if (authenticator != null && context instanceof ContainerBase) {\n            Pipeline pipeline = ((ContainerBase) context).getPipeline();\n            if (pipeline != null) {\n                ((ContainerBase) context).getPipeline().addValve(authenticator);\n                if (log.isDebugEnabled()) {\n                    log.debug(sm.getString(\n                                    \"contextConfig.authenticatorConfigured\",\n                                    loginConfig.getAuthMethod()));\n                }\n            }\n        }\n\n    }"
    },
    {
        "idx": "1797",
        "vuln_id": "unknown-269",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/struts",
        "commit": "1320f00ed05f7e5a472add51278abe85f43046fb",
        "method_before": "    private static String buildParameterSubstring(String name, String value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(name);\n        builder.append('=');\n        builder.append(translateAndEncode(value));\n\n        return builder.toString();\n    }",
        "method_after": "    private static String buildParameterSubstring(String name, String value) {\n        StringBuilder builder = new StringBuilder();\n        builder.append(translateAndEncode(name));\n        builder.append('=');\n        builder.append(translateAndEncode(value));\n\n        return builder.toString();\n    }"
    },
    {
        "idx": "1838",
        "vuln_id": "unknown-63",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/AdoptOpenJDK/IcedTea-Web",
        "commit": "808467030ce474915b6032855d29503741ade24e",
        "method_before": "    public void checkPermission(Permission perm) {\n        String name = perm.getName();\n\n        // Enable this manually -- it'll produce too much output for -verbose\n        // otherwise.\n        //      if (true)\n        //        System.out.println(\"Checking permission: \" + perm.toString());\n\n        if (!JNLPRuntime.isWebstartApplication() &&\n                (\"setPolicy\".equals(name) || \"setSecurityManager\".equals(name)))\n            throw new SecurityException(R(\"RCantReplaceSM\"));\n\n        try {\n            // deny all permissions to stopped applications\n            // The call to getApplication() below might not work if an\n            // application hasn't been fully initialized yet.\n            //            if (JNLPRuntime.isDebug()) {\n            //                if (!\"getClassLoader\".equals(name)) {\n            //                    ApplicationInstance app = getApplication();\n            //                    if (app != null && !app.isRunning())\n            //                        throw new SecurityException(R(\"RDenyStopped\"));\n            //                }\n            //            }\n\n            try {\n                super.checkPermission(perm);\n            } catch (SecurityException se) {\n\n                //This section is a special case for dealing with SocketPermissions.\n                if (JNLPRuntime.isDebug())\n                    System.err.println(\"Requesting permission: \" + perm.toString());\n\n                //Change this SocketPermission's action to connect and accept\n                //(and resolve). This is to avoid asking for connect permission\n                //on every address resolve.\n                Permission tmpPerm = null;\n                if (perm instanceof SocketPermission) {\n                    tmpPerm = new SocketPermission(perm.getName(),\n                                                        SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION);\n\n                    // before proceeding, check if we are trying to connect to same origin\n                    ApplicationInstance app = getApplication();\n                    JNLPFile file = app.getJNLPFile();\n\n                    String srcHost = file.getSourceLocation().getAuthority();\n                    String destHost = name;\n\n                    // host = abc.xyz.com or abc.xyz.com:<port>\n                    if (destHost.indexOf(':') >= 0)\n                        destHost = destHost.substring(0, destHost.indexOf(':'));\n\n                    // host = abc.xyz.com\n                    String[] hostComponents = destHost.split(\"\\\\.\");\n\n                    int length = hostComponents.length;\n                    if (length >= 2) {\n\n                        // address is in xxx.xxx.xxx format\n                        destHost = hostComponents[length - 2] + \".\" + hostComponents[length - 1];\n\n                        // host = xyz.com i.e. origin\n                        boolean isDestHostName = false;\n\n                        // make sure that it is not an ip address\n                        try {\n                            Integer.parseInt(hostComponents[length - 1]);\n                        } catch (NumberFormatException e) {\n                            isDestHostName = true;\n                        }\n\n                        if (isDestHostName) {\n                            // okay, destination is hostname. Now figure out if it is a subset of origin\n                            if (srcHost.endsWith(destHost)) {\n                                addPermission(tmpPerm);\n                                return;\n                            }\n                        }\n                    }\n                } else {\n                    tmpPerm = perm;\n                }\n\n                if (tmpPerm != null) {\n                    //askPermission will only prompt the user on SocketPermission\n                    //meaning we're denying all other SecurityExceptions that may arise.\n                    if (askPermission(tmpPerm)) {\n                        addPermission(tmpPerm);\n                        //return quietly.\n                    } else {\n                        throw se;\n                    }\n                }\n            }\n        } catch (SecurityException ex) {\n            if (JNLPRuntime.isDebug()) {\n                System.out.println(\"Denying permission: \" + perm);\n            }\n            throw ex;\n        }\n    }",
        "method_after": "    public void checkPermission(Permission perm) {\n        String name = perm.getName();\n\n        // Enable this manually -- it'll produce too much output for -verbose\n        // otherwise.\n        //      if (true)\n        //        System.out.println(\"Checking permission: \" + perm.toString());\n\n        if (!JNLPRuntime.isWebstartApplication() &&\n                (\"setPolicy\".equals(name) || \"setSecurityManager\".equals(name)))\n            throw new SecurityException(R(\"RCantReplaceSM\"));\n\n        try {\n            // deny all permissions to stopped applications\n            // The call to getApplication() below might not work if an\n            // application hasn't been fully initialized yet.\n            //            if (JNLPRuntime.isDebug()) {\n            //                if (!\"getClassLoader\".equals(name)) {\n            //                    ApplicationInstance app = getApplication();\n            //                    if (app != null && !app.isRunning())\n            //                        throw new SecurityException(R(\"RDenyStopped\"));\n            //                }\n            //            }\n\n            super.checkPermission(perm);\n        } catch (SecurityException ex) {\n            if (JNLPRuntime.isDebug()) {\n                System.out.println(\"Denying permission: \" + perm);\n            }\n            throw ex;\n        }\n    }"
    },
    {
        "idx": "1844",
        "vuln_id": "unknown-69",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/opencast/opencast",
        "commit": "e1bfeae309347de9e659d5629760f1964b10cf09",
        "method_before": "    ByteArrayServletOutputStream(int size) {\n      if (size < 0) {\n        throw new IllegalArgumentException(\"Negative initial size: \" + size);\n      }\n      buf = new byte[size];\n    }\n\n    /**\n     * Returns a copy of the buffer as an array.\n     *\n     * @return the buffer as a byte array\n     */\n    public synchronized byte toByteArray()[] {\n      return Arrays.copyOf(buf, count);\n    }",
        "method_after": "    ByteArrayServletOutputStream(int size) {\n      if (size < 0) {\n        throw new IllegalArgumentException(\"Negative initial size: \" + size);\n      }\n      buf = new byte[size];\n    }\n\n    /**\n     * Returns a copy of the buffer as an array.\n     *\n     * @return the buffer as a byte array\n     */\n    public synchronized byte[] toByteArray() {\n      return Arrays.copyOf(buf, count);\n    }"
    },
    {
        "idx": "1862",
        "vuln_id": "unknown-85",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "d4b5e4041a4c1f34b11ec24f17ecee25ab92ce48",
        "method_before": "            if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);\n            else r.reset(socket,ka,OP_REGISTER);\n            addEvent(r);\n        }\n        public void cancelledKey(SelectionKey key, SocketStatus status, boolean dispatch) {\n            try {\n                if ( key == null ) return;//nothing to do\n                KeyAttachment ka = (KeyAttachment) key.attachment();\n                if (ka != null && ka.getComet() && status != null) {\n                    //the comet event takes care of clean up\n                    //processSocket(ka.getChannel(), status, dispatch);\n                    ka.setComet(false);//to avoid a loop\n                    if (status == SocketStatus.TIMEOUT ) {\n                        if (processSocket(ka.getChannel(), status, true)) {\n                            return; // don't close on comet timeout\n                        }\n                    } else {\n                        processSocket(ka.getChannel(), status, false); //don't dispatch if the lines below are cancelling the key\n                    }                    \n                }\n                key.attach(null);\n                if (ka!=null) handler.release(ka);\n                else handler.release((SocketChannel)key.channel());\n                if (key.isValid()) key.cancel();\n                if (key.channel().isOpen()) {\n                    try {\n                        key.channel().close();\n                    } catch (Exception e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\n                                    \"endpoint.debug.channelCloseFail\"), e);\n                        }\n                    }\n                }\n                try {\n                    if (ka!=null) {\n                        ka.getSocket().close(true);\n                    }\n                } catch (Exception e){\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"endpoint.debug.socketCloseFail\"), e);\n                    }\n                }\n                try {if (ka!=null && ka.getSendfileData()!=null && ka.getSendfileData().fchannel!=null && ka.getSendfileData().fchannel.isOpen()) ka.getSendfileData().fchannel.close();}catch (Exception ignore){}\n                if (ka!=null) {\n                    ka.reset();\n                    countDownConnection(); \n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                if (log.isDebugEnabled()) log.error(\"\",e);\n            }\n        }\n        /**\n         * The background thread that listens for incoming TCP/IP connections and\n         * hands them off to an appropriate processor.\n         */\n        @Override\n        public void run() {\n            // Loop until we receive a shutdown command\n            while (running) {\n                try {\n                    // Loop if endpoint is paused\n                    while (paused && (!close) ) {\n                        try {\n                            Thread.sleep(100);\n                        } catch (InterruptedException e) {\n                            // Ignore\n                        }\n                    }\n\n                    boolean hasEvents = events();\n\n                    // Time to terminate?\n                    if (close) {\n                        timeout(0, false);\n                        break;\n                    }\n                    try {\n                        if ( !close ) {\n                            if (wakeupCounter.get()>0) {\n                                //if we are here, means we have other stuff to do\n                                //do a non blocking select\n                                keyCount = selector.selectNow();\n                            }else {\n                                keyCount = selector.keys().size();\n                                wakeupCounter.set(-1);\n                                keyCount = selector.select(selectorTimeout);\n                            }\n                            wakeupCounter.set(0);\n                        }\n                        if (close) {\n                            timeout(0, false);\n                            selector.close(); \n                            break; \n                        }\n                    } catch ( NullPointerException x ) {\n                        //sun bug 5076772 on windows JDK 1.5\n                        if ( log.isDebugEnabled() ) log.debug(\"Possibly encountered sun bug 5076772 on windows JDK 1.5\",x);\n                        if ( wakeupCounter == null || selector == null ) throw x;\n                        continue;\n                    } catch ( CancelledKeyException x ) {\n                        //sun bug 5076772 on windows JDK 1.5\n                        if ( log.isDebugEnabled() ) log.debug(\"Possibly encountered sun bug 5076772 on windows JDK 1.5\",x);\n                        if ( wakeupCounter == null || selector == null ) throw x;\n                        continue;\n                    } catch (Throwable x) {\n                        ExceptionUtils.handleThrowable(x);\n                        log.error(\"\",x);\n                        continue;\n                    }\n                    //either we timed out or we woke up, process events first\n                    if ( keyCount == 0 ) hasEvents = (hasEvents | events());\n\n                    Iterator<SelectionKey> iterator =\n                        keyCount > 0 ? selector.selectedKeys().iterator() : null;\n                    // Walk through the collection of ready keys and dispatch\n                    // any active event.\n                    while (iterator != null && iterator.hasNext()) {\n                        SelectionKey sk = iterator.next();\n                        KeyAttachment attachment = (KeyAttachment)sk.attachment();\n                        // Attachment may be null if another thread has called\n                        // cancelledKey()\n                        if (attachment == null) {\n                            iterator.remove();\n                        } else {\n                            attachment.access();\n                            iterator.remove();\n                            processKey(sk, attachment);\n                        }\n                    }//while\n\n                    //process timeouts\n                    timeout(keyCount,hasEvents);\n                    if ( oomParachute > 0 && oomParachuteData == null ) checkParachute();\n                } catch (OutOfMemoryError oom) {\n                    try {\n                        oomParachuteData = null;\n                        releaseCaches();\n                        log.error(\"\", oom);\n                    }catch ( Throwable oomt ) {\n                        try {\n                            System.err.println(oomParachuteMsg);\n                            oomt.printStackTrace();\n                        }catch (Throwable letsHopeWeDontGetHere){\n                            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);\n                        }\n                    }\n                }\n            }//while\n            synchronized (this) {\n                this.notifyAll();\n            }\n            stopLatch.countDown();\n\n        }\n        \n        protected boolean processKey(SelectionKey sk, KeyAttachment attachment) {\n            boolean result = true;\n            try {\n                if ( close ) {\n                    cancelledKey(sk, SocketStatus.STOP, false);\n                } else if ( sk.isValid() && attachment != null ) {\n                    attachment.access();//make sure we don't time out valid sockets\n                    sk.attach(attachment);//cant remember why this is here\n                    NioChannel channel = attachment.getChannel();\n                    if (sk.isReadable() || sk.isWritable() ) {\n                        if ( attachment.getSendfileData() != null ) {\n                            processSendfile(sk,attachment,true, false);\n                        } else if ( attachment.getComet() ) {\n                            //check if thread is available\n                            if ( isWorkerAvailable() ) {\n                                //set interest ops to 0 so we don't get multiple\n                                //Invocations for both read and write on separate threads\n                                reg(sk, attachment, 0);\n                                //read goes before write\n                                if (sk.isReadable()) {\n                                    //read notification\n                                    if (!processSocket(channel, SocketStatus.OPEN, true))\n                                        processSocket(channel, SocketStatus.DISCONNECT, true);\n                                } else {\n                                    //future placement of a WRITE notif\n                                    if (!processSocket(channel, SocketStatus.OPEN, true))\n                                        processSocket(channel, SocketStatus.DISCONNECT, true);\n                                }\n                            } else {\n                                result = false;\n                            }\n                        } else {\n                            //later on, improve latch behavior\n                            if ( isWorkerAvailable() ) {\n                                unreg(sk, attachment,sk.readyOps());\n                                boolean close = (!processSocket(channel, null, true));\n                                if (close) {\n                                    cancelledKey(sk,SocketStatus.DISCONNECT,false);\n                                }\n                            } else {\n                                result = false;\n                            }\n                        }\n                    } \n                } else {\n                    //invalid key\n                    cancelledKey(sk, SocketStatus.ERROR,false);\n                }\n            } catch ( CancelledKeyException ckx ) {\n                cancelledKey(sk, SocketStatus.ERROR,false);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(\"\",t);\n            }\n            return result;\n        }\n        \n        public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                //unreg(sk,attachment);//only do this if we do process send file on a separate thread\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n                \n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }",
        "method_after": "            if ( r==null) r = new PollerEvent(socket,ka,OP_REGISTER);\n            else r.reset(socket,ka,OP_REGISTER);\n            addEvent(r);\n        }\n        public void cancelledKey(SelectionKey key, SocketStatus status, boolean dispatch) {\n            try {\n                if ( key == null ) return;//nothing to do\n                KeyAttachment ka = (KeyAttachment) key.attachment();\n                if (ka != null && ka.getComet() && status != null) {\n                    //the comet event takes care of clean up\n                    //processSocket(ka.getChannel(), status, dispatch);\n                    ka.setComet(false);//to avoid a loop\n                    if (status == SocketStatus.TIMEOUT ) {\n                        if (processSocket(ka.getChannel(), status, true)) {\n                            return; // don't close on comet timeout\n                        }\n                    } else {\n                        processSocket(ka.getChannel(), status, false); //don't dispatch if the lines below are cancelling the key\n                    }                    \n                }\n                key.attach(null);\n                if (ka!=null) handler.release(ka);\n                else handler.release((SocketChannel)key.channel());\n                if (key.isValid()) key.cancel();\n                if (key.channel().isOpen()) {\n                    try {\n                        key.channel().close();\n                    } catch (Exception e) {\n                        if (log.isDebugEnabled()) {\n                            log.debug(sm.getString(\n                                    \"endpoint.debug.channelCloseFail\"), e);\n                        }\n                    }\n                }\n                try {\n                    if (ka!=null) {\n                        ka.getSocket().close(true);\n                    }\n                } catch (Exception e){\n                    if (log.isDebugEnabled()) {\n                        log.debug(sm.getString(\n                                \"endpoint.debug.socketCloseFail\"), e);\n                    }\n                }\n                try {if (ka!=null && ka.getSendfileData()!=null && ka.getSendfileData().fchannel!=null && ka.getSendfileData().fchannel.isOpen()) ka.getSendfileData().fchannel.close();}catch (Exception ignore){}\n                if (ka!=null) {\n                    ka.reset();\n                    countDownConnection(); \n                }\n            } catch (Throwable e) {\n                ExceptionUtils.handleThrowable(e);\n                if (log.isDebugEnabled()) log.error(\"\",e);\n            }\n        }\n        /**\n         * The background thread that listens for incoming TCP/IP connections and\n         * hands them off to an appropriate processor.\n         */\n        @Override\n        public void run() {\n            // Loop until we receive a shutdown command\n            while (running) {\n                try {\n                    // Loop if endpoint is paused\n                    while (paused && (!close) ) {\n                        try {\n                            Thread.sleep(100);\n                        } catch (InterruptedException e) {\n                            // Ignore\n                        }\n                    }\n\n                    boolean hasEvents = events();\n\n                    // Time to terminate?\n                    if (close) {\n                        timeout(0, false);\n                        break;\n                    }\n                    try {\n                        if ( !close ) {\n                            if (wakeupCounter.get()>0) {\n                                //if we are here, means we have other stuff to do\n                                //do a non blocking select\n                                keyCount = selector.selectNow();\n                            }else {\n                                keyCount = selector.keys().size();\n                                wakeupCounter.set(-1);\n                                keyCount = selector.select(selectorTimeout);\n                            }\n                            wakeupCounter.set(0);\n                        }\n                        if (close) {\n                            timeout(0, false);\n                            selector.close(); \n                            break; \n                        }\n                    } catch ( NullPointerException x ) {\n                        //sun bug 5076772 on windows JDK 1.5\n                        if ( log.isDebugEnabled() ) log.debug(\"Possibly encountered sun bug 5076772 on windows JDK 1.5\",x);\n                        if ( wakeupCounter == null || selector == null ) throw x;\n                        continue;\n                    } catch ( CancelledKeyException x ) {\n                        //sun bug 5076772 on windows JDK 1.5\n                        if ( log.isDebugEnabled() ) log.debug(\"Possibly encountered sun bug 5076772 on windows JDK 1.5\",x);\n                        if ( wakeupCounter == null || selector == null ) throw x;\n                        continue;\n                    } catch (Throwable x) {\n                        ExceptionUtils.handleThrowable(x);\n                        log.error(\"\",x);\n                        continue;\n                    }\n                    //either we timed out or we woke up, process events first\n                    if ( keyCount == 0 ) hasEvents = (hasEvents | events());\n\n                    Iterator<SelectionKey> iterator =\n                        keyCount > 0 ? selector.selectedKeys().iterator() : null;\n                    // Walk through the collection of ready keys and dispatch\n                    // any active event.\n                    while (iterator != null && iterator.hasNext()) {\n                        SelectionKey sk = iterator.next();\n                        KeyAttachment attachment = (KeyAttachment)sk.attachment();\n                        // Attachment may be null if another thread has called\n                        // cancelledKey()\n                        if (attachment == null) {\n                            iterator.remove();\n                        } else {\n                            attachment.access();\n                            iterator.remove();\n                            processKey(sk, attachment);\n                        }\n                    }//while\n\n                    //process timeouts\n                    timeout(keyCount,hasEvents);\n                    if ( oomParachute > 0 && oomParachuteData == null ) checkParachute();\n                } catch (OutOfMemoryError oom) {\n                    try {\n                        oomParachuteData = null;\n                        releaseCaches();\n                        log.error(\"\", oom);\n                    }catch ( Throwable oomt ) {\n                        try {\n                            System.err.println(oomParachuteMsg);\n                            oomt.printStackTrace();\n                        }catch (Throwable letsHopeWeDontGetHere){\n                            ExceptionUtils.handleThrowable(letsHopeWeDontGetHere);\n                        }\n                    }\n                }\n            }//while\n            synchronized (this) {\n                this.notifyAll();\n            }\n            stopLatch.countDown();\n\n        }\n        \n        protected boolean processKey(SelectionKey sk, KeyAttachment attachment) {\n            boolean result = true;\n            try {\n                if ( close ) {\n                    cancelledKey(sk, SocketStatus.STOP, false);\n                } else if ( sk.isValid() && attachment != null ) {\n                    attachment.access();//make sure we don't time out valid sockets\n                    sk.attach(attachment);//cant remember why this is here\n                    NioChannel channel = attachment.getChannel();\n                    if (sk.isReadable() || sk.isWritable() ) {\n                        if ( attachment.getSendfileData() != null ) {\n                            processSendfile(sk,attachment,true, false);\n                        } else if ( attachment.getComet() ) {\n                            //check if thread is available\n                            if ( isWorkerAvailable() ) {\n                                //set interest ops to 0 so we don't get multiple\n                                //Invocations for both read and write on separate threads\n                                reg(sk, attachment, 0);\n                                //read goes before write\n                                if (sk.isReadable()) {\n                                    //read notification\n                                    if (!processSocket(channel, SocketStatus.OPEN, true))\n                                        processSocket(channel, SocketStatus.DISCONNECT, true);\n                                } else {\n                                    //future placement of a WRITE notif\n                                    if (!processSocket(channel, SocketStatus.OPEN, true))\n                                        processSocket(channel, SocketStatus.DISCONNECT, true);\n                                }\n                            } else {\n                                result = false;\n                            }\n                        } else {\n                            //later on, improve latch behavior\n                            if ( isWorkerAvailable() ) {\n                                unreg(sk, attachment,sk.readyOps());\n                                boolean close = (!processSocket(channel, null, true));\n                                if (close) {\n                                    cancelledKey(sk,SocketStatus.DISCONNECT,false);\n                                }\n                            } else {\n                                result = false;\n                            }\n                        }\n                    } \n                } else {\n                    //invalid key\n                    cancelledKey(sk, SocketStatus.ERROR,false);\n                }\n            } catch ( CancelledKeyException ckx ) {\n                cancelledKey(sk, SocketStatus.ERROR,false);\n            } catch (Throwable t) {\n                ExceptionUtils.handleThrowable(t);\n                log.error(\"\",t);\n            }\n            return result;\n        }\n        \n        public boolean processSendfile(SelectionKey sk, KeyAttachment attachment, boolean reg, boolean event) {\n            NioChannel sc = null;\n            try {\n                //unreg(sk,attachment);//only do this if we do process send file on a separate thread\n                SendfileData sd = attachment.getSendfileData();\n                if ( sd.fchannel == null ) {\n                    File f = new File(sd.fileName);\n                    if ( !f.exists() ) {\n                        cancelledKey(sk,SocketStatus.ERROR,false);\n                        return false;\n                    }\n                    sd.fchannel = new FileInputStream(f).getChannel();\n                }\n                sc = attachment.getChannel();\n                sc.setSendFile(true);\n                WritableByteChannel wc = ((sc instanceof SecureNioChannel)?sc:sc.getIOChannel());\n                \n                if (sc.getOutboundRemaining()>0) {\n                    if (sc.flushOutbound()) {\n                        attachment.access();\n                    }\n                } else {\n                    long written = sd.fchannel.transferTo(sd.pos,sd.length,wc);\n                    if ( written > 0 ) {\n                        sd.pos += written;\n                        sd.length -= written;\n                        attachment.access();\n                    } else {\n                        // Unusual not to be able to transfer any bytes\n                        // Check the length was set correctly\n                        if (sd.fchannel.size() <= sd.pos) {\n                            throw new IOException(\"Sendfile configured to \" +\n                                    \"send more data than was available\");\n                        }\n                    }\n                }\n                if ( sd.length <= 0 && sc.getOutboundRemaining()<=0) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"Send file complete for:\"+sd.fileName);\n                    }\n                    attachment.setSendfileData(null);\n                    try {sd.fchannel.close();}catch(Exception ignore){}\n                    if ( sd.keepAlive ) {\n                        if (reg) {\n                            if (log.isDebugEnabled()) {\n                                log.debug(\"Connection is keep alive, registering back for OP_READ\");\n                            }\n                            if (event) {\n                                this.add(attachment.getChannel(),SelectionKey.OP_READ);\n                            } else {\n                                reg(sk,attachment,SelectionKey.OP_READ);\n                            }\n                        }\n                    } else {\n                        if (log.isDebugEnabled()) {\n                            log.debug(\"Send file connection is being closed\");\n                        }\n                        cancelledKey(sk,SocketStatus.STOP,false);\n                        return false;\n                    }\n                } else if ( attachment.interestOps() == 0 && reg ) {\n                    if (log.isDebugEnabled()) {\n                        log.debug(\"OP_WRITE for sendilfe:\"+sd.fileName);\n                    }\n                    if (event) {\n                        add(attachment.getChannel(),SelectionKey.OP_WRITE);\n                    } else {\n                        reg(sk,attachment,SelectionKey.OP_WRITE);\n                    }\n                }\n            }catch ( IOException x ) {\n                if ( log.isDebugEnabled() ) log.debug(\"Unable to complete sendfile request:\", x);\n                cancelledKey(sk,SocketStatus.ERROR,false);\n                return false;\n            }catch ( Throwable t ) {\n                log.error(\"\",t);\n                cancelledKey(sk, SocketStatus.ERROR, false);\n                return false;\n            }finally {\n                if (sc!=null) sc.setSendFile(false);\n            }\n            return true;\n        }"
    },
    {
        "idx": "1872",
        "vuln_id": "unknown-94",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/javamelody/javamelody",
        "commit": "3d862e20b17f597d91a6f7b34d642d51425f7f35",
        "method_before": "\t\tHtmlCounterRequestGraphReport(Range range, Writer writer) {\n\t\t\tsuper(writer);\n\t\t\tassert range != null;\n\t\t\tthis.range = range;\n\t\t}\n\n\t\t@Override\n\t\tvoid toHtml() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tvoid writeRequestGraph(String requestId, String requestName) throws IOException {\n\t\t\tuniqueByPageAndGraphSequence++;\n\t\t\t// la classe tooltip est configur\u00e9e dans la css de HtmlReport\n\t\t\twrite(\"<a class='tooltip' href='?part=graph&amp;graph=\");\n\t\t\twrite(requestId);\n\t\t\twrite(\"'\");\n\t\t\t// ce onmouseover sert \u00e0 charger les graphs par requ\u00eate un par un et \u00e0 la demande\n\t\t\t// sans les charger tous au chargement de la page.\n\t\t\t// le onmouseover se d\u00e9sactive apr\u00e8s chargement pour ne pas recharger une image d\u00e9j\u00e0 charg\u00e9e\n\t\t\twrite(\" onmouseover=\\\"document.getElementById('\");\n\t\t\tfinal String id = \"id\" + uniqueByPageAndGraphSequence;\n\t\t\twrite(id);\n\t\t\twrite(\"').src='?graph=\");\n\t\t\twrite(requestId);\n\t\t\twrite(\"&amp;width=100&amp;height=50'; this.onmouseover=null;\\\" >\");\n\t\t\t// avant mouseover on prend une image qui sera mise en cache\n\t\t\twrite(\"<em><img src='?resource=db.png' id='\");\n\t\t\twrite(id);\n\t\t\twrite(\"' alt='graph'/></em>\");\n\t\t\tif (requestName.length() <= MAX_REQUEST_NAME_LENGTH) {\n\t\t\t\t// writeDirectly pour ne pas g\u00e9rer de traductions si le nom contient '#'\n\t\t\t\twriteDirectly(htmlEncodeRequestName(requestId, requestName));\n\t\t\t\twrite(\"</a>\");\n\t\t\t} else {\n\t\t\t\t// si une requ\u00eate a trop de caract\u00e8res, alors cela sature le tableau des requ\u00eates\n\t\t\t\t// et le rend peu lisible, donc on tronque cette requ\u00eate en ajoutant une action \"Details\".\n\t\t\t\twriteDirectly(htmlEncodeRequestName(requestId,\n\t\t\t\t\t\trequestName.substring(0, MAX_REQUEST_NAME_LENGTH)));\n\t\t\t\twrite(\"</a>\");\n\t\t\t\twrite(\"<br/> \");\n\n\t\t\t\tfinal String idToShow = \"request-\" + requestId;\n\t\t\t\twriteShowHideLink(idToShow, \"#Details#\");\n\t\t\t\twriteln(\"<div id='request-\" + requestId + \"' style='display: none;'>\");\n\t\t\t\twrite(\"<br/> \");\n\t\t\t\twriteDirectly(htmlEncodeRequestName(requestId, requestName));\n\t\t\t\twriteln(\"</div> \");\n\t\t\t}\n\t\t}\n\n\t\tvoid writeRequestAndGraphDetail(Collector collector, CollectorServer collectorServer,\n\t\t\t\tString graphName) throws IOException {\n\t\t\tcounters = collector.getRangeCounters(range);\n\t\t\trequestsById = mapAllRequestsById();\n\t\t\tfinal CounterRequest request = requestsById.get(graphName);\n\t\t\tif (request != null) {\n\t\t\t\twriteRequest(request);\n\n\t\t\t\tif (JdbcWrapper.SINGLETON.getSqlCounter().isRequestIdFromThisCounter(graphName)\n\t\t\t\t\t\t&& !request.getName().toLowerCase(Locale.ENGLISH).startsWith(\"alter \")) {\n\t\t\t\t\t// inutile d'essayer d'avoir le plan d'ex\u00e9cution des requ\u00eates sql\n\t\t\t\t\t// telles que \"alter session set ...\" (cf issue 152)\n\t\t\t\t\twriteSqlRequestExplainPlan(collector, collectorServer, request);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isGraphDisplayed(collector, request)) {\n\t\t\t\twriteln(\"<table summary=''><tr><td>\");\n\t\t\t\twriteln(\"<div id='track' class='noPrint'>\");\n\t\t\t\twriteln(\"<div class='selected' id='handle'>\");\n\t\t\t\twriteln(\"<img src='?resource=scaler_slider.gif' alt=''/>\");\n\t\t\t\twriteln(\"</div></div>\");\n\t\t\t\twriteln(\"</td><td>\");\n\t\t\t\twriteDirectly(\"<div class='noPrint' style='color: #808080;'>\");\n\t\t\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\t\t\twriteln(\"<label for='cb'><input id='cb' type='checkbox' onclick=\\\"handleHideMaximumClick(this);\\\"/>&nbsp;#hide_maximum#</label>\");\n\t\t\t\twriteln(\"</div> \");\n\t\t\t\twriteln(\"</td></tr></table>\");\n\n\t\t\t\twriteln(\"<div align='center'>\");\n\t\t\t\twriteln(\"<table summary=''><tr><td>\");\n\t\t\t\twriteln(\"<img class='synth\u00e8se' id='img' src='\"\n\t\t\t\t\t\t+ \"?width=960&amp;height=400&amp;graph=\" + urlEncode(graphName)\n\t\t\t\t\t\t+ \"' alt='zoom'/>\");\n\t\t\t\twriteDirectly(\"<br/><div align='right' style='color: #808080;'>\");\n\t\t\t\twriteln(\"#graph_units#\");\n\t\t\t\twriteln(\"</div></td></tr></table>\");\n\t\t\t\twriteln(\"</div>\");\n\t\t\t\twriteln(\"<div align='right'><a href='?part=lastValue&amp;graph=\"\n\t\t\t\t\t\t+ urlEncode(graphName) + \"' title=\\\"#Lien_derniere_valeur#\\\">_</a></div>\");\n\n\t\t\t\twriteGraphDetailScript(graphName);\n\t\t\t}\n\t\t\tif (request != null && request.getStackTrace() != null) {\n\t\t\t\twriteln(\"<blockquote><blockquote><b>Stack-trace</b><br/><font size='-1'>\");\n\t\t\t\t// writeDirectly pour ne pas g\u00e9rer de traductions si la stack-trace contient '#'\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(request.getStackTrace()).replaceAll(\"\\t\",\n\t\t\t\t\t\t\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"));\n\t\t\t\twriteln(\"</font></blockquote></blockquote>\");\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isGraphDisplayed(Collector collector, CounterRequest request) {\n\t\t\treturn request == null || getCounterByRequestId(request) != null\n\t\t\t\t\t&& isRequestGraphDisplayed(getCounterByRequestId(request))\n\t\t\t\t\t// on v\u00e9rifie aussi que l'instance de jrobin existe pour faire le graph,\n\t\t\t\t\t// notamment si les statistiques ont \u00e9t\u00e9 r\u00e9initialis\u00e9es, ce qui vide les instances de jrobin\n\t\t\t\t\t&& collector.getJRobin(request.getId()) != null;\n\t\t}\n\n\t\tprivate void writeSqlRequestExplainPlan(Collector collector,\n\t\t\t\tCollectorServer collectorServer, CounterRequest sqlRequest) throws IOException {\n\t\t\ttry {\n\t\t\t\tfinal String explainPlan;\n\t\t\t\tif (collectorServer == null) {\n\t\t\t\t\texplainPlan = DatabaseInformations.explainPlanFor(sqlRequest.getName());\n\t\t\t\t} else {\n\t\t\t\t\texplainPlan = collectorServer.collectSqlRequestExplainPlan(\n\t\t\t\t\t\t\tcollector.getApplication(), sqlRequest.getName());\n\t\t\t\t}\n\t\t\t\t// rq : si explainPlan \u00e9tait un tableau (ex: mysql),\n\t\t\t\t// on pourrait utiliser HtmlDatabaseInformationsReport.TableReport\n\t\t\t\tif (explainPlan != null) {\n\t\t\t\t\twriteln(\"<b>#Plan_d_execution#</b>\");\n\t\t\t\t\twriteln(\"<div class='explainPlan'>\");\n\t\t\t\t\twriteDirectly(explainPlan.replace(\" \", \"&nbsp;\").replace(\"\\n\", \"<br/>\"));\n\t\t\t\t\twriteln(\"</div><hr/>\");\n\t\t\t\t}\n\t\t\t} catch (final Exception e) {\n\t\t\t\twriteln(\"<b>#Plan_d_execution#</b> \");\n\t\t\t\twriteln(e.toString());\n\t\t\t\twriteln(\"<br/>\");\n\t\t\t}\n\t\t}\n\n\t\tvoid writeRequestUsages(Collector collector, String requestId) throws IOException {\n\t\t\tassert requestId != null;\n\t\t\tcounters = collector.getRangeCounters(range);\n\t\t\tCounterRequest myRequest = null;\n\t\t\tfinal List<CounterRequest> requests = new ArrayList<CounterRequest>();\n\t\t\tfor (final Counter counter : counters) {\n\t\t\t\tfor (final CounterRequest request : counter.getOrderedRequests()) {\n\t\t\t\t\tif (myRequest == null && request.getId().equals(requestId)) {\n\t\t\t\t\t\tmyRequest = request;\n\t\t\t\t\t}\n\t\t\t\t\tif (request.containsChildRequest(requestId)) {\n\t\t\t\t\t\trequests.add(request);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twriteRequestUsages(myRequest, requests);\n\t\t}\n\n\t\tprivate void writeRequestUsages(CounterRequest myRequest, List<CounterRequest> requests)\n\t\t\t\tthrows IOException {\n\t\t\twriteln(\"<br/><b>#Utilisations_de#</b>\");\n\t\t\tif (myRequest != null) {\n\t\t\t\twriteDirectly(htmlEncodeRequestName(myRequest.getId(), myRequest.getName()));\n\t\t\t}\n\t\t\twriteln(\"<br/><br/>\");\n\t\t\tif (requests.isEmpty()) {\n\t\t\t\twriteln(\"#Aucune_requete#\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal boolean someUsagesDisplayed = getUsagesDisplayed(requests);\n\t\t\tfinal HtmlTable table = new HtmlTable();\n\t\t\ttable.beginTable(getString(\"Utilisations_de\"));\n\t\t\twrite(\"<th>#Requete#</th>\");\n\t\t\tif (someUsagesDisplayed) {\n\t\t\t\twrite(\"<th class='noPrint'>#Chercher_utilisations#</th>\");\n\t\t\t}\n\t\t\tfor (final CounterRequest request : requests) {\n\t\t\t\ttable.nextRow();\n\t\t\t\twriteUsedRequest(request, someUsagesDisplayed);\n\t\t\t}\n\t\t\ttable.endTable();\n\t\t}\n\n\t\tprivate void writeUsedRequest(CounterRequest request, boolean someUsageDisplayed)\n\t\t\t\tthrows IOException {\n\t\t\twriteln(\" <td>\");\n\t\t\twriteCounterIcon(request);\n\t\t\twriteRequestGraph(request.getId(), request.getName());\n\t\t\tif (someUsageDisplayed) {\n\t\t\t\twriteln(\"</td><td align='center' class='noPrint'>\");\n\t\t\t\tif (doesRequestDisplayUsages(request)) {\n\t\t\t\t\twriteln(\"<a href='?part=usages&amp;graph=\" + request.getId() + \"'>\");\n\t\t\t\t\twriteln(\"<img src='?resource=find.png' alt='#Chercher_utilisations#' title='#Chercher_utilisations#'/></a>\");\n\t\t\t\t} else {\n\t\t\t\t\twriteln(\"&nbsp;\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twriteln(\"</td>\");\n\t\t}\n\n\t\tprivate boolean getUsagesDisplayed(List<CounterRequest> requests) {\n\t\t\tfor (final CounterRequest request : requests) {\n\t\t\t\tif (doesRequestDisplayUsages(request)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate void writeRequest(CounterRequest request) throws IOException {\n\t\t\tfinal Map<String, Long> childRequests = request.getChildRequestsExecutionsByRequestId();\n\t\t\twriteln(\" <br/>\");\n\t\t\tfinal HtmlTable table = new HtmlTable();\n\t\t\ttable.beginTable(getString(\"Drill_down\"));\n\t\t\twriteln(\"<th>#Requete#</th>\");\n\t\t\tfinal boolean hasChildren = !childRequests.isEmpty();\n\t\t\tif (hasChildren) {\n\t\t\t\twriteln(\"<th class='sorttable_numeric'>#Hits_par_requete#</th>\");\n\t\t\t}\n\t\t\twriteln(\"<th class='sorttable_numeric'>#Temps_moyen#</th><th class='sorttable_numeric'>#Temps_max#</th>\");\n\t\t\twriteln(\"<th class='sorttable_numeric'>#Ecart_type#</th><th class='sorttable_numeric'>#Temps_cpu_moyen#</th>\");\n\t\t\twriteln(\"<th class='sorttable_numeric'>#erreur_systeme#</th>\");\n\t\t\tfinal Counter parentCounter = getCounterByRequestId(request);\n\t\t\tfinal boolean allChildHitsDisplayed = parentCounter != null\n\t\t\t\t\t&& parentCounter.getChildCounterName() != null && request.hasChildHits();\n\t\t\tif (allChildHitsDisplayed) {\n\t\t\t\tfinal String childCounterName = parentCounter.getChildCounterName();\n\t\t\t\twriteln(\"<th class='sorttable_numeric'>\"\n\t\t\t\t\t\t+ getFormattedString(\"hits_fils_moyens\", childCounterName));\n\t\t\t\twriteln(\"</th><th class='sorttable_numeric'>\"\n\t\t\t\t\t\t+ getFormattedString(\"temps_fils_moyen\", childCounterName) + \"</th>\");\n\t\t\t}\n\t\t\ttable.nextRow();\n\t\t\twrite(\"<td class='wrappedText'>\");\n\t\t\twriteCounterIcon(request);\n\t\t\twriteDirectly(htmlEncodeRequestName(request.getId(), request.getName()));\n\t\t\tif (hasChildren) {\n\t\t\t\twriteln(\"</td><td>&nbsp;\");\n\t\t\t}\n\t\t\twriteRequestValues(request, allChildHitsDisplayed);\n\t\t\twriteln(\"</td> \");\n\n\t\t\tif (hasChildren) {\n\t\t\t\twriteChildRequests(request, childRequests, allChildHitsDisplayed, table);\n\t\t\t}\n\t\t\ttable.endTable();\n\t\t\tif (doesRequestDisplayUsages(request)) {\n\t\t\t\twriteln(\"<div align='right' class='noPrint'>\");\n\t\t\t\twriteln(\"<a href='?part=usages&amp;graph=\" + request.getId() + \"'>\");\n\t\t\t\twriteln(\"<img src='?resource=find.png' alt='#Chercher_utilisations#' \");\n\t\t\t\twriteln(\"title='#Chercher_utilisations#'/> #Chercher_utilisations#</a></div>\");\n\t\t\t} else {\n\t\t\t\twriteln(\"<br/>\");\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean doesRequestDisplayUsages(CounterRequest request) {\n\t\t\tfinal Counter parentCounter = getCounterByRequestId(request);\n\t\t\treturn parentCounter != null && !parentCounter.isErrorCounter()\n\t\t\t\t\t&& !Counter.HTTP_COUNTER_NAME.equals(parentCounter.getName());\n\t\t}\n\n\t\tprivate void writeChildRequests(CounterRequest request, Map<String, Long> childRequests,\n\t\t\t\tboolean allChildHitsDisplayed, HtmlTable table) throws IOException {\n\t\t\tfor (final Map.Entry<String, Long> entry : childRequests.entrySet()) {\n\t\t\t\tfinal CounterRequest childRequest = requestsById.get(entry.getKey());\n\t\t\t\tif (childRequest != null) {\n\t\t\t\t\ttable.nextRow();\n\t\t\t\t\tfinal Long nbExecutions = entry.getValue();\n\t\t\t\t\tfinal float executionsByRequest = (float) nbExecutions / request.getHits();\n\t\t\t\t\twriteChildRequest(childRequest, executionsByRequest, allChildHitsDisplayed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeChildRequest(CounterRequest childRequest, float executionsByRequest,\n\t\t\t\tboolean allChildHitsDisplayed) throws IOException {\n\t\t\twriteln(\"<td>\");\n\t\t\twriteln(\"<div style='margin-left: 10px;' class='wrappedText'>\");\n\t\t\twriteCounterIcon(childRequest);\n\t\t\twriteRequestGraph(childRequest.getId(), childRequest.getName());\n\t\t\twriteln(\"</div></td><td align='right'>\");\n\t\t\twrite(nbExecutionsFormat.format(executionsByRequest));\n\t\t\twriteRequestValues(childRequest, allChildHitsDisplayed);\n\t\t\twriteln(\"</td>\");\n\t\t}\n\n\t\tprivate void writeRequestValues(CounterRequest request, boolean allChildHitsDisplayed)\n\t\t\t\tthrows IOException {\n\t\t\tfinal String nextColumn = \"</td><td align='right'>\";\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(integerFormat.format(request.getMean()));\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(integerFormat.format(request.getMaximum()));\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(integerFormat.format(request.getStandardDeviation()));\n\t\t\twriteln(nextColumn);\n\t\t\tfinal String nbsp = \"&nbsp;\";\n\t\t\tif (request.getCpuTimeMean() >= 0) {\n\t\t\t\twriteln(integerFormat.format(request.getCpuTimeMean()));\n\t\t\t} else {\n\t\t\t\twriteln(nbsp);\n\t\t\t}\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(systemErrorFormat.format(request.getSystemErrorPercentage()));\n\t\t\tif (allChildHitsDisplayed) {\n\t\t\t\twriteln(nextColumn);\n\t\t\t\tfinal boolean childHitsDisplayed = request.hasChildHits();\n\t\t\t\tif (childHitsDisplayed) {\n\t\t\t\t\twriteln(integerFormat.format(request.getChildHitsMean()));\n\t\t\t\t} else {\n\t\t\t\t\twriteln(nbsp);\n\t\t\t\t}\n\t\t\t\twriteln(nextColumn);\n\t\t\t\tif (childHitsDisplayed) {\n\t\t\t\t\twriteln(integerFormat.format(request.getChildDurationsMean()));\n\t\t\t\t} else {\n\t\t\t\t\twriteln(nbsp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeCounterIcon(CounterRequest request) throws IOException {\n\t\t\tfinal Counter parentCounter = getCounterByRequestId(request);\n\t\t\tif (parentCounter != null && parentCounter.getIconName() != null) {\n\t\t\t\twriteln(\"<img src='?resource=\" + parentCounter.getIconName() + \"' alt='\"\n\t\t\t\t\t\t+ parentCounter.getName() + \"' width='16' height='16' />&nbsp;\");\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeGraphDetailScript(String graphName) throws IOException {\n\t\t\twriteln(SCRIPT_BEGIN);\n\t\t\twriteln(\"function handleHideMaximumClick(checkbox) {\");\n\t\t\twriteln(\"    var img = document.getElementById('img');\");\n\t\t\twriteln(\"    if (checkbox.checked) {\");\n\t\t\twriteln(\"        img.src = img.src + '\\\\u0026max=false\\\\u0026r=' + Math.random();\");\n\t\t\twriteln(\"    } else {\");\n\t\t\twriteln(\"        img.src = img.src.replace('\\\\u0026max=false','');\");\n\t\t\twriteln(\"    }\");\n\t\t\twriteln(\"}\");\n\t\t\twriteln(\"function scaleImage(v, min, max) {\");\n\t\t\twriteln(\"    var images = document.getElementsByClassName('synth\u00e8se');\");\n\t\t\twriteln(\"    w = (max - min) * v + min;\");\n\t\t\twriteln(\"    for (i = 0; i < images.length; i++) {\");\n\t\t\twriteln(\"        images[i].style.width = w + 'px';\");\n\t\t\twriteln(\"    }\");\n\t\t\twriteln(\"}\");\n\n\t\t\t// 'animate' our slider\n\t\t\twriteln(\"var slider = new Control.Slider('handle', 'track', {axis:'horizontal', alignX: 0, increment: 2});\");\n\n\t\t\t// resize the image as the slider moves. The image quality would deteriorate, but it\n\t\t\t// would not be final anyway. Once slider is released the image is re-requested from the server, where\n\t\t\t// it is rebuilt from vector format\n\t\t\twriteln(\"slider.options.onSlide = function(value) {\");\n\t\t\twriteln(\"  scaleImage(value, initialWidth, initialWidth / 2 * 3);\");\n\t\t\twriteln(\"}\");\n\n\t\t\t// this is where the slider is released and the image is reloaded\n\t\t\t// we use current style settings to work the required image dimensions\n\t\t\twriteln(\"slider.options.onChange = function(value) {\");\n\t\t\t// chop off \"px\" and round up float values\n\t\t\twriteln(\"  width = Math.round(Element.getStyle('img','width').replace('px','')) - 80;\");\n\t\t\twriteln(\"  height = Math.round(width * initialHeight / initialWidth) - 48;\");\n\t\t\t// reload the images\n\t\t\t// rq : on utilise des caract\u00e8res unicode pour \u00e9viter des warnings\n\t\t\twriteln(\"  document.getElementById('img').src = '?graph=\" + urlEncode(graphName)\n\t\t\t\t\t+ \"\\\\u0026width=' + width + '\\\\u0026height=' + height;\");\n\t\t\twriteln(\"  document.getElementById('img').style.width = '';\");\n\t\t\twriteln(\"}\");\n\t\t\twriteln(\"window.onload = function() {\");\n\t\t\twriteln(\"  if (navigator.appName == 'Microsoft Internet Explorer') {\");\n\t\t\twriteln(\"    initialWidth = document.getElementById('img').width;\");\n\t\t\twriteln(\"    initialHeight = document.getElementById('img').height;\");\n\t\t\twriteln(\"  } else {\");\n\t\t\twriteln(\"    initialWidth = Math.round(Element.getStyle('img','width').replace('px',''));\");\n\t\t\twriteln(\"    initialHeight = Math.round(Element.getStyle('img','height').replace('px',''));\");\n\t\t\twriteln(\"  }\");\n\t\t\twriteln(\"}\");\n\t\t\twriteln(SCRIPT_END);\n\t\t}",
        "method_after": "\t\tHtmlCounterRequestGraphReport(Range range, Writer writer) {\n\t\t\tsuper(writer);\n\t\t\tassert range != null;\n\t\t\tthis.range = range;\n\t\t}\n\n\t\t@Override\n\t\tvoid toHtml() {\n\t\t\tthrow new UnsupportedOperationException();\n\t\t}\n\n\t\tvoid writeRequestGraph(String requestId, String requestName) throws IOException {\n\t\t\tuniqueByPageAndGraphSequence++;\n\t\t\t// la classe tooltip est configur\u00e9e dans la css de HtmlReport\n\t\t\twrite(\"<a class='tooltip' href='?part=graph&amp;graph=\");\n\t\t\twrite(requestId);\n\t\t\twrite(\"'\");\n\t\t\t// ce onmouseover sert \u00e0 charger les graphs par requ\u00eate un par un et \u00e0 la demande\n\t\t\t// sans les charger tous au chargement de la page.\n\t\t\t// le onmouseover se d\u00e9sactive apr\u00e8s chargement pour ne pas recharger une image d\u00e9j\u00e0 charg\u00e9e\n\t\t\twrite(\" onmouseover=\\\"document.getElementById('\");\n\t\t\tfinal String id = \"id\" + uniqueByPageAndGraphSequence;\n\t\t\twrite(id);\n\t\t\twrite(\"').src='?graph=\");\n\t\t\twrite(requestId);\n\t\t\twrite(\"&amp;width=100&amp;height=50'; this.onmouseover=null;\\\" >\");\n\t\t\t// avant mouseover on prend une image qui sera mise en cache\n\t\t\twrite(\"<em><img src='?resource=db.png' id='\");\n\t\t\twrite(id);\n\t\t\twrite(\"' alt='graph'/></em>\");\n\t\t\tif (requestName.length() <= MAX_REQUEST_NAME_LENGTH) {\n\t\t\t\t// writeDirectly pour ne pas g\u00e9rer de traductions si le nom contient '#'\n\t\t\t\twriteDirectly(htmlEncodeRequestName(requestId, requestName));\n\t\t\t\twrite(\"</a>\");\n\t\t\t} else {\n\t\t\t\t// si une requ\u00eate a trop de caract\u00e8res, alors cela sature le tableau des requ\u00eates\n\t\t\t\t// et le rend peu lisible, donc on tronque cette requ\u00eate en ajoutant une action \"Details\".\n\t\t\t\twriteDirectly(htmlEncodeRequestName(requestId,\n\t\t\t\t\t\trequestName.substring(0, MAX_REQUEST_NAME_LENGTH)));\n\t\t\t\twrite(\"</a>\");\n\t\t\t\twrite(\"<br/> \");\n\n\t\t\t\tfinal String idToShow = \"request-\" + requestId;\n\t\t\t\twriteShowHideLink(idToShow, \"#Details#\");\n\t\t\t\twriteln(\"<div id='request-\" + requestId + \"' style='display: none;'>\");\n\t\t\t\twrite(\"<br/> \");\n\t\t\t\twriteDirectly(htmlEncodeRequestName(requestId, requestName));\n\t\t\t\twriteln(\"</div> \");\n\t\t\t}\n\t\t}\n\n\t\tvoid writeRequestAndGraphDetail(Collector collector, CollectorServer collectorServer,\n\t\t\t\tString graphName) throws IOException {\n\t\t\tcounters = collector.getRangeCounters(range);\n\t\t\trequestsById = mapAllRequestsById();\n\t\t\tfinal CounterRequest request = requestsById.get(graphName);\n\t\t\tif (request != null) {\n\t\t\t\twriteRequest(request);\n\n\t\t\t\tif (JdbcWrapper.SINGLETON.getSqlCounter().isRequestIdFromThisCounter(graphName)\n\t\t\t\t\t\t&& !request.getName().toLowerCase(Locale.ENGLISH).startsWith(\"alter \")) {\n\t\t\t\t\t// inutile d'essayer d'avoir le plan d'ex\u00e9cution des requ\u00eates sql\n\t\t\t\t\t// telles que \"alter session set ...\" (cf issue 152)\n\t\t\t\t\twriteSqlRequestExplainPlan(collector, collectorServer, request);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (isGraphDisplayed(collector, request)) {\n\t\t\t\twriteln(\"<table summary=''><tr><td>\");\n\t\t\t\twriteln(\"<div id='track' class='noPrint'>\");\n\t\t\t\twriteln(\"<div class='selected' id='handle'>\");\n\t\t\t\twriteln(\"<img src='?resource=scaler_slider.gif' alt=''/>\");\n\t\t\t\twriteln(\"</div></div>\");\n\t\t\t\twriteln(\"</td><td>\");\n\t\t\t\twriteDirectly(\"<div class='noPrint' style='color: #808080;'>\");\n\t\t\t\twriteln(\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\");\n\t\t\t\twriteln(\"<label for='cb'><input id='cb' type='checkbox' onclick=\\\"handleHideMaximumClick(this);\\\"/>&nbsp;#hide_maximum#</label>\");\n\t\t\t\twriteln(\"</div> \");\n\t\t\t\twriteln(\"</td></tr></table>\");\n\n\t\t\t\twriteln(\"<div align='center'>\");\n\t\t\t\twriteln(\"<table summary=''><tr><td>\");\n\t\t\t\twriteln(\"<img class='synth\u00e8se' id='img' src='\"\n\t\t\t\t\t\t+ \"?width=960&amp;height=400&amp;graph=\" + urlEncode(graphName)\n\t\t\t\t\t\t+ \"' alt='zoom'/>\");\n\t\t\t\twriteDirectly(\"<br/><div align='right' style='color: #808080;'>\");\n\t\t\t\twriteln(\"#graph_units#\");\n\t\t\t\twriteln(\"</div></td></tr></table>\");\n\t\t\t\twriteln(\"</div>\");\n\t\t\t\twriteln(\"<div align='right'><a href='?part=lastValue&amp;graph=\"\n\t\t\t\t\t\t+ urlEncode(graphName) + \"' title=\\\"#Lien_derniere_valeur#\\\">_</a></div>\");\n\n\t\t\t\twriteGraphDetailScript(graphName);\n\t\t\t}\n\t\t\tif (request != null && request.getStackTrace() != null) {\n\t\t\t\twriteln(\"<blockquote><blockquote><b>Stack-trace</b><br/><font size='-1'>\");\n\t\t\t\t// writeDirectly pour ne pas g\u00e9rer de traductions si la stack-trace contient '#'\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(request.getStackTrace()).replaceAll(\"\\t\",\n\t\t\t\t\t\t\"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;\"));\n\t\t\t\twriteln(\"</font></blockquote></blockquote>\");\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean isGraphDisplayed(Collector collector, CounterRequest request) {\n\t\t\treturn request == null || getCounterByRequestId(request) != null\n\t\t\t\t\t&& isRequestGraphDisplayed(getCounterByRequestId(request))\n\t\t\t\t\t// on v\u00e9rifie aussi que l'instance de jrobin existe pour faire le graph,\n\t\t\t\t\t// notamment si les statistiques ont \u00e9t\u00e9 r\u00e9initialis\u00e9es, ce qui vide les instances de jrobin\n\t\t\t\t\t&& collector.getJRobin(request.getId()) != null;\n\t\t}\n\n\t\tprivate void writeSqlRequestExplainPlan(Collector collector,\n\t\t\t\tCollectorServer collectorServer, CounterRequest sqlRequest) throws IOException {\n\t\t\ttry {\n\t\t\t\tfinal String explainPlan;\n\t\t\t\tif (collectorServer == null) {\n\t\t\t\t\texplainPlan = DatabaseInformations.explainPlanFor(sqlRequest.getName());\n\t\t\t\t} else {\n\t\t\t\t\texplainPlan = collectorServer.collectSqlRequestExplainPlan(\n\t\t\t\t\t\t\tcollector.getApplication(), sqlRequest.getName());\n\t\t\t\t}\n\t\t\t\t// rq : si explainPlan \u00e9tait un tableau (ex: mysql),\n\t\t\t\t// on pourrait utiliser HtmlDatabaseInformationsReport.TableReport\n\t\t\t\tif (explainPlan != null) {\n\t\t\t\t\twriteln(\"<b>#Plan_d_execution#</b>\");\n\t\t\t\t\twriteln(\"<div class='explainPlan'>\");\n\t\t\t\t\twriteDirectly(explainPlan.replace(\" \", \"&nbsp;\").replace(\"\\n\", \"<br/>\"));\n\t\t\t\t\twriteln(\"</div><hr/>\");\n\t\t\t\t}\n\t\t\t} catch (final Exception e) {\n\t\t\t\twriteln(\"<b>#Plan_d_execution#</b> \");\n\t\t\t\twriteln(e.toString());\n\t\t\t\twriteln(\"<br/>\");\n\t\t\t}\n\t\t}\n\n\t\tvoid writeRequestUsages(Collector collector, String requestId) throws IOException {\n\t\t\tassert requestId != null;\n\t\t\tcounters = collector.getRangeCounters(range);\n\t\t\tCounterRequest myRequest = null;\n\t\t\tfinal List<CounterRequest> requests = new ArrayList<CounterRequest>();\n\t\t\tfor (final Counter counter : counters) {\n\t\t\t\tfor (final CounterRequest request : counter.getOrderedRequests()) {\n\t\t\t\t\tif (myRequest == null && request.getId().equals(requestId)) {\n\t\t\t\t\t\tmyRequest = request;\n\t\t\t\t\t}\n\t\t\t\t\tif (request.containsChildRequest(requestId)) {\n\t\t\t\t\t\trequests.add(request);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\twriteRequestUsages(myRequest, requests);\n\t\t}\n\n\t\tprivate void writeRequestUsages(CounterRequest myRequest, List<CounterRequest> requests)\n\t\t\t\tthrows IOException {\n\t\t\twriteln(\"<br/><b>#Utilisations_de#</b>\");\n\t\t\tif (myRequest != null) {\n\t\t\t\twriteDirectly(htmlEncodeRequestName(myRequest.getId(), myRequest.getName()));\n\t\t\t}\n\t\t\twriteln(\"<br/><br/>\");\n\t\t\tif (requests.isEmpty()) {\n\t\t\t\twriteln(\"#Aucune_requete#\");\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfinal boolean someUsagesDisplayed = getUsagesDisplayed(requests);\n\t\t\tfinal HtmlTable table = new HtmlTable();\n\t\t\ttable.beginTable(getString(\"Utilisations_de\"));\n\t\t\twrite(\"<th>#Requete#</th>\");\n\t\t\tif (someUsagesDisplayed) {\n\t\t\t\twrite(\"<th class='noPrint'>#Chercher_utilisations#</th>\");\n\t\t\t}\n\t\t\tfor (final CounterRequest request : requests) {\n\t\t\t\ttable.nextRow();\n\t\t\t\twriteUsedRequest(request, someUsagesDisplayed);\n\t\t\t}\n\t\t\ttable.endTable();\n\t\t}\n\n\t\tprivate void writeUsedRequest(CounterRequest request, boolean someUsageDisplayed)\n\t\t\t\tthrows IOException {\n\t\t\twriteln(\" <td>\");\n\t\t\twriteCounterIcon(request);\n\t\t\twriteRequestGraph(request.getId(), request.getName());\n\t\t\tif (someUsageDisplayed) {\n\t\t\t\twriteln(\"</td><td align='center' class='noPrint'>\");\n\t\t\t\tif (doesRequestDisplayUsages(request)) {\n\t\t\t\t\twriteln(\"<a href='?part=usages&amp;graph=\" + request.getId() + \"'>\");\n\t\t\t\t\twriteln(\"<img src='?resource=find.png' alt='#Chercher_utilisations#' title='#Chercher_utilisations#'/></a>\");\n\t\t\t\t} else {\n\t\t\t\t\twriteln(\"&nbsp;\");\n\t\t\t\t}\n\t\t\t}\n\t\t\twriteln(\"</td>\");\n\t\t}\n\n\t\tprivate boolean getUsagesDisplayed(List<CounterRequest> requests) {\n\t\t\tfor (final CounterRequest request : requests) {\n\t\t\t\tif (doesRequestDisplayUsages(request)) {\n\t\t\t\t\treturn true;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn false;\n\t\t}\n\n\t\tprivate void writeRequest(CounterRequest request) throws IOException {\n\t\t\tfinal Map<String, Long> childRequests = request.getChildRequestsExecutionsByRequestId();\n\t\t\twriteln(\" <br/>\");\n\t\t\tfinal HtmlTable table = new HtmlTable();\n\t\t\ttable.beginTable(getString(\"Drill_down\"));\n\t\t\twriteln(\"<th>#Requete#</th>\");\n\t\t\tfinal boolean hasChildren = !childRequests.isEmpty();\n\t\t\tif (hasChildren) {\n\t\t\t\twriteln(\"<th class='sorttable_numeric'>#Hits_par_requete#</th>\");\n\t\t\t}\n\t\t\twriteln(\"<th class='sorttable_numeric'>#Temps_moyen#</th><th class='sorttable_numeric'>#Temps_max#</th>\");\n\t\t\twriteln(\"<th class='sorttable_numeric'>#Ecart_type#</th><th class='sorttable_numeric'>#Temps_cpu_moyen#</th>\");\n\t\t\twriteln(\"<th class='sorttable_numeric'>#erreur_systeme#</th>\");\n\t\t\tfinal Counter parentCounter = getCounterByRequestId(request);\n\t\t\tfinal boolean allChildHitsDisplayed = parentCounter != null\n\t\t\t\t\t&& parentCounter.getChildCounterName() != null && request.hasChildHits();\n\t\t\tif (allChildHitsDisplayed) {\n\t\t\t\tfinal String childCounterName = parentCounter.getChildCounterName();\n\t\t\t\twriteln(\"<th class='sorttable_numeric'>\"\n\t\t\t\t\t\t+ getFormattedString(\"hits_fils_moyens\", childCounterName));\n\t\t\t\twriteln(\"</th><th class='sorttable_numeric'>\"\n\t\t\t\t\t\t+ getFormattedString(\"temps_fils_moyen\", childCounterName) + \"</th>\");\n\t\t\t}\n\t\t\ttable.nextRow();\n\t\t\twrite(\"<td class='wrappedText'>\");\n\t\t\twriteCounterIcon(request);\n\t\t\twriteDirectly(htmlEncodeRequestName(request.getId(), request.getName()));\n\t\t\tif (hasChildren) {\n\t\t\t\twriteln(\"</td><td>&nbsp;\");\n\t\t\t}\n\t\t\twriteRequestValues(request, allChildHitsDisplayed);\n\t\t\twriteln(\"</td> \");\n\n\t\t\tif (hasChildren) {\n\t\t\t\twriteChildRequests(request, childRequests, allChildHitsDisplayed, table);\n\t\t\t}\n\t\t\ttable.endTable();\n\t\t\tif (doesRequestDisplayUsages(request)) {\n\t\t\t\twriteln(\"<div align='right' class='noPrint'>\");\n\t\t\t\twriteln(\"<a href='?part=usages&amp;graph=\" + request.getId() + \"'>\");\n\t\t\t\twriteln(\"<img src='?resource=find.png' alt='#Chercher_utilisations#' \");\n\t\t\t\twriteln(\"title='#Chercher_utilisations#'/> #Chercher_utilisations#</a></div>\");\n\t\t\t} else {\n\t\t\t\twriteln(\"<br/>\");\n\t\t\t}\n\t\t}\n\n\t\tprivate boolean doesRequestDisplayUsages(CounterRequest request) {\n\t\t\tfinal Counter parentCounter = getCounterByRequestId(request);\n\t\t\treturn parentCounter != null && !parentCounter.isErrorCounter()\n\t\t\t\t\t&& !Counter.HTTP_COUNTER_NAME.equals(parentCounter.getName());\n\t\t}\n\n\t\tprivate void writeChildRequests(CounterRequest request, Map<String, Long> childRequests,\n\t\t\t\tboolean allChildHitsDisplayed, HtmlTable table) throws IOException {\n\t\t\tfor (final Map.Entry<String, Long> entry : childRequests.entrySet()) {\n\t\t\t\tfinal CounterRequest childRequest = requestsById.get(entry.getKey());\n\t\t\t\tif (childRequest != null) {\n\t\t\t\t\ttable.nextRow();\n\t\t\t\t\tfinal Long nbExecutions = entry.getValue();\n\t\t\t\t\tfinal float executionsByRequest = (float) nbExecutions / request.getHits();\n\t\t\t\t\twriteChildRequest(childRequest, executionsByRequest, allChildHitsDisplayed);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeChildRequest(CounterRequest childRequest, float executionsByRequest,\n\t\t\t\tboolean allChildHitsDisplayed) throws IOException {\n\t\t\twriteln(\"<td>\");\n\t\t\twriteln(\"<div style='margin-left: 10px;' class='wrappedText'>\");\n\t\t\twriteCounterIcon(childRequest);\n\t\t\twriteRequestGraph(childRequest.getId(), childRequest.getName());\n\t\t\twriteln(\"</div></td><td align='right'>\");\n\t\t\twrite(nbExecutionsFormat.format(executionsByRequest));\n\t\t\twriteRequestValues(childRequest, allChildHitsDisplayed);\n\t\t\twriteln(\"</td>\");\n\t\t}\n\n\t\tprivate void writeRequestValues(CounterRequest request, boolean allChildHitsDisplayed)\n\t\t\t\tthrows IOException {\n\t\t\tfinal String nextColumn = \"</td><td align='right'>\";\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(integerFormat.format(request.getMean()));\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(integerFormat.format(request.getMaximum()));\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(integerFormat.format(request.getStandardDeviation()));\n\t\t\twriteln(nextColumn);\n\t\t\tfinal String nbsp = \"&nbsp;\";\n\t\t\tif (request.getCpuTimeMean() >= 0) {\n\t\t\t\twriteln(integerFormat.format(request.getCpuTimeMean()));\n\t\t\t} else {\n\t\t\t\twriteln(nbsp);\n\t\t\t}\n\t\t\twriteln(nextColumn);\n\t\t\twriteln(systemErrorFormat.format(request.getSystemErrorPercentage()));\n\t\t\tif (allChildHitsDisplayed) {\n\t\t\t\twriteln(nextColumn);\n\t\t\t\tfinal boolean childHitsDisplayed = request.hasChildHits();\n\t\t\t\tif (childHitsDisplayed) {\n\t\t\t\t\twriteln(integerFormat.format(request.getChildHitsMean()));\n\t\t\t\t} else {\n\t\t\t\t\twriteln(nbsp);\n\t\t\t\t}\n\t\t\t\twriteln(nextColumn);\n\t\t\t\tif (childHitsDisplayed) {\n\t\t\t\t\twriteln(integerFormat.format(request.getChildDurationsMean()));\n\t\t\t\t} else {\n\t\t\t\t\twriteln(nbsp);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeCounterIcon(CounterRequest request) throws IOException {\n\t\t\tfinal Counter parentCounter = getCounterByRequestId(request);\n\t\t\tif (parentCounter != null && parentCounter.getIconName() != null) {\n\t\t\t\twriteln(\"<img src='?resource=\" + parentCounter.getIconName() + \"' alt='\"\n\t\t\t\t\t\t+ parentCounter.getName() + \"' width='16' height='16' />&nbsp;\");\n\t\t\t}\n\t\t}\n\n\t\tprivate void writeGraphDetailScript(String graphName) throws IOException {\n\t\t\twriteln(SCRIPT_BEGIN);\n\t\t\twriteln(\"function handleHideMaximumClick(checkbox) {\");\n\t\t\twriteln(\"    var img = document.getElementById('img');\");\n\t\t\twriteln(\"    if (checkbox.checked) {\");\n\t\t\twriteln(\"        img.src = img.src + '\\\\u0026max=false\\\\u0026r=' + Math.random();\");\n\t\t\twriteln(\"    } else {\");\n\t\t\twriteln(\"        img.src = img.src.replace('\\\\u0026max=false','');\");\n\t\t\twriteln(\"    }\");\n\t\t\twriteln(\"}\");\n\t\t\twriteln(\"function scaleImage(v, min, max) {\");\n\t\t\twriteln(\"    var images = document.getElementsByClassName('synth\u00e8se');\");\n\t\t\twriteln(\"    w = (max - min) * v + min;\");\n\t\t\twriteln(\"    for (i = 0; i < images.length; i++) {\");\n\t\t\twriteln(\"        images[i].style.width = w + 'px';\");\n\t\t\twriteln(\"    }\");\n\t\t\twriteln(\"}\");\n\n\t\t\t// 'animate' our slider\n\t\t\twriteln(\"var slider = new Control.Slider('handle', 'track', {axis:'horizontal', alignX: 0, increment: 2});\");\n\n\t\t\t// resize the image as the slider moves. The image quality would deteriorate, but it\n\t\t\t// would not be final anyway. Once slider is released the image is re-requested from the server, where\n\t\t\t// it is rebuilt from vector format\n\t\t\twriteln(\"slider.options.onSlide = function(value) {\");\n\t\t\twriteln(\"  scaleImage(value, initialWidth, initialWidth / 2 * 3);\");\n\t\t\twriteln(\"}\");\n\n\t\t\t// this is where the slider is released and the image is reloaded\n\t\t\t// we use current style settings to work the required image dimensions\n\t\t\twriteln(\"slider.options.onChange = function(value) {\");\n\t\t\t// chop off \"px\" and round up float values\n\t\t\twriteln(\"  width = Math.round(Element.getStyle('img','width').replace('px','')) - 80;\");\n\t\t\twriteln(\"  height = Math.round(width * initialHeight / initialWidth) - 48;\");\n\t\t\t// reload the images\n\t\t\t// rq : on utilise des caract\u00e8res unicode pour \u00e9viter des warnings\n\t\t\twriteln(\"  document.getElementById('img').src = '?graph=\" + I18N.htmlEncode(urlEncode(graphName), false)\n\t\t\t\t\t+ \"\\\\u0026width=' + width + '\\\\u0026height=' + height;\");\n\t\t\twriteln(\"  document.getElementById('img').style.width = '';\");\n\t\t\twriteln(\"}\");\n\t\t\twriteln(\"window.onload = function() {\");\n\t\t\twriteln(\"  if (navigator.appName == 'Microsoft Internet Explorer') {\");\n\t\t\twriteln(\"    initialWidth = document.getElementById('img').width;\");\n\t\t\twriteln(\"    initialHeight = document.getElementById('img').height;\");\n\t\t\twriteln(\"  } else {\");\n\t\t\twriteln(\"    initialWidth = Math.round(Element.getStyle('img','width').replace('px',''));\");\n\t\t\twriteln(\"    initialHeight = Math.round(Element.getStyle('img','height').replace('px',''));\");\n\t\t\twriteln(\"  }\");\n\t\t\twriteln(\"}\");\n\t\t\twriteln(SCRIPT_END);\n\t\t}"
    },
    {
        "idx": "82",
        "vuln_id": "CVE-2011-1582",
        "desc": "Apache Tomcat 7.0.12 and 7.0.13 processes the first request to a servlet without following security constraints that have been configured through annotations, which allows remote attackers to bypass intended access restrictions via HTTP requests. NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1088, CVE-2011-1183, and CVE-2011-1419.",
        "cwe_id": "CWE-264",
        "cwe_name": "Permissions, Privileges, and Access Controls",
        "repo": "https://github.com/apache/tomcat",
        "commit": "299b26af66793438c323ea6b18462fa44683080f",
        "method_before": "    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParentClassLoader().loadClass(getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }",
        "method_after": "    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParent().getLoader().getClassLoader().loadClass(\n                        getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }"
    },
    {
        "idx": "278",
        "vuln_id": "CVE-2014-3490",
        "desc": "['RESTEasy 2.3.1 before 2.3.8.SP2 and 3.x before 3.0.9, as used in Red Hat JBoss Enterprise Application Platform (EAP) 6.3.0, does not disable external entities when the resteasy.document.expand.entity.references parameter is set to false, which allows remote attackers to read arbitrary files and have other unspecified impact via unspecified vectors, related to an XML External Entity (XXE) issue.  NOTE: this vulnerability exists because of an incomplete fix for CVE-2012-0818.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/ronsigal/Resteasy",
        "commit": "9b7d0f574cafdcf3bea5428f3145ab4908fc6d83"
    },
    {
        "idx": "295",
        "vuln_id": "CVE-2014-7809",
        "desc": "Apache Struts 2.0.0 through 2.3.x before 2.3.20 uses predictable <s:token/> values, which allows remote attackers to bypass the CSRF protection mechanism.",
        "cwe_id": "CWE-352",
        "cwe_name": "Cross-Site Request Forgery (CSRF)",
        "repo": "https://github.com/apache/struts",
        "commit": "1f301038a751bf16e525607c3db513db835b2999"
    },
    {
        "idx": "311",
        "vuln_id": "CVE-2015-1831",
        "desc": "['The default exclude patterns (excludeParams) in Apache Struts 2.3.20 allow remote attackers to \"compromise internal state of an application\" via unspecified vectors.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/struts",
        "commit": "d832747d647df343ed07a58b1b5e540a05a4d51b"
    },
    {
        "idx": "365",
        "vuln_id": "CVE-2015-8320",
        "desc": "['Apache Cordova-Android before 3.7.0 improperly generates random values for BridgeSecret data, which makes it easier for attackers to conduct bridge hijacking attacks by predicting a value.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/cordova-android",
        "commit": "032ea8a8d386d8bcffc5de7fd3e4202478effb7d",
        "method_before": "    private boolean verifySecret(String action, int bridgeSecret) throws IllegalAccessException {\n        if (!jsMessageQueue.isBridgeEnabled()) {\n            if (bridgeSecret == -1) {\n                Log.d(LOG_TAG, action + \" call made before bridge was enabled.\");\n            } else {\n                Log.d(LOG_TAG, \"Ignoring \" + action + \" from previous page load.\");\n            }\n            return false;\n        }\n        // Bridge secret wrong and bridge not due to it being from the previous page.\n        if (expectedBridgeSecret < 0 || bridgeSecret != expectedBridgeSecret) {\n            throw new IllegalAccessException();\n        }\n        return true;\n    }",
        "method_after": "    private boolean verifySecret(String action, int bridgeSecret) throws IllegalAccessException {\n        if (!jsMessageQueue.isBridgeEnabled()) {\n            if (bridgeSecret == -1) {\n                Log.d(LOG_TAG, action + \" call made before bridge was enabled.\");\n            } else {\n                Log.d(LOG_TAG, \"Ignoring \" + action + \" from previous page load.\");\n            }\n            return false;\n        }\n        // Bridge secret wrong and bridge not due to it being from the previous page.\n        if (expectedBridgeSecret < 0 || bridgeSecret != expectedBridgeSecret) {\n            Log.e(LOG_TAG, \"Bridge access attempt with wrong secret token, possibly from malicious code. Disabling exec() bridge!\");\n            clearBridgeSecret();\n            throw new IllegalAccessException();\n        }\n        return true;\n    }"
    },
    {
        "idx": "380",
        "vuln_id": "CVE-2016-0783",
        "desc": "The sendHashByUser function in Apache OpenMeetings before 3.1.1 generates predictable password reset tokens, which makes it easier for remote attackers to reset arbitrary user passwords by leveraging knowledge of a user name and the current system time.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/apache/openmeetings",
        "commit": "7eef674039acd587bc46c1c399d3bdf058f0919b"
    },
    {
        "idx": "418",
        "vuln_id": "CVE-2016-3720",
        "desc": "['XML external entity (XXE) vulnerability in XmlMapper in the Data format extension for Jackson (aka jackson-dataformat-xml) allows attackers to have unspecified impact via unknown vectors.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/FasterXML/jackson-dataformat-xml",
        "commit": "f0f19a4c924d9db9a1e2830434061c8640092cc0",
        "method_before": "    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }",
        "method_after": "    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }"
    },
    {
        "idx": "512",
        "vuln_id": "CVE-2016-7051",
        "desc": "XmlMapper in the Jackson XML dataformat component (aka jackson-dataformat-xml) before 2.7.8 and 2.8.x before 2.8.4 allows remote attackers to conduct server-side request forgery (SSRF) attacks via vectors related to a DTD.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/FasterXML/jackson-dataformat-xml",
        "commit": "eeff2c312e9d4caa8c9f27b8f740c7529d00524a",
        "method_before": "    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }",
        "method_after": "    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n            // and ditto wrt [dataformat-xml#211], SUPPORT_DTD\n            xmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }"
    },
    {
        "idx": "593",
        "vuln_id": "CVE-2017-12795",
        "desc": "OpenMRS openmrs-module-htmlformentry 3.3.2 is affected by: (Improper Input Validation).",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "86f35221c8a57cdd7557ce731a56b90db216c8e0",
        "method_before": "\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}",
        "method_after": "\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\n        Context.requirePrivilege(\"Manage Forms\");\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}"
    },
    {
        "idx": "695",
        "vuln_id": "CVE-2017-8028",
        "desc": "In Pivotal Spring-LDAP versions 1.3.0 - 2.3.1, when connected to some LDAP servers, when no additional attributes are bound, and when using LDAP BindAuthenticator with org.springframework.ldap.core.support.DefaultTlsDirContextAuthenticationStrategy as the authentication strategy, and setting userSearch, authentication is allowed with an arbitrary password when the username is correct. This occurs because some LDAP vendors require an explicit operation for the LDAP bind to take effect.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/spring-projects/spring-ldap",
        "commit": "08e8ae289bbd1b581986c7238604a147119c1336",
        "method_before": "\tprotected void applyAuthentication(LdapContext ctx, String userDn, String password) throws NamingException {\n\t\tctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION);\n\t\tctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDn);\n\t\tctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n\t}",
        "method_after": "\tprotected void applyAuthentication(LdapContext ctx, String userDn, String password) throws NamingException {\n\t\tctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION);\n\t\tctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDn);\n\t\tctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n\t\t// Force reconnect with user credentials\n\t\tctx.reconnect(null);\n\t}"
    },
    {
        "idx": "714",
        "vuln_id": "CVE-2018-1000008",
        "desc": "Jenkins PMD Plugin 3.49 and earlier processes XML external entities in files it parses as part of the build process, allowing attackers with user permissions in Jenkins to extract secrets from the Jenkins master, perform server-side request forgery, or denial-of-service attacks.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/jenkinsci/pmd-plugin",
        "commit": "f88399a021c22e30cb8fbac5200471d69f1b6224",
        "method_before": "    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            Digester digester = new Digester();\n            digester.setValidating(false);\n            digester.setClassLoader(PmdParser.class.getClassLoader());\n\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }",
        "method_after": "    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            SecureDigester digester = new SecureDigester(PmdParser.class);\n\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }"
    },
    {
        "idx": "719",
        "vuln_id": "CVE-2018-1000067",
        "desc": "An improper authorization vulnerability exists in Jenkins versions 2.106 and earlier, and LTS 2.89.3 and earlier, that allows an attacker to have Jenkins submit HTTP GET requests and get limited information about the response.",
        "cwe_id": "CWE-918",
        "cwe_name": "Server-Side Request Forgery (SSRF)",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "2d16b459205730d85e51499c2457109b234ca9d9",
        "method_before": "    public static class DescriptorImpl extends Descriptor<ProxyConfiguration> {\n        @Override\n        public String getDisplayName() {\n            return \"Proxy Configuration\";\n        }\n\n        public FormValidation doCheckPort(@QueryParameter String value) {\n            value = Util.fixEmptyAndTrim(value);\n            if (value == null) {\n                return FormValidation.ok();\n            }\n            int port;\n            try {\n                port = Integer.parseInt(value);\n            } catch (NumberFormatException e) {\n                return FormValidation.error(Messages.PluginManager_PortNotANumber());\n            }\n            if (port < 0 || port > 65535) {\n                return FormValidation.error(Messages.PluginManager_PortNotInRange(0, 65535));\n            }\n            return FormValidation.ok();\n        }\n\n        @RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n                \n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n                \n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n            \n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }",
        "method_after": "    public static class DescriptorImpl extends Descriptor<ProxyConfiguration> {\n        @Override\n        public String getDisplayName() {\n            return \"Proxy Configuration\";\n        }\n\n        public FormValidation doCheckPort(@QueryParameter String value) {\n            value = Util.fixEmptyAndTrim(value);\n            if (value == null) {\n                return FormValidation.ok();\n            }\n            int port;\n            try {\n                port = Integer.parseInt(value);\n            } catch (NumberFormatException e) {\n                return FormValidation.error(Messages.PluginManager_PortNotANumber());\n            }\n            if (port < 0 || port > 65535) {\n                return FormValidation.error(Messages.PluginManager_PortNotInRange(0, 65535));\n            }\n            return FormValidation.ok();\n        }\n\n        @RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n                \n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n                \n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n            \n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }"
    },
    {
        "idx": "758",
        "vuln_id": "CVE-2018-10862",
        "desc": "WildFly Core before version 6.0.0.Alpha3 does not properly validate file paths in .war archives, allowing for the extraction of crafted .war archives to overwrite arbitrary files. This is an instance of the 'Zip Slip' vulnerability.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/wildfly/wildfly-core",
        "commit": "40996ae6d5d3b6c1602a15f96b86a8d8a39b53eb"
    },
    {
        "idx": "780",
        "vuln_id": "CVE-2018-11771",
        "desc": "When reading a specially crafted ZIP archive, the read method of Apache Commons Compress 1.7 to 1.17's ZipArchiveInputStream can fail to return the correct EOF indication after the end of the stream has been reached. When combined with a java.io.InputStreamReader this can lead to an infinite stream, which can be used to mount a denial of service attack against services that use Compress' zip package.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "a41ce6892cb0590b2e658704434ac0dbcb6834c8",
        "method_before": "    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }",
        "method_after": "    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                buf.limit(0);\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }"
    },
    {
        "idx": "882",
        "vuln_id": "CVE-2018-15531",
        "desc": "JavaMelody before 1.74.0 has XXE via parseSoapMethodName in bull/javamelody/PayloadNameRequestWrapper.java.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/javamelody/javamelody",
        "commit": "ef111822562d0b9365bd3e671a75b65bd0613353",
        "method_before": "\tprivate static String parseSoapMethodName(InputStream stream, String charEncoding) {\n\t\ttry {\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfinal XMLStreamReader xmlReader;\n\t\t\tif (charEncoding != null) {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\n\t\t\t} else {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\n\t\t\t}\n\n\t\t\t//best-effort parsing\n\n\t\t\t//start document, go to first tag\n\t\t\txmlReader.nextTag();\n\n\t\t\t//expect first tag to be \"Envelope\"\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\t//scan for body tag\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\txmlReader.nextTag();\n\n\t\t\t//tag is method name\n\t\t\treturn \".\" + xmlReader.getLocalName();\n\t\t} catch (final XMLStreamException e) {\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\n\t\t\t//failed\n\t\t\treturn null;\n\t\t}\n\t}",
        "method_after": "\tprivate static String parseSoapMethodName(InputStream stream, String charEncoding) {\n\t\ttry {\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // disable DTDs entirely for that factory\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // disable external entities\n\t\t\tfinal XMLStreamReader xmlReader;\n\t\t\tif (charEncoding != null) {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\n\t\t\t} else {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\n\t\t\t}\n\n\t\t\t//best-effort parsing\n\n\t\t\t//start document, go to first tag\n\t\t\txmlReader.nextTag();\n\n\t\t\t//expect first tag to be \"Envelope\"\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\t//scan for body tag\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\txmlReader.nextTag();\n\n\t\t\t//tag is method name\n\t\t\treturn \".\" + xmlReader.getLocalName();\n\t\t} catch (final XMLStreamException e) {\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\n\t\t\t//failed\n\t\t\treturn null;\n\t\t}\n\t}"
    },
    {
        "idx": "1010",
        "vuln_id": "CVE-2019-1010245",
        "desc": "The Linux Foundation ONOS SDN Controller 1.15 and earlier versions is affected by: Improper Input Validation. The impact is: A remote attacker can execute arbitrary commands on the controller. The component is: apps/yang/src/main/java/org/onosproject/yang/impl/YangLiveCompilerManager.java. The attack vector is: network connectivity. The fixed version is: 1.15.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/opennetworkinglab/onos",
        "commit": "c6455baca3ad15813ffb4f2a78f56b897c9ee5b6",
        "method_before": "    public static String getValidModelId(String id) throws\n            IllegalArgumentException {\n        // checking weather modelId contains the alphanumeric character or not.\n        if (id.matches(\".*[A-Za-z0-9].*\")) {\n            // replacing special characters with '_'\n            id = id.replaceAll(\"[\\\\s\\\\/:*?\\\"\\\\[\\\\]<>|$@!#%&(){}';.,-]\", \"_\");\n            // remove leading and trailing underscore\n            id = id.replaceAll(\"^_+|_+$\", \"\");\n            // replacing the consecutive underscores '_' to single _\n            id = id.replaceAll(\"_+\", \"_\");\n            return id;\n        } else {\n            throw new IllegalArgumentException(\"Invalid model id \" + id);\n        }\n    }",
        "method_after": "    public static String getValidModelId(String id) throws\n            IllegalArgumentException {\n        // checking whether modelId contains the alphanumeric character or not.\n        if (id.matches(\".*[A-Za-z0-9].*\")) {\n            // replacing special characters with '_'\n            id = id.replaceAll(\"[\\\\s\\\\/:*?\\\"\\\\[\\\\]<>|$@!#%&(){}'`;.,-]\", \"_\");\n            // remove leading and trailing underscore\n            id = id.replaceAll(\"^_+|_+$\", \"\");\n            // replacing the consecutive underscores '_' to single _\n            id = id.replaceAll(\"_+\", \"_\");\n            return id;\n        } else {\n            throw new IllegalArgumentException(\"Invalid model id \" + id);\n        }\n    }"
    },
    {
        "idx": "1034",
        "vuln_id": "CVE-2019-11772",
        "desc": "In Eclipse OpenJ9 prior to 0.15, the String.getBytes(int, int, byte[], int) method does not verify that the provided byte array is non-null nor that the provided index is in bounds when compiled by the JIT. This allows arbitrary writes to any 32-bit address or beyond the end of a byte array within Java code run under a SecurityManager.",
        "cwe_id": "CWE-787",
        "cwe_name": "Out-of-bounds Write",
        "repo": "https://github.com/eclipse/openj9",
        "commit": "f1244665be5ac08b1e16f6ed80574529a62392cb",
        "method_before": "\tpublic void getBytes(int start, int end, byte[] data, int index) {\n\t\tif (0 <= start && start <= end && end <= lengthInternal()) {\n\t\t\t// Check if the String is compressed\n\t\t\tif (enableCompression && (null == compressionFlag || coder == LATIN1)) {\n\t\t\t\tcompressedArrayCopy(value, start, data, index, end - start);\n\t\t\t} else {\n\t\t\t\tcompress(value, start, data, index, end - start);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new StringIndexOutOfBoundsException();\n\t\t}\n\t}",
        "method_after": "\tpublic void getBytes(int start, int end, byte[] data, int index) {\n\t\tif (0 <= start && start <= end && end <= lengthInternal() && 0 <= index && ((end - start) <= (data.length - index))) {\n\t\t\t// Check if the String is compressed\n\t\t\tif (enableCompression && (null == compressionFlag || coder == LATIN1)) {\n\t\t\t\tcompressedArrayCopy(value, start, data, index, end - start);\n\t\t\t} else {\n\t\t\t\tcompress(value, start, data, index, end - start);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new StringIndexOutOfBoundsException();\n\t\t}\n\t}"
    },
    {
        "idx": "1045",
        "vuln_id": "CVE-2019-16335",
        "desc": "A Polymorphic Typing issue was discovered in FasterXML jackson-databind before 2.9.10. It is related to com.zaxxer.hikari.HikariDataSource. This is a different vulnerability than CVE-2019-14540.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "73c1c2cc76e6cdd7f3a5615cbe3207fe96e4d3db"
    },
    {
        "idx": "1161",
        "vuln_id": "CVE-2021-27582",
        "desc": "org/mitre/oauth2/web/OAuthConfirmationController.java in the OpenID Connect server implementation for MITREid Connect through 1.3.3 contains a Mass Assignment (aka Autobinding) vulnerability. This arises due to unsafe usage of the @ModelAttribute annotation during the OAuth authorization flow, in which HTTP request parameters affect an authorizationRequest.",
        "cwe_id": "CWE-1321",
        "cwe_name": "Improperly Controlled Modification of Object Prototype Attributes ('Prototype Pollution')",
        "repo": "https://github.com/mitreid-connect/OpenID-Connect-Java-Spring-Server",
        "commit": "7eba3c12fed82388f917e8dd9b73e86e3a311e4c"
    },
    {
        "idx": "1349",
        "vuln_id": "CVE-2017-2582",
        "desc": "It was found that while parsing the SAML messages the StaxParserUtil class of keycloak before 2.5.1 replaces special strings for obtaining attribute values with system property. This could allow an attacker to determine values of system properties at the attacked system by formatting the SAML request ID field to be the chosen system property which could be obtained in the \"InResponseTo\" field in the response.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/keycloak/keycloak",
        "commit": "0cb5ba0f6e83162d221681f47b470c3042eef237"
    },
    {
        "idx": "1358",
        "vuln_id": "CVE-2017-2611",
        "desc": "Jenkins before versions 2.44, 2.32.2 is vulnerable to an insufficient permission check for periodic processes (SECURITY-389). The URLs /workspaceCleanup and /fingerprintCleanup did not perform permission checks, allowing users with read access to Jenkins to trigger these background processes (that are otherwise performed daily), possibly causing additional load on Jenkins master and agents.",
        "cwe_id": "CWE-863",
        "cwe_name": "Incorrect Authorization",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "97a61a9fe55f4c16168c123f98301a5173b9fa86"
    },
    {
        "idx": "1472",
        "vuln_id": "CVE-2019-14837",
        "desc": "A flaw was found in keycloack before version 8.0.0. The owner of 'placeholder.org' domain can setup mail server on this domain and knowing only name of a client can reset password and then log in. For example, for client name 'test' the email address will be 'service-account-test@placeholder.org'.",
        "cwe_id": "CWE-798",
        "cwe_name": "Use of Hard-coded Credentials",
        "repo": "https://github.com/keycloak/keycloak",
        "commit": "9a7c1a91a59ab85e7f8889a505be04a71580777f"
    },
    {
        "idx": "1507",
        "vuln_id": "CVE-2019-17267",
        "desc": "A Polymorphic Typing issue was discovered in FasterXML jackson-databind before 2.9.10. It is related to net.sf.ehcache.hibernate.EhcacheJtaTransactionManagerLookup.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "191a4cdf87b56d2ddddb77edd895ee756b7f75eb"
    },
    {
        "idx": "1543",
        "vuln_id": "CVE-2020-11113",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.4 mishandles the interaction between serialization gadgets and typing, related to org.apache.openjpa.ee.WASRegistryManagedRuntime (aka openjpa).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "e2ba12d5d60715d95105e3e790fc234cfb59893d"
    },
    {
        "idx": "1597",
        "vuln_id": "CVE-2020-9447",
        "desc": "There is an XSS (cross-site scripting) vulnerability in GwtUpload 1.0.3 in the file upload functionality. Someone can upload a file with a malicious filename, which contains JavaScript code, which would result in XSS. Cross-site scripting enables attackers to steal data, change the appearance of a website, and perform other malicious activities like phishing or drive-by hacking.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/manolo/gwtupload",
        "commit": "9164fd469a2d5ae82824d5407385eb6fd3fa3fe1"
    },
    {
        "idx": "1600",
        "vuln_id": "CVE-2021-20190",
        "desc": "A flaw was found in jackson-databind before 2.9.10.7. FasterXML mishandles the interaction between serialization gadgets and typing. The highest threat from this vulnerability is to data confidentiality and integrity as well as system availability.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "7dbf51bf78d157098074a20bd9da39bd48c18e4a"
    },
    {
        "idx": "1609",
        "vuln_id": "unknown-1",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "a4a4d16783d1f38a8b2b10f58f9f28ea154cd834",
        "method_before": "    protected String getSubstitution(FormEntrySession session, FormSubmissionController controllerActions, Map<String, String> parameters) {\n        String expression = parameters.get(\"expression\");\n        String className = parameters.get(\"class\");\n        String complexExpression = parameters.get(\"complexExpression\");\n        if (expression != null && complexExpression != null)\n            throw new RuntimeException(\"Cannot specify both expression and complexExpression\");\n        if (expression == null && complexExpression == null)\n            throw new RuntimeException(\"Must specify expression or complexExpression for velocity\");\n        String value;\n        if (expression != null)\n            value = session.evaluateVelocityExpression(\"$!{\" + expression + \"}\");\n        else\n            value = session.evaluateVelocityExpression(complexExpression);\n        \n        // Enable date formatting \n    \tDateFormat fromFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss z yyyy\");\n    \tDateFormat fromFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n    \tDate d = null;\n    \ttry {\n        \td = fromFormat.parse(value);\n    \t}\n        catch (Exception e) {\n        \ttry {\n        \t\td = fromFormat2.parse(value);\n        \t}\n            catch (Exception e2) {\n            \t// Do nothing\n            }\n        }\n        if (d != null) {\n        \tString newFormat = parameters.get(\"format\");\n        \tDateFormat toFormat = new SimpleDateFormat(newFormat == null ? \"dd/MMM/yyyy\" : newFormat, Context.getLocale());\n        \tvalue = toFormat.format(d);\n        }\n        \n        // Enable translation via existing message sources\n        String codePrefix = parameters.get(\"codePrefix\");\n        if (codePrefix != null) {\n        \tString lookupCode = codePrefix + value;\n        \tString translatedValue = session.getContext().getTranslator().translate(Context.getLocale().toString(), lookupCode);\n        \tif (StringUtils.hasText(translatedValue) && !translatedValue.equals(lookupCode)) {\n        \t\tvalue = translatedValue;\n        \t}\n        }\n        \n        value = StringEscapeUtils.escapeHtml(value);\n        \n        if (className != null) {\n            return \"<span class=\\\"\" + className + \"\\\">\" + value + \"</span>\";\n        } else {\n            return value;\n        }\n    }",
        "method_after": "    protected String getSubstitution(FormEntrySession session, FormSubmissionController controllerActions, Map<String, String> parameters) {\n        String expression = parameters.get(\"expression\");\n        String className = parameters.get(\"class\");\n        String complexExpression = parameters.get(\"complexExpression\");\n        if (expression != null && complexExpression != null)\n            throw new RuntimeException(\"Cannot specify both expression and complexExpression\");\n        if (expression == null && complexExpression == null)\n            throw new RuntimeException(\"Must specify expression or complexExpression for velocity\");\n        String value;\n        if (expression != null)\n            value = session.evaluateVelocityExpression(\"$!{\" + expression + \"}\");\n        else\n            value = session.evaluateVelocityExpression(complexExpression);\n        \n        // Enable date formatting \n    \tDateFormat fromFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss z yyyy\");\n    \tDateFormat fromFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n    \tDate d = null;\n    \ttry {\n        \td = fromFormat.parse(value);\n    \t}\n        catch (Exception e) {\n        \ttry {\n        \t\td = fromFormat2.parse(value);\n        \t}\n            catch (Exception e2) {\n            \t// Do nothing\n            }\n        }\n        if (d != null) {\n        \tString newFormat = parameters.get(\"format\");\n        \tDateFormat toFormat = new SimpleDateFormat(newFormat == null ? \"dd/MMM/yyyy\" : newFormat, Context.getLocale());\n        \tvalue = toFormat.format(d);\n        }\n        \n        // Enable translation via existing message sources\n        String codePrefix = parameters.get(\"codePrefix\");\n        if (codePrefix != null) {\n        \tString lookupCode = codePrefix + value;\n        \tString translatedValue = session.getContext().getTranslator().translate(Context.getLocale().toString(), lookupCode);\n        \tif (StringUtils.hasText(translatedValue) && !translatedValue.equals(lookupCode)) {\n        \t\tvalue = translatedValue;\n        \t}\n        }\n        \n        if (className != null) {\n            return \"<span class=\\\"\" + className + \"\\\">\" + value + \"</span>\";\n        } else {\n            return value;\n        }\n    }"
    },
    {
        "idx": "1639",
        "vuln_id": "unknown-126",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "ea8912b2ce46a372fa94e34a657eba21bd8c57b8",
        "method_before": "    public static String format(OpenmrsMetadata md, Locale locale) {\n        String override = getLocalization(locale, md.getClass().getSimpleName(), md.getUuid());\n        return override != null ? override : md.getName();\n    }",
        "method_after": "    public static String format(OpenmrsMetadata md, Locale locale) {\n        String override = getLocalization(locale, md.getClass().getSimpleName(), md.getUuid());\n        return override != null ? override : StringEscapeUtils.escapeHtml(md.getName());\n    }"
    },
    {
        "idx": "1644",
        "vuln_id": "unknown-130",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/micromata/projectforge-webapp",
        "commit": "fb4f4d286ba15cd053089dfbc5f7d8facb5f4674",
        "method_before": "  public void onRendered(Component component)\n  {\n    if (component instanceof FormComponent<?> == false) {\n      return;\n    }\n    FormComponent< ? > fc = (FormComponent< ? >) component;\n    if (fc.isValid() == false) {\n      String error;\n      if (fc.hasFeedbackMessage() == true) {\n        error = fc.getFeedbackMessage().getMessage().toString();\n      } else {\n        error = \"Your input is invalid.\";\n      }\n      fc.getResponse().write(\"<div class=\\\"validationMsg\\\">\" + error + \"</div>\");\n    }\n  }",
        "method_after": "  public void onRendered(Component component)\n  {\n    if (component instanceof FormComponent<?> == false) {\n      return;\n    }\n    FormComponent< ? > fc = (FormComponent< ? >) component;\n    if (fc.isValid() == false) {\n      String error;\n      if (fc.hasFeedbackMessage() == true) {\n        error = fc.getFeedbackMessage().getMessage().toString();\n      } else {\n        error = \"Your input is invalid.\";\n      }\n      fc.getResponse().write(\"<div class=\\\"validationMsg\\\">\" + HtmlHelper.escapeXml(error) + \"</div>\");\n    }\n  }"
    },
    {
        "idx": "1657",
        "vuln_id": "unknown-142",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "25149f5094de966006c3a31ec7712b8fadb66bfe",
        "method_before": "    protected String getSubstitution(FormEntrySession session, FormSubmissionController controllerActions, Map<String, String> parameters) {\n        String expression = parameters.get(\"expression\");\n        String className = parameters.get(\"class\");\n        String complexExpression = parameters.get(\"complexExpression\");\n        if (expression != null && complexExpression != null)\n            throw new RuntimeException(\"Cannot specify both expression and complexExpression\");\n        if (expression == null && complexExpression == null)\n            throw new RuntimeException(\"Must specify expression or complexExpression for velocity\");\n        String value;\n        if (expression != null)\n            value = session.evaluateVelocityExpression(\"$!{\" + expression + \"}\");\n        else\n            value = session.evaluateVelocityExpression(complexExpression);\n        \n        // Enable date formatting \n    \tDateFormat fromFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss z yyyy\");\n    \tDateFormat fromFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n    \tDate d = null;\n    \ttry {\n        \td = fromFormat.parse(value);\n    \t}\n        catch (Exception e) {\n        \ttry {\n        \t\td = fromFormat2.parse(value);\n        \t}\n            catch (Exception e2) {\n            \t// Do nothing\n            }\n        }\n        if (d != null) {\n        \tString newFormat = parameters.get(\"format\");\n        \tDateFormat toFormat = new SimpleDateFormat(newFormat == null ? \"dd/MMM/yyyy\" : newFormat, Context.getLocale());\n        \tvalue = toFormat.format(d);\n        }\n        \n        // Enable translation via existing message sources\n        String codePrefix = parameters.get(\"codePrefix\");\n        if (codePrefix != null) {\n        \tString lookupCode = codePrefix + value;\n        \tString translatedValue = session.getContext().getTranslator().translate(Context.getLocale().toString(), lookupCode);\n        \tif (StringUtils.hasText(translatedValue) && !translatedValue.equals(lookupCode)) {\n        \t\tvalue = translatedValue;\n        \t}\n        }\n        \n        if (className != null) {\n            return \"<span class=\\\"\" + className + \"\\\">\" + value + \"</span>\";\n        } else {\n            return value;\n        }\n    }",
        "method_after": "    protected String getSubstitution(FormEntrySession session, FormSubmissionController controllerActions, Map<String, String> parameters) {\n        String expression = parameters.get(\"expression\");\n        String className = parameters.get(\"class\");\n        String complexExpression = parameters.get(\"complexExpression\");\n        if (expression != null && complexExpression != null)\n            throw new RuntimeException(\"Cannot specify both expression and complexExpression\");\n        if (expression == null && complexExpression == null)\n            throw new RuntimeException(\"Must specify expression or complexExpression for velocity\");\n        String value;\n        if (expression != null)\n            value = session.evaluateVelocityExpression(\"$!{\" + expression + \"}\");\n        else\n            value = session.evaluateVelocityExpression(complexExpression);\n        \n        // Enable date formatting \n    \tDateFormat fromFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss z yyyy\");\n    \tDateFormat fromFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n    \tDate d = null;\n    \ttry {\n        \td = fromFormat.parse(value);\n    \t}\n        catch (Exception e) {\n        \ttry {\n        \t\td = fromFormat2.parse(value);\n        \t}\n            catch (Exception e2) {\n            \t// Do nothing\n            }\n        }\n        if (d != null) {\n        \tString newFormat = parameters.get(\"format\");\n        \tDateFormat toFormat = new SimpleDateFormat(newFormat == null ? \"dd/MMM/yyyy\" : newFormat, Context.getLocale());\n        \tvalue = toFormat.format(d);\n        }\n        \n        // Enable translation via existing message sources\n        String codePrefix = parameters.get(\"codePrefix\");\n        if (codePrefix != null) {\n        \tString lookupCode = codePrefix + value;\n        \tString translatedValue = session.getContext().getTranslator().translate(Context.getLocale().toString(), lookupCode);\n        \tif (StringUtils.hasText(translatedValue) && !translatedValue.equals(lookupCode)) {\n        \t\tvalue = translatedValue;\n        \t}\n        }\n        \n        if (className != null) {\n            return \"<span class=\\\"\" + className + \"\\\">\" + StringEscapeUtils.escapeHtml(value) + \"</span>\";\n        } else {\n            return value;\n        }\n    }"
    },
    {
        "idx": "1682",
        "vuln_id": "unknown-165",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/pgjdbc/pgjdbc",
        "commit": "5e0641509ae1fe13f89e5a8e757c4ef789948de0",
        "method_before": "    public String toString(int index) {\n        --index;\n        if (paramValues[index] == null)\n            return \"?\";\n        else if (paramValues[index] == NULL_OBJECT)\n            return \"NULL\";\n        else {\n            String param = paramValues[index].toString();\n            boolean hasBackslash = param.indexOf('\\\\') != -1;\n\n            // add room for quotes + potential escaping.\n            StringBuffer p = new StringBuffer(3 + param.length() * 11 / 10);\n\n            boolean standardConformingStrings = false;\n            boolean supportsEStringSyntax = false;\n            if (protoConnection != null) {\n                standardConformingStrings = protoConnection.getStandardConformingStrings();\n                supportsEStringSyntax = protoConnection.getServerVersion().compareTo(\"8.1\") >= 0;\n            }\n\n            if (hasBackslash && !standardConformingStrings && supportsEStringSyntax)\n                p.append('E');\n\n            p.append('\\'');\n            try {\n                p = Utils.appendEscapedLiteral(p, param, protoConnection.getStandardConformingStrings());\n            } catch (SQLException sqle) {\n                // This should only happen if we have an embedded null\n                // and there's not much we can do if we do hit one.\n                //\n                // The goal of toString isn't to be sent to the server,\n                // so we aren't 100% accurate (see StreamWrapper), put\n                // the unescaped version of the data.\n                //\n                p.append(param);\n            }\n            p.append('\\'');\n            return p.toString();\n        }\n    }",
        "method_after": "    public String toString(int index) {\n        --index;\n        if (paramValues[index] == null)\n            return \"?\";\n        else if (paramValues[index] == NULL_OBJECT)\n            return \"NULL\";\n        else {\n            String param = paramValues[index].toString();\n            boolean hasBackslash = param.indexOf('\\\\') != -1;\n\n            // add room for quotes + potential escaping.\n            StringBuffer p = new StringBuffer(3 + param.length() * 11 / 10);\n\n            boolean standardConformingStrings = false;\n            boolean supportsEStringSyntax = false;\n            if (protoConnection != null) {\n                standardConformingStrings = protoConnection.getStandardConformingStrings();\n                supportsEStringSyntax = protoConnection.getServerVersion().compareTo(\"8.1\") >= 0;\n            }\n\n            if (hasBackslash && !standardConformingStrings && supportsEStringSyntax)\n                p.append('E');\n\n            p.append('\\'');\n            try {\n                p = Utils.appendEscapedLiteral(p, param, standardConformingStrings);\n            } catch (SQLException sqle) {\n                // This should only happen if we have an embedded null\n                // and there's not much we can do if we do hit one.\n                //\n                // The goal of toString isn't to be sent to the server,\n                // so we aren't 100% accurate (see StreamWrapper), put\n                // the unescaped version of the data.\n                //\n                p.append(param);\n            }\n            p.append('\\'');\n            return p.toString();\n        }\n    }"
    },
    {
        "idx": "1686",
        "vuln_id": "unknown-169",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/javamelody/javamelody",
        "commit": "69b3ed26dde78e0c693fcdedfef0ef57b191e520",
        "method_before": "\tstatic String javascriptEncode(String text) {\n\t\treturn text.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\").replace(\"\\\"\", \"\\\\\\\"\")\n\t\t\t\t.replace(\"'\", \"\\\\'\");\n\t}",
        "method_after": "\tstatic String javascriptEncode(String text) {\n\t\treturn text.replace(\"\\\\\", \"\\\\\\\\\").replace(\"\\n\", \"\\\\n\").replace(\"\\\"\", \"%22\")\n\t\t\t\t.replace(\"'\", \"%27\");\n\t}"
    },
    {
        "idx": "1705",
        "vuln_id": "unknown-186",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/skywalking",
        "commit": "5b84c5ad1873c568c36dc74f34245ed0dd701352",
        "method_before": "    private void updateConfig(final Reader contentRender) {\n        dictionary = (Map<String, Integer>) new Yaml().load(contentRender);\n        if (dictionary == null) {\n            dictionary = Collections.emptyMap();\n        }\n    }",
        "method_after": "    private void updateConfig(final Reader contentRender) {\n        dictionary = (Map<String, Integer>) new Yaml(new SafeConstructor()).load(contentRender);\n        if (dictionary == null) {\n            dictionary = Collections.emptyMap();\n        }\n    }"
    },
    {
        "idx": "1722",
        "vuln_id": "unknown-200",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/AdoptOpenJDK/IcedTea-Web",
        "commit": "684caa381ca6ac6fcfce9bd389953e3f12b56a45",
        "method_before": "    public void checkPermission(Permission perm) {\n        String name = perm.getName();\n\n        // Enable this manually -- it'll produce too much output for -verbose\n        // otherwise.\n        //      if (true)\n        //        System.out.println(\"Checking permission: \" + perm.toString());\n\n        if (!JNLPRuntime.isWebstartApplication() &&\n                (\"setPolicy\".equals(name) || \"setSecurityManager\".equals(name)))\n            throw new SecurityException(R(\"RCantReplaceSM\"));\n\n        try {\n            // deny all permissions to stopped applications\n            // The call to getApplication() below might not work if an\n            // application hasn't been fully initialized yet.\n            //            if (JNLPRuntime.isDebug()) {\n            //                if (!\"getClassLoader\".equals(name)) {\n            //                    ApplicationInstance app = getApplication();\n            //                    if (app != null && !app.isRunning())\n            //                        throw new SecurityException(R(\"RDenyStopped\"));\n            //                }\n            //            }\n\n            try {\n                super.checkPermission(perm);\n            } catch (SecurityException se) {\n\n                //This section is a special case for dealing with SocketPermissions.\n                if (JNLPRuntime.isDebug())\n                    System.err.println(\"Requesting permission: \" + perm.toString());\n\n                //Change this SocketPermission's action to connect and accept\n                //(and resolve). This is to avoid asking for connect permission\n                //on every address resolve.\n                Permission tmpPerm = null;\n                if (perm instanceof SocketPermission) {\n                    tmpPerm = new SocketPermission(perm.getName(),\n                                                        SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION);\n\n                    // before proceeding, check if we are trying to connect to same origin\n                    ApplicationInstance app = getApplication();\n                    JNLPFile file = app.getJNLPFile();\n\n                    String srcHost = file.getSourceLocation().getAuthority();\n                    String destHost = name;\n\n                    // host = abc.xyz.com or abc.xyz.com:<port>\n                    if (destHost.indexOf(':') >= 0)\n                        destHost = destHost.substring(0, destHost.indexOf(':'));\n\n                    // host = abc.xyz.com\n                    String[] hostComponents = destHost.split(\"\\\\.\");\n\n                    int length = hostComponents.length;\n                    if (length >= 2) {\n\n                        // address is in xxx.xxx.xxx format\n                        destHost = hostComponents[length - 2] + \".\" + hostComponents[length - 1];\n\n                        // host = xyz.com i.e. origin\n                        boolean isDestHostName = false;\n\n                        // make sure that it is not an ip address\n                        try {\n                            Integer.parseInt(hostComponents[length - 1]);\n                        } catch (NumberFormatException e) {\n                            isDestHostName = true;\n                        }\n\n                        if (isDestHostName) {\n                            // okay, destination is hostname. Now figure out if it is a subset of origin\n                            if (srcHost.endsWith(destHost)) {\n                                addPermission(tmpPerm);\n                                return;\n                            }\n                        }\n                    }\n\n                } else if (perm instanceof SecurityPermission) {\n\n                    // JCE's initialization requires putProviderProperty permission\n                    if (perm.equals(new SecurityPermission(\"putProviderProperty.SunJCE\"))) {\n                        if (inTrustedCallChain(\"com.sun.crypto.provider.SunJCE\", \"run\")) {\n                            return;\n                        }\n                    }\n\n                } else if (perm instanceof RuntimePermission) {\n\n                    // KeyGenerator's init method requires internal spec access\n                    if (perm.equals(new SecurityPermission(\"accessClassInPackage.sun.security.internal.spec\"))) {\n                        if (inTrustedCallChain(\"javax.crypto.KeyGenerator\", \"init\")) {\n                            return;\n                        }\n                    }\n\n                } else {\n                    tmpPerm = perm;\n                }\n\n                if (tmpPerm != null) {\n                    //askPermission will only prompt the user on SocketPermission\n                    //meaning we're denying all other SecurityExceptions that may arise.\n                    if (askPermission(tmpPerm)) {\n                        addPermission(tmpPerm);\n                        //return quietly.\n                    } else {\n                        throw se;\n                    }\n                }\n            }\n        } catch (SecurityException ex) {\n            if (JNLPRuntime.isDebug()) {\n                System.out.println(\"Denying permission: \" + perm);\n            }\n            throw ex;\n        }\n    }",
        "method_after": "    public void checkPermission(Permission perm) {\n        String name = perm.getName();\n\n        // Enable this manually -- it'll produce too much output for -verbose\n        // otherwise.\n        //      if (true)\n        //        System.out.println(\"Checking permission: \" + perm.toString());\n\n        if (!JNLPRuntime.isWebstartApplication() &&\n                (\"setPolicy\".equals(name) || \"setSecurityManager\".equals(name)))\n            throw new SecurityException(R(\"RCantReplaceSM\"));\n\n        try {\n            // deny all permissions to stopped applications\n            // The call to getApplication() below might not work if an\n            // application hasn't been fully initialized yet.\n            //            if (JNLPRuntime.isDebug()) {\n            //                if (!\"getClassLoader\".equals(name)) {\n            //                    ApplicationInstance app = getApplication();\n            //                    if (app != null && !app.isRunning())\n            //                        throw new SecurityException(R(\"RDenyStopped\"));\n            //                }\n            //            }\n\n            try {\n                super.checkPermission(perm);\n            } catch (SecurityException se) {\n\n                //This section is a special case for dealing with SocketPermissions.\n                if (JNLPRuntime.isDebug())\n                    System.err.println(\"Requesting permission: \" + perm.toString());\n\n                //Change this SocketPermission's action to connect and accept\n                //(and resolve). This is to avoid asking for connect permission\n                //on every address resolve.\n                Permission tmpPerm = null;\n                if (perm instanceof SocketPermission) {\n                    tmpPerm = new SocketPermission(perm.getName(),\n                                                        SecurityConstants.SOCKET_CONNECT_ACCEPT_ACTION);\n\n                    // before proceeding, check if we are trying to connect to same origin\n                    ApplicationInstance app = getApplication();\n                    JNLPFile file = app.getJNLPFile();\n\n                    String srcHost = file.getSourceLocation().getAuthority();\n                    String destHost = name;\n\n                    // host = abc.xyz.com or abc.xyz.com:<port>\n                    if (destHost.indexOf(':') >= 0)\n                        destHost = destHost.substring(0, destHost.indexOf(':'));\n\n                    // host = abc.xyz.com\n                    String[] hostComponents = destHost.split(\"\\\\.\");\n\n                    int length = hostComponents.length;\n                    if (length >= 2) {\n\n                        // address is in xxx.xxx.xxx format\n                        destHost = hostComponents[length - 2] + \".\" + hostComponents[length - 1];\n\n                        // host = xyz.com i.e. origin\n                        boolean isDestHostName = false;\n\n                        // make sure that it is not an ip address\n                        try {\n                            Integer.parseInt(hostComponents[length - 1]);\n                        } catch (NumberFormatException e) {\n                            isDestHostName = true;\n                        }\n\n                        if (isDestHostName) {\n                            // okay, destination is hostname. Now figure out if it is a subset of origin\n                            if (srcHost.endsWith(destHost)) {\n                                addPermission(tmpPerm);\n                                return;\n                            }\n                        }\n                    }\n\n                } else if (perm instanceof SecurityPermission) {\n                    tmpPerm = perm;\n\n                    // JCE's initialization requires putProviderProperty permission\n                    if (perm.equals(new SecurityPermission(\"putProviderProperty.SunJCE\"))) {\n                        if (inTrustedCallChain(\"com.sun.crypto.provider.SunJCE\", \"run\")) {\n                            return;\n                        }\n                    }\n\n                } else if (perm instanceof RuntimePermission) {\n                    tmpPerm = perm;\n\n                    // KeyGenerator's init method requires internal spec access\n                    if (perm.equals(new SecurityPermission(\"accessClassInPackage.sun.security.internal.spec\"))) {\n                        if (inTrustedCallChain(\"javax.crypto.KeyGenerator\", \"init\")) {\n                            return;\n                        }\n                    }\n\n                } else {\n                    tmpPerm = perm;\n                }\n\n                if (tmpPerm != null) {\n                    //askPermission will only prompt the user on SocketPermission\n                    //meaning we're denying all other SecurityExceptions that may arise.\n                    if (askPermission(tmpPerm)) {\n                        addPermission(tmpPerm);\n                        //return quietly.\n                    } else {\n                        throw se;\n                    }\n                }\n            }\n        } catch (SecurityException ex) {\n            if (JNLPRuntime.isDebug()) {\n                System.out.println(\"Denying permission: \" + perm);\n            }\n            throw ex;\n        }\n    }"
    },
    {
        "idx": "1737",
        "vuln_id": "unknown-214",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "6982cfed93255c72031cec4d2567b8b8558be9c5",
        "method_before": "    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParentClassLoader().loadClass(getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }",
        "method_after": "    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParent().getLoader().getClassLoader().loadClass(\n                        getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }"
    },
    {
        "idx": "1752",
        "vuln_id": "unknown-228",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/directory-ldap-api",
        "commit": "2662e1394ef4896de70c0c0aa4fbb5ee631b737f"
    },
    {
        "idx": "1761",
        "vuln_id": "unknown-236",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat",
        "commit": "e4b1187df3cc7a881d76e75920149380cf437a74",
        "method_before": "    public URL[] getURLs() {\n\n        if (repositoryURLs != null) {\n            return repositoryURLs;\n        }\n\n        URL[] external = super.getURLs();\n\n        int filesLength = files.length;\n        int jarFilesLength = jarRealFiles.length;\n        int externalsLength = external.length;\n        int off = 0;\n        int i;\n\n        try {\n\n            URL[] urls = new URL[filesLength + jarFilesLength + externalsLength];\n            if (searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[i] = external[i];\n                }\n                off = externalsLength;\n            }\n            for (i = 0; i < filesLength; i++) {\n                urls[off + i] = getURL(files[i], true);\n            }\n            off += filesLength;\n            for (i = 0; i < jarFilesLength; i++) {\n                urls[off + i] = getURL(jarRealFiles[i], true);\n            }\n            off += jarFilesLength;\n            if (!searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[off + i] = external[i];\n                }\n            }\n\n            repositoryURLs = urls;\n\n        } catch (MalformedURLException e) {\n            repositoryURLs = new URL[0];\n        }\n\n        return repositoryURLs;\n\n    }",
        "method_after": "    public URL[] getURLs() {\n\n        if (repositoryURLs != null) {\n            return repositoryURLs.clone();\n        }\n\n        URL[] external = super.getURLs();\n\n        int filesLength = files.length;\n        int jarFilesLength = jarRealFiles.length;\n        int externalsLength = external.length;\n        int off = 0;\n        int i;\n\n        try {\n\n            URL[] urls = new URL[filesLength + jarFilesLength + externalsLength];\n            if (searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[i] = external[i];\n                }\n                off = externalsLength;\n            }\n            for (i = 0; i < filesLength; i++) {\n                urls[off + i] = getURL(files[i], true);\n            }\n            off += filesLength;\n            for (i = 0; i < jarFilesLength; i++) {\n                urls[off + i] = getURL(jarRealFiles[i], true);\n            }\n            off += jarFilesLength;\n            if (!searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[off + i] = external[i];\n                }\n            }\n\n            repositoryURLs = urls;\n\n        } catch (MalformedURLException e) {\n            repositoryURLs = new URL[0];\n        }\n\n        return repositoryURLs.clone();\n\n    }"
    },
    {
        "idx": "1789",
        "vuln_id": "unknown-261",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/kafka",
        "commit": "40432e31f7c5b0e0992a51621dc8b1c0e3d3103f"
    },
    {
        "idx": "1792",
        "vuln_id": "unknown-264",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/cordova-android",
        "commit": "dfae37421d345031b41be1a4cbc9a3374d94ca16",
        "method_before": "    private void exposeJsInterface() {\n        int SDK_INT = Build.VERSION.SDK_INT;\n        boolean isHoneycomb = (SDK_INT >= Build.VERSION_CODES.HONEYCOMB && SDK_INT <= Build.VERSION_CODES.HONEYCOMB_MR2);\n        if (isHoneycomb || (SDK_INT < Build.VERSION_CODES.GINGERBREAD)) {\n            Log.i(TAG, \"Disabled addJavascriptInterface() bridge since Android version is old.\");\n            // Bug being that Java Strings do not get converted to JS strings automatically.\n            // This isn't hard to work-around on the JS side, but it's easier to just\n            // use the prompt bridge instead.\n            return;            \n        } else if (SDK_INT < Build.VERSION_CODES.HONEYCOMB && Build.MANUFACTURER.equals(\"unknown\")) {\n            // addJavascriptInterface crashes on the 2.3 emulator.\n            Log.i(TAG, \"Disabled addJavascriptInterface() bridge callback due to a bug on the 2.3 emulator\");\n            return;\n        }\n        this.addJavascriptInterface(exposedJsApi, \"_cordovaNative\");\n    }",
        "method_after": "    private void exposeJsInterface() {\n        int SDK_INT = Build.VERSION.SDK_INT;\n        if ((SDK_INT < Build.VERSION_CODES.JELLY_BEAN_MR1)) {\n            Log.i(TAG, \"Disabled addJavascriptInterface() bridge since Android version is old.\");\n            // Bug being that Java Strings do not get converted to JS strings automatically.\n            // This isn't hard to work-around on the JS side, but it's easier to just\n            // use the prompt bridge instead.\n            return;            \n        } \n        this.addJavascriptInterface(exposedJsApi, \"_cordovaNative\");\n    }"
    },
    {
        "idx": "1817",
        "vuln_id": "unknown-44",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/igniterealtime/Openfire",
        "commit": "9f29a35c4ff46ca7af2a97ec1242c480d2c513ff"
    },
    {
        "idx": "1871",
        "vuln_id": "unknown-93",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/vt-middleware/cryptacular",
        "commit": "03c282de7ca9fb3c678c736b6274954d3786fd17",
        "method_before": "  public BlockCipher newInstance()\n  {\n    BlockCipher cipher;\n    if (\"AES\".equalsIgnoreCase(algorithm)) {\n      cipher = new AESFastEngine();\n    } else if (\"Blowfish\".equalsIgnoreCase(algorithm)) {\n      cipher = new BlowfishEngine();\n    } else if (\"Camellia\".equalsIgnoreCase(algorithm)) {\n      cipher = new CamelliaEngine();\n    } else if (\"CAST5\".equalsIgnoreCase(algorithm)) {\n      cipher = new CAST5Engine();\n    } else if (\"CAST6\".equalsIgnoreCase(algorithm)) {\n      cipher = new CAST6Engine();\n    } else if (\"DES\".equalsIgnoreCase(algorithm)) {\n      cipher = new DESEngine();\n    } else if (\"DESede\".equalsIgnoreCase(algorithm) || \"DES3\".equalsIgnoreCase(algorithm)) {\n      cipher = new DESedeEngine();\n    } else if (\"GOST\".equalsIgnoreCase(algorithm) || \"GOST28147\".equals(algorithm)) {\n      cipher = new GOST28147Engine();\n    } else if (\"Noekeon\".equalsIgnoreCase(algorithm)) {\n      cipher = new NoekeonEngine();\n    } else if (\"RC2\".equalsIgnoreCase(algorithm)) {\n      cipher = new RC2Engine();\n    } else if (\"RC5\".equalsIgnoreCase(algorithm)) {\n      cipher = new RC564Engine();\n    } else if (\"RC6\".equalsIgnoreCase(algorithm)) {\n      cipher = new RC6Engine();\n    } else if (\"SEED\".equalsIgnoreCase(algorithm)) {\n      cipher = new SEEDEngine();\n    } else if (\"Serpent\".equalsIgnoreCase(algorithm)) {\n      cipher = new SerpentEngine();\n    } else if (\"Skipjack\".equalsIgnoreCase(algorithm)) {\n      cipher = new SkipjackEngine();\n    } else if (\"TEA\".equalsIgnoreCase(algorithm)) {\n      cipher = new TEAEngine();\n    } else if (\"Twofish\".equalsIgnoreCase(algorithm)) {\n      cipher = new TwofishEngine();\n    } else if (\"XTEA\".equalsIgnoreCase(algorithm)) {\n      cipher = new XTEAEngine();\n    } else {\n      throw new IllegalStateException(\"Unsupported cipher algorithm \" + algorithm);\n    }\n    return cipher;\n  }",
        "method_after": "  public BlockCipher newInstance()\n  {\n    BlockCipher cipher;\n    if (\"AES\".equalsIgnoreCase(algorithm)) {\n      cipher = new AESEngine();\n    } else if (\"Blowfish\".equalsIgnoreCase(algorithm)) {\n      cipher = new BlowfishEngine();\n    } else if (\"Camellia\".equalsIgnoreCase(algorithm)) {\n      cipher = new CamelliaEngine();\n    } else if (\"CAST5\".equalsIgnoreCase(algorithm)) {\n      cipher = new CAST5Engine();\n    } else if (\"CAST6\".equalsIgnoreCase(algorithm)) {\n      cipher = new CAST6Engine();\n    } else if (\"DES\".equalsIgnoreCase(algorithm)) {\n      cipher = new DESEngine();\n    } else if (\"DESede\".equalsIgnoreCase(algorithm) || \"DES3\".equalsIgnoreCase(algorithm)) {\n      cipher = new DESedeEngine();\n    } else if (\"GOST\".equalsIgnoreCase(algorithm) || \"GOST28147\".equals(algorithm)) {\n      cipher = new GOST28147Engine();\n    } else if (\"Noekeon\".equalsIgnoreCase(algorithm)) {\n      cipher = new NoekeonEngine();\n    } else if (\"RC2\".equalsIgnoreCase(algorithm)) {\n      cipher = new RC2Engine();\n    } else if (\"RC5\".equalsIgnoreCase(algorithm)) {\n      cipher = new RC564Engine();\n    } else if (\"RC6\".equalsIgnoreCase(algorithm)) {\n      cipher = new RC6Engine();\n    } else if (\"SEED\".equalsIgnoreCase(algorithm)) {\n      cipher = new SEEDEngine();\n    } else if (\"Serpent\".equalsIgnoreCase(algorithm)) {\n      cipher = new SerpentEngine();\n    } else if (\"Skipjack\".equalsIgnoreCase(algorithm)) {\n      cipher = new SkipjackEngine();\n    } else if (\"TEA\".equalsIgnoreCase(algorithm)) {\n      cipher = new TEAEngine();\n    } else if (\"Twofish\".equalsIgnoreCase(algorithm)) {\n      cipher = new TwofishEngine();\n    } else if (\"XTEA\".equalsIgnoreCase(algorithm)) {\n      cipher = new XTEAEngine();\n    } else {\n      throw new IllegalStateException(\"Unsupported cipher algorithm \" + algorithm);\n    }\n    return cipher;\n  }"
    },
    {
        "idx": "1874",
        "vuln_id": "unknown-96",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "82da759b16ddb0f4bce3347344f25e046da33cc7",
        "method_before": "    public URL[] getURLs() {\n\n        if (repositoryURLs != null) {\n            return repositoryURLs;\n        }\n\n        URL[] external = super.getURLs();\n\n        int filesLength = files.length;\n        int jarFilesLength = jarRealFiles.length;\n        int externalsLength = external.length;\n        int off = 0;\n        int i;\n\n        try {\n\n            URL[] urls = new URL[filesLength + jarFilesLength + externalsLength];\n            if (searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[i] = external[i];\n                }\n                off = externalsLength;\n            }\n            for (i = 0; i < filesLength; i++) {\n                urls[off + i] = getURL(files[i], true);\n            }\n            off += filesLength;\n            for (i = 0; i < jarFilesLength; i++) {\n                urls[off + i] = getURL(jarRealFiles[i], true);\n            }\n            off += jarFilesLength;\n            if (!searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[off + i] = external[i];\n                }\n            }\n\n            repositoryURLs = urls;\n\n        } catch (MalformedURLException e) {\n            repositoryURLs = new URL[0];\n        }\n\n        return repositoryURLs;\n\n    }",
        "method_after": "    public URL[] getURLs() {\n\n        if (repositoryURLs != null) {\n            return repositoryURLs.clone();\n        }\n\n        URL[] external = super.getURLs();\n\n        int filesLength = files.length;\n        int jarFilesLength = jarRealFiles.length;\n        int externalsLength = external.length;\n        int off = 0;\n        int i;\n\n        try {\n\n            URL[] urls = new URL[filesLength + jarFilesLength + externalsLength];\n            if (searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[i] = external[i];\n                }\n                off = externalsLength;\n            }\n            for (i = 0; i < filesLength; i++) {\n                urls[off + i] = getURL(files[i], true);\n            }\n            off += filesLength;\n            for (i = 0; i < jarFilesLength; i++) {\n                urls[off + i] = getURL(jarRealFiles[i], true);\n            }\n            off += jarFilesLength;\n            if (!searchExternalFirst) {\n                for (i = 0; i < externalsLength; i++) {\n                    urls[off + i] = external[i];\n                }\n            }\n\n            repositoryURLs = urls;\n\n        } catch (MalformedURLException e) {\n            repositoryURLs = new URL[0];\n        }\n\n        return repositoryURLs.clone();\n\n    }"
    },
    {
        "idx": "495",
        "vuln_id": "CVE-2016-6802",
        "desc": "Apache Shiro before 1.3.2 allows attackers to bypass intended servlet filters and gain access by leveraging use of a non-root servlet context path.",
        "cwe_id": "CWE-284",
        "cwe_name": "Improper Access Control",
        "repo": "https://github.com/apache/shiro",
        "commit": "b15ab927709ca18ea4a02538be01919a19ab65af"
    },
    {
        "idx": "533",
        "vuln_id": "CVE-2017-1000207",
        "desc": "A vulnerability in Swagger-Parser's version <= 1.0.30 and Swagger codegen version <= 2.2.2 yaml parsing functionality results in arbitrary code being executed when a maliciously crafted yaml Open-API specification is parsed. This in particular, affects the 'generate' and 'validate' command in swagger-codegen (<= 2.2.2) and can lead to arbitrary code being executed when these commands are used on a well-crafted yaml specification.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/swagger-api/swagger-parser",
        "commit": "4c6584306b40de9b2dfa9065c3a438cd918534af"
    },
    {
        "idx": "534",
        "vuln_id": "CVE-2017-1000208",
        "desc": "A vulnerability in Swagger-Parser's (version <= 1.0.30) yaml parsing functionality results in arbitrary code being executed when a maliciously crafted yaml Open-API specification is parsed. This in particular, affects the 'generate' and 'validate' command in swagger-codegen (<= 2.2.2) and can lead to arbitrary code being executed when these commands are used on a well-crafted yaml specification.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/swagger-api/swagger-parser",
        "commit": "4c6584306b40de9b2dfa9065c3a438cd918534af"
    },
    {
        "idx": "538",
        "vuln_id": "CVE-2017-1000355",
        "desc": "Jenkins versions 2.56 and earlier as well as 2.46.1 LTS and earlier are vulnerable to an XStream: Java crash when trying to instantiate void/Void.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "701ea95a52afe53bee28f76a3f96eb0e578852e9",
        "method_before": "    private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }",
        "method_after": "    private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        // http://www.openwall.com/lists/oss-security/2017/04/03/4\n        denyTypes(new Class[] { void.class, Void.class });\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }"
    },
    {
        "idx": "595",
        "vuln_id": "CVE-2017-13309",
        "desc": "[]",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/google/conscrypt",
        "commit": "e56958e7dea05c1784317f139e2216e2e707d391"
    },
    {
        "idx": "679",
        "vuln_id": "CVE-2017-7545",
        "desc": "It was discovered that the XmlUtils class in jbpmmigration 6.5 performed expansion of external parameter entities while parsing XML files. A remote attacker could use this flaw to read files accessible to the user running the application server and, potentially, perform other more advanced XML eXternal Entity (XXE) attacks.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/kiegroup/jbpm-designer",
        "commit": "a143f3b92a6a5a527d929d68c02a0c5d914ab81d"
    },
    {
        "idx": "716",
        "vuln_id": "CVE-2018-1000054",
        "desc": "Jenkins CCM Plugin 3.1 and earlier processes XML external entities in files it parses as part of the build process, allowing attackers with user permissions in Jenkins to extract secrets from the Jenkins master, perform server-side request forgery, or denial-of-service attacks.",
        "cwe_id": "CWE-918",
        "cwe_name": "Server-Side Request Forgery (SSRF)",
        "repo": "https://github.com/jenkinsci/ccm-plugin",
        "commit": "066cb43b4413b3490d822ec8b8a32072ebd213ca",
        "method_before": "\tprivate Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tDigester digester = new Digester();\n\t\tdigester.setValidating(false);\n\t\tdigester.setClassLoader(CcmParser.class.getClassLoader());\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}",
        "method_after": "\tprivate Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tSecureDigester digester = new SecureDigester(CcmParser.class);\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}"
    },
    {
        "idx": "720",
        "vuln_id": "CVE-2018-1000068",
        "desc": "An improper input validation vulnerability exists in Jenkins versions 2.106 and earlier, and LTS 2.89.3 and earlier, that allows an attacker to access plugin resource files in the META-INF and WEB-INF directories that should not be accessible, if the Jenkins home directory is on a case-insensitive file system.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "8830d68f5fe21f344be3496984bc4470bfcd0564",
        "method_before": "    public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || path.contains(\"META-INF\") || path.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }",
        "method_after": "    public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        String pathUC = path.toUpperCase(Locale.ENGLISH);\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }"
    },
    {
        "idx": "756",
        "vuln_id": "CVE-2018-1067",
        "desc": "In Undertow before versions 7.1.2.CR1, 7.1.2.GA it was found that the fix for CVE-2016-4993 was incomplete and Undertow web server is vulnerable to the injection of arbitrary HTTP headers, and also response splitting, due to insufficient sanitization and validation of user input before the input is used as part of an HTTP header value.",
        "cwe_id": "CWE-113",
        "cwe_name": "Improper Neutralization of CRLF Sequences in HTTP Headers ('HTTP Request/Response Splitting')",
        "repo": "https://github.com/undertow-io/undertow",
        "commit": "85d4478e598105fe94ac152d3e11e388374e8b8"
    },
    {
        "idx": "831",
        "vuln_id": "CVE-2018-12691",
        "desc": "Time-of-check to time-of-use (TOCTOU) race condition in org.onosproject.acl (aka the access control application) in ONOS v1.13 and earlier allows attackers to bypass network access control via data plane packet injection.",
        "cwe_id": "CWE-362",
        "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "repo": "https://github.com/opennetworkinglab/onos",
        "commit": "4b931a988e2f6b547769ba70c815aaea4fe6b5d0",
        "method_before": "    private class InternalHostListener implements HostListener {\n\n        /**\n         * Generate new ACL flow rules for new host following the given ACL rule.\n         */\n        private void processHostAddedEvent(HostEvent event, AclRule rule) {\n            DeviceId deviceId = event.subject().location().deviceId();\n            for (IpAddress address : event.subject().ipAddresses()) {\n                if ((rule.srcIp() != null) ?\n                        (checkIpInCidr(address.getIp4Address(), rule.srcIp())) :\n                        (checkIpInCidr(address.getIp4Address(), rule.dstIp()))) {\n                    if (!aclStore.checkIfRuleWorksInDevice(rule.id(), deviceId)) {\n                        List<RuleId> allowingRuleList = aclStore\n                                .getAllowingRuleByDenyingRule(rule.id());\n                        if (allowingRuleList != null) {\n                            for (RuleId allowingRuleId : allowingRuleList) {\n                                generateAclFlow(aclStore.getAclRule(allowingRuleId), deviceId);\n                            }\n                        }\n                        generateAclFlow(rule, deviceId);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void event(HostEvent event) {\n            // if a new host appears and an existing rule denies\n            // its traffic, a new ACL flow rule is generated.\n            if (event.type() == HostEvent.Type.HOST_ADDED) {\n                DeviceId deviceId = event.subject().location().deviceId();\n                if (mastershipService.getLocalRole(deviceId) == MastershipRole.MASTER) {\n                    for (AclRule rule : aclStore.getAclRules()) {\n                        if (rule.action() != AclRule.Action.ALLOW) {\n                            processHostAddedEvent(event, rule);\n                        }\n                    }\n                }\n            }\n        }",
        "method_after": "    private class InternalHostListener implements HostListener {\n\n        /**\n         * Generate new ACL flow rules for new or updated host following the given ACL rule.\n         */\n        private void processHostAddedEvent(HostEvent event, AclRule rule) {\n            DeviceId deviceId = event.subject().location().deviceId();\n            for (IpAddress address : event.subject().ipAddresses()) {\n                if ((rule.srcIp() != null) ?\n                        (checkIpInCidr(address.getIp4Address(), rule.srcIp())) :\n                        (checkIpInCidr(address.getIp4Address(), rule.dstIp()))) {\n                    if (!aclStore.checkIfRuleWorksInDevice(rule.id(), deviceId)) {\n                        List<RuleId> allowingRuleList = aclStore\n                                .getAllowingRuleByDenyingRule(rule.id());\n                        if (allowingRuleList != null) {\n                            for (RuleId allowingRuleId : allowingRuleList) {\n                                generateAclFlow(aclStore.getAclRule(allowingRuleId), deviceId);\n                            }\n                        }\n                        generateAclFlow(rule, deviceId);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void event(HostEvent event) {\n            // if a new host appears or is updated and an existing rule denies\n            // its traffic, a new ACL flow rule is generated.\n            if (event.type() == HostEvent.Type.HOST_ADDED || event.type() == HostEvent.Type.HOST_UPDATED) {\n                DeviceId deviceId = event.subject().location().deviceId();\n                if (mastershipService.getLocalRole(deviceId) == MastershipRole.MASTER) {\n                    for (AclRule rule : aclStore.getAclRules()) {\n                        if (rule.action() != AclRule.Action.ALLOW) {\n                            processHostAddedEvent(event, rule);\n                        }\n                    }\n                }\n            }\n        }"
    },
    {
        "idx": "857",
        "vuln_id": "CVE-2018-1320",
        "desc": "Apache Thrift Java client library versions 0.5.0 through 0.11.0 can bypass SASL negotiation isComplete validation in the org.apache.thrift.transport.TSaslTransport class. An assert used to determine if the SASL handshake had successfully completed could be disabled in production settings making the validation incomplete.",
        "cwe_id": "CWE-295",
        "cwe_name": "Improper Certificate Validation",
        "repo": "https://github.com/apache/thrift",
        "commit": "d973409661f820d80d72c0034d06a12348c8705e",
        "method_before": "  public void open() throws TTransportException {\n    /*\n     * readSaslHeader is used to tag whether the SASL header has been read properly.\n     * If there is a problem in reading the header, there might not be any\n     * data in the stream, possibly a TCP health check from load balancer.\n     */\n    boolean readSaslHeader = false;\n\n    LOGGER.debug(\"opening transport {}\", this);\n    if (sasl != null && sasl.isComplete())\n      throw new TTransportException(\"SASL transport already open\");\n\n    if (!underlyingTransport.isOpen())\n      underlyingTransport.open();\n\n    try {\n      // Negotiate a SASL mechanism. The client also sends its\n      // initial response, or an empty one.\n      handleSaslStartMessage();\n      readSaslHeader = true;\n      LOGGER.debug(\"{}: Start message handled\", getRole());\n\n      SaslResponse message = null;\n      while (!sasl.isComplete()) {\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE &&\n            message.status != NegotiationStatus.OK) {\n          throw new TTransportException(\"Expected COMPLETE or OK, got \" + message.status);\n        }\n\n        byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);\n\n        // If we are the client, and the server indicates COMPLETE, we don't need to\n        // send back any further response.\n        if (message.status == NegotiationStatus.COMPLETE &&\n            getRole() == SaslRole.CLIENT) {\n          LOGGER.debug(\"{}: All done!\", getRole());\n          break;\n        }\n\n        sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,\n                        challenge);\n      }\n      LOGGER.debug(\"{}: Main negotiation loop complete\", getRole());\n\n      assert sasl.isComplete();\n\n      // If we're the client, and we're complete, but the server isn't\n      // complete yet, we need to wait for its response. This will occur\n      // with ANONYMOUS auth, for example, where we send an initial response\n      // and are immediately complete.\n      if (getRole() == SaslRole.CLIENT &&\n          (message == null || message.status == NegotiationStatus.OK)) {\n        LOGGER.debug(\"{}: SASL Client receiving last message\", getRole());\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE) {\n          throw new TTransportException(\n            \"Expected SASL COMPLETE, but got \" + message.status);\n        }\n      }\n    } catch (SaslException e) {\n      try {\n        LOGGER.error(\"SASL negotiation failure\", e);\n        throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());\n      } finally {\n        underlyingTransport.close();\n      }\n    } catch (TTransportException e) {\n      /*\n       * If there is no-data or no-sasl header in the stream, throw a different\n       * type of exception so we can handle this scenario differently.\n       */\n      if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {\n        underlyingTransport.close();\n        LOGGER.debug(\"No data or no sasl data in the stream\");\n        throw new TSaslTransportException(\"No data or no sasl data in the stream\");\n      }\n      throw e;\n    }\n\n    String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null && !qop.equalsIgnoreCase(\"auth\"))\n      shouldWrap = true;\n  }",
        "method_after": "  public void open() throws TTransportException {\n    /*\n     * readSaslHeader is used to tag whether the SASL header has been read properly.\n     * If there is a problem in reading the header, there might not be any\n     * data in the stream, possibly a TCP health check from load balancer.\n     */\n    boolean readSaslHeader = false;\n\n    LOGGER.debug(\"opening transport {}\", this);\n    if (sasl != null && sasl.isComplete())\n      throw new TTransportException(\"SASL transport already open\");\n\n    if (!underlyingTransport.isOpen())\n      underlyingTransport.open();\n\n    try {\n      // Negotiate a SASL mechanism. The client also sends its\n      // initial response, or an empty one.\n      handleSaslStartMessage();\n      readSaslHeader = true;\n      LOGGER.debug(\"{}: Start message handled\", getRole());\n\n      SaslResponse message = null;\n      while (!sasl.isComplete()) {\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE &&\n            message.status != NegotiationStatus.OK) {\n          throw new TTransportException(\"Expected COMPLETE or OK, got \" + message.status);\n        }\n\n        byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);\n\n        // If we are the client, and the server indicates COMPLETE, we don't need to\n        // send back any further response.\n        if (message.status == NegotiationStatus.COMPLETE &&\n            getRole() == SaslRole.CLIENT) {\n          LOGGER.debug(\"{}: All done!\", getRole());\n          continue;\n        }\n\n        sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,\n                        challenge);\n      }\n      LOGGER.debug(\"{}: Main negotiation loop complete\", getRole());\n\n      // If we're the client, and we're complete, but the server isn't\n      // complete yet, we need to wait for its response. This will occur\n      // with ANONYMOUS auth, for example, where we send an initial response\n      // and are immediately complete.\n      if (getRole() == SaslRole.CLIENT &&\n          (message == null || message.status == NegotiationStatus.OK)) {\n        LOGGER.debug(\"{}: SASL Client receiving last message\", getRole());\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE) {\n          throw new TTransportException(\n            \"Expected SASL COMPLETE, but got \" + message.status);\n        }\n      }\n    } catch (SaslException e) {\n      try {\n        LOGGER.error(\"SASL negotiation failure\", e);\n        throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());\n      } finally {\n        underlyingTransport.close();\n      }\n    } catch (TTransportException e) {\n      /*\n       * If there is no-data or no-sasl header in the stream, throw a different\n       * type of exception so we can handle this scenario differently.\n       */\n      if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {\n        underlyingTransport.close();\n        LOGGER.debug(\"No data or no sasl data in the stream\");\n        throw new TSaslTransportException(\"No data or no sasl data in the stream\");\n      }\n      throw e;\n    }\n\n    String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null && !qop.equalsIgnoreCase(\"auth\"))\n      shouldWrap = true;\n  }"
    },
    {
        "idx": "910",
        "vuln_id": "CVE-2018-18389",
        "desc": "Due to incorrect access control in Neo4j Enterprise Database Server 3.4.x before 3.4.9, the setting of LDAP for authentication with STARTTLS, and System Account for authorization, allows an attacker to log into the server by sending any valid username with an arbitrary password.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/neo4j/neo4j",
        "commit": "46de5d01ae2741ffe04c36270fc62c6d490f65c9",
        "method_before": "    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }",
        "method_after": "    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            // do a lookup of the user to trigger authentication\n            ctx.lookup( principal.toString() );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }"
    },
    {
        "idx": "913",
        "vuln_id": "CVE-2018-19413",
        "desc": "A vulnerability in the API of SonarSource SonarQube before 7.4 could allow an authenticated user to discover sensitive information such as valid user-account logins in the web application. The vulnerability occurs because of improperly configured access controls that cause the API to return the externalIdentity field to non-administrator users. The attacker could use this information in subsequent attacks against the system.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/SonarSource/sonarqube",
        "commit": "7b567ba3d15ed7dd0b0bba0330686487e35af85c"
    },
    {
        "idx": "973",
        "vuln_id": "CVE-2018-8038",
        "desc": "Versions of Apache CXF Fediz prior to 1.4.4 do not fully disable Document Type Declarations (DTDs) when either parsing the Identity Provider response in the application plugins, or in the Identity Provider itself when parsing certain XML-based parameters.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/apache/cxf-fediz",
        "commit": "b6ed9865d0614332fa419fe4b6d0fe81bc2e660d"
    },
    {
        "idx": "1027",
        "vuln_id": "CVE-2019-10797",
        "desc": "['Netty in WSO2 transport-http before v6.3.1 is vulnerable to HTTP Response Splitting due to HTTP Header validation being disabled.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/wso2/transport-http",
        "commit": "4a4dc99c7b259646ee5e23b7aaa7c3a8bac959c1"
    },
    {
        "idx": "1029",
        "vuln_id": "CVE-2019-11272",
        "desc": "Spring Security, versions 4.2.x up to 4.2.12, and older unsupported versions support plain text passwords using PlaintextPasswordEncoder. If an application using an affected version of Spring Security is leveraging PlaintextPasswordEncoder and a user has a null encoded password, a malicious user (or attacker) can authenticate using a password of \"null\".",
        "cwe_id": "CWE-522",
        "cwe_name": "Insufficiently Protected Credentials",
        "repo": "https://github.com/spring-projects/spring-security",
        "commit": "b2d4fec3617c497c5a8eb9c7e5270e0c7db293ee"
    },
    {
        "idx": "1038",
        "vuln_id": "CVE-2019-12402",
        "desc": "The file name encoding algorithm used internally in Apache Commons Compress 1.15 to 1.18 can get into an infinite loop when faced with specially crafted inputs. This can lead to a denial of service attack if an attacker can choose the file names inside of an archive created by Compress.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "4ad5d80a6272e007f64a6ac66829ca189a8093b9",
        "method_before": "    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    // if the destination buffer isn't over sized, assume that the presence of one\n                    // unmappable character makes it likely that there will be more. Find all the\n                    // un-encoded characters and allocate space based on those estimates.\n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n            }\n        }\n        // tell the encoder we are done\n        enc.encode(cb, out, true);\n        // may have caused underflow, but that's been ignored traditionally\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
        "method_after": "    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    // if the destination buffer isn't over sized, assume that the presence of one\n                    // unmappable character makes it likely that there will be more. Find all the\n                    // un-encoded characters and allocate space based on those estimates.\n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n\n            } else if (res.isUnderflow() || res.isError()) {\n                break;\n            }\n        }\n        // tell the encoder we are done\n        enc.encode(cb, out, true);\n        // may have caused underflow, but that's been ignored traditionally\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }"
    },
    {
        "idx": "1102",
        "vuln_id": "CVE-2020-12480",
        "desc": "In Play Framework 2.6.0 through 2.8.1, the CSRF filter can be bypassed by making CORS simple requests with content types that contain parameters that can't be parsed.",
        "cwe_id": "CWE-352",
        "cwe_name": "Cross-Site Request Forgery (CSRF)",
        "repo": "https://github.com/playframework/playframework",
        "commit": "681d8ee3f785a6105b0595d8f10a8ee5718e6d7b",
        "method_before": "  public CompletionStage<Result> call(Http.Request req) {\n\n    CSRFActionHelper csrfActionHelper =\n        new CSRFActionHelper(sessionConfiguration, config, tokenSigner, tokenProvider);\n\n    RequestHeader taggedRequest = csrfActionHelper.tagRequestFromHeader(req.asScala());\n    // Check for bypass\n    if (!csrfActionHelper.requiresCsrfCheck(taggedRequest)) {\n      return delegate.call(req);\n    } else {\n      // Get token from cookie/session\n      Option<String> headerToken = csrfActionHelper.getTokenToValidate(taggedRequest);\n      if (headerToken.isDefined()) {\n        String tokenToCheck = null;\n\n        // Get token from query string\n        Option<String> queryStringToken = csrfActionHelper.getHeaderToken(taggedRequest);\n        if (queryStringToken.isDefined()) {\n          tokenToCheck = queryStringToken.get();\n        } else {\n\n          // Get token from body\n          if (req.body().asFormUrlEncoded() != null) {\n            String[] values = req.body().asFormUrlEncoded().get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          } else if (req.body().asMultipartFormData() != null) {\n            Map<String, String[]> form = req.body().asMultipartFormData().asFormUrlEncoded();\n            String[] values = form.get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          }\n        }\n\n        if (tokenToCheck != null) {\n          if (tokenProvider.compareTokens(tokenToCheck, headerToken.get())) {\n            return delegate.call(req);\n          } else {\n            return handleTokenError(req, taggedRequest, \"CSRF tokens don't match\");\n          }\n        } else {\n          return handleTokenError(\n              req, taggedRequest, \"CSRF token not found in body or query string\");\n        }\n      } else {\n        return handleTokenError(req, taggedRequest, \"CSRF token not found in session\");\n      }\n    }\n  }",
        "method_after": "  public CompletionStage<Result> call(Http.Request req) {\n\n    CSRFActionHelper csrfActionHelper =\n        new CSRFActionHelper(sessionConfiguration, config, tokenSigner, tokenProvider);\n\n    RequestHeader taggedRequest = csrfActionHelper.tagRequestFromHeader(req.asScala());\n    // Check for bypass\n    if (!csrfActionHelper.requiresCsrfCheck(taggedRequest)\n        || (config.checkContentType().apply(req.asScala().contentType()) != Boolean.TRUE\n            && !csrfActionHelper.hasInvalidContentType(req.asScala()))) {\n      return delegate.call(req);\n    } else {\n      // Get token from cookie/session\n      Option<String> headerToken = csrfActionHelper.getTokenToValidate(taggedRequest);\n      if (headerToken.isDefined()) {\n        String tokenToCheck = null;\n\n        // Get token from query string\n        Option<String> queryStringToken = csrfActionHelper.getHeaderToken(taggedRequest);\n        if (queryStringToken.isDefined()) {\n          tokenToCheck = queryStringToken.get();\n        } else {\n\n          // Get token from body\n          if (req.body().asFormUrlEncoded() != null) {\n            String[] values = req.body().asFormUrlEncoded().get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          } else if (req.body().asMultipartFormData() != null) {\n            Map<String, String[]> form = req.body().asMultipartFormData().asFormUrlEncoded();\n            String[] values = form.get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          }\n        }\n\n        if (tokenToCheck != null) {\n          if (tokenProvider.compareTokens(tokenToCheck, headerToken.get())) {\n            return delegate.call(req);\n          } else {\n            return handleTokenError(req, taggedRequest, \"CSRF tokens don't match\");\n          }\n        } else {\n          return handleTokenError(\n              req, taggedRequest, \"CSRF token not found in body or query string\");\n        }\n      } else {\n        return handleTokenError(req, taggedRequest, \"CSRF token not found in session\");\n      }\n    }\n  }"
    },
    {
        "idx": "1213",
        "vuln_id": "ZEPPELIN-2769",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/zeppelin",
        "commit": "709c5a70a8f37277c9eea0a1c0c9195b5eb21a74",
        "method_before": "  public List<String> getUserList(JdbcRealm obj) {\n    List<String> userlist = new ArrayList<>();\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    DataSource dataSource = null;\n    String authQuery = \"\";\n    String retval[];\n    String tablename = \"\";\n    String username = \"\";\n    String userquery = \"\";\n    try {\n      dataSource = (DataSource) FieldUtils.readField(obj, \"dataSource\", true);\n      authQuery = (String) FieldUtils.readField(obj, \"authenticationQuery\", true);\n      LOG.info(authQuery);\n      String authQueryLowerCase = authQuery.toLowerCase();\n      retval = authQueryLowerCase.split(\"from\", 2);\n      if (retval.length >= 2) {\n        retval = retval[1].split(\"with|where\", 2);\n        tablename = retval[0];\n        retval = retval[1].split(\"where\", 2);\n        if (retval.length >= 2)\n          retval = retval[1].split(\"=\", 2);\n        else\n          retval = retval[0].split(\"=\", 2);\n        username = retval[0];\n      }\n\n      if (StringUtils.isBlank(username) || StringUtils.isBlank(tablename)) {\n        return userlist;\n      }\n\n      userquery = \"select \" + username + \" from \" + tablename;\n\n    } catch (IllegalAccessException e) {\n      LOG.error(\"Error while accessing dataSource for JDBC Realm\", e);\n      return null;\n    }\n\n    try {\n      Connection con = dataSource.getConnection();\n      ps = con.prepareStatement(userquery);\n      rs = ps.executeQuery();\n      while (rs.next()) {\n        userlist.add(rs.getString(1).trim());\n      }\n    } catch (Exception e) {\n      LOG.error(\"Error retrieving User list from JDBC Realm\", e);\n    } finally {\n      JdbcUtils.closeResultSet(rs);\n      JdbcUtils.closeStatement(ps);\n    }\n    return userlist;\n  }",
        "method_after": "  public List<String> getUserList(JdbcRealm obj) {\n    List<String> userlist = new ArrayList<>();\n    PreparedStatement ps = null;\n    ResultSet rs = null;\n    DataSource dataSource = null;\n    String authQuery = \"\";\n    String retval[];\n    String tablename = \"\";\n    String username = \"\";\n    String userquery = \"\";\n    try {\n      dataSource = (DataSource) FieldUtils.readField(obj, \"dataSource\", true);\n      authQuery = (String) FieldUtils.readField(obj, \"authenticationQuery\", true);\n      LOG.info(authQuery);\n      String authQueryLowerCase = authQuery.toLowerCase();\n      retval = authQueryLowerCase.split(\"from\", 2);\n      if (retval.length >= 2) {\n        retval = retval[1].split(\"with|where\", 2);\n        tablename = retval[0];\n        retval = retval[1].split(\"where\", 2);\n        if (retval.length >= 2)\n          retval = retval[1].split(\"=\", 2);\n        else\n          retval = retval[0].split(\"=\", 2);\n        username = retval[0];\n      }\n\n      if (StringUtils.isBlank(username) || StringUtils.isBlank(tablename)) {\n        return userlist;\n      }\n\n      userquery = \"select ? from ?\";\n\n    } catch (IllegalAccessException e) {\n      LOG.error(\"Error while accessing dataSource for JDBC Realm\", e);\n      return null;\n    }\n\n    try {\n      Connection con = dataSource.getConnection();\n      ps = con.prepareStatement(userquery);\n      ps.setString(1, username);\n      ps.setString(2, tablename);\n      rs = ps.executeQuery();\n      while (rs.next()) {\n        userlist.add(rs.getString(1).trim());\n      }\n    } catch (Exception e) {\n      LOG.error(\"Error retrieving User list from JDBC Realm\", e);\n    } finally {\n      JdbcUtils.closeResultSet(rs);\n      JdbcUtils.closeStatement(ps);\n    }\n    return userlist;\n  }"
    },
    {
        "idx": "1468",
        "vuln_id": "CVE-2019-13623",
        "desc": "In NSA Ghidra before 9.1, path traversal can occur in RestoreTask.java (from the package ghidra.app.plugin.core.archive) via an archive with an executable file that has an initial ../ in its filename. This allows attackers to overwrite arbitrary files in scenarios where an intermediate analysis result is archived for sharing with other persons. To achieve arbitrary code execution, one approach is to overwrite some critical Ghidra modules, e.g., the decompile module.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/NationalSecurityAgency/ghidra",
        "commit": "c15364e0a4bd2bcd3bdf13a35afd6ac9607a5164"
    },
    {
        "idx": "1474",
        "vuln_id": "CVE-2019-14893",
        "desc": "A flaw was discovered in FasterXML jackson-databind in all versions before 2.9.10 and 2.10.0, where it would permit polymorphic deserialization of malicious objects using the xalan JNDI gadget when used in conjunction with polymorphic type handling methods such as `enableDefaultTyping()` or when @JsonTypeInfo is using `Id.CLASS` or `Id.MINIMAL_CLASS` or in any other way which ObjectMapper.readValue might instantiate objects from unsafe sources. An attacker could use this flaw to execute arbitrary code.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "998efd708284778f29d83d7962a9bd935c228317"
    },
    {
        "idx": "1544",
        "vuln_id": "CVE-2020-11619",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.4 mishandles the interaction between serialization gadgets and typing, related to org.springframework.aop.config.MethodLocatingFactoryBean (aka spring-aop).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "113e89fb08b1b6b072d60b3e4737ed407c13db9a"
    },
    {
        "idx": "1545",
        "vuln_id": "CVE-2020-11620",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.4 mishandles the interaction between serialization gadgets and typing, related to org.apache.commons.jelly.impl.Embedded (aka commons-jelly).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "77040d85e3eb6710508e6445640ae1a3d5e60c22"
    },
    {
        "idx": "1551",
        "vuln_id": "CVE-2020-14062",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.5 mishandles the interaction between serialization gadgets and typing, related to com.sun.org.apache.xalan.internal.lib.sql.JNDIConnectionPool (aka xalan2).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "840eae2ca81c597a0010b2126f32dce17d384b70"
    },
    {
        "idx": "1552",
        "vuln_id": "CVE-2020-14195",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.5 mishandles the interaction between serialization gadgets and typing, related to org.jsecurity.realm.jndi.JndiRealmFactory (aka org.jsecurity).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "f6d9c664f6d481703138319f6a0f1fdbddb3a259"
    },
    {
        "idx": "1563",
        "vuln_id": "CVE-2020-24616",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.6 mishandles the interaction between serialization gadgets and typing, related to br.com.anteros.dbcp.AnterosDBCPDataSource (aka Anteros-DBCP).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "3d97153944f7de9c19c1b3637b33d3cf1fbbe4d7"
    },
    {
        "idx": "1565",
        "vuln_id": "CVE-2020-24750",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.6 mishandles the interaction between serialization gadgets and typing, related to com.pastdev.httpcomponents.configuration.JndiConfiguration.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "6cc9f1a1af323cd156f5668a47e43bab324ae16f"
    },
    {
        "idx": "1662",
        "vuln_id": "unknown-147",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/SonarSource/sonarqube",
        "commit": "f05114072b582839b997c40ea36f9267eae6b8d4",
        "method_before": "  public Filter createFilter() {\n    return Filter.create()\n        .setDisplayAs(Filter.LIST)\n        .add(Criterion.createForQualifier(Qualifiers.PROJECT))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.ALERT_STATUS_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"name\", null, FilterColumn.ASC, false))\n        .add(FilterColumn.create(\"version\", null, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.NCLOC_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.TECHNICAL_DEBT_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"date\", null, FilterColumn.DESC, false));\n  }",
        "method_after": "  public Filter createFilter() {\n    return Filter.create()\n        .setDisplayAs(Filter.LIST)\n        .add(Criterion.createForQualifier(Qualifiers.PROJECT))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.ALERT_STATUS_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"name\", null, FilterColumn.ASC, false))\n        .add(FilterColumn.create(\"version\", null, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.NCLOC_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.CODE_SMELLS_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.BUGS_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"metric\", CoreMetrics.VULNERABILITIES_KEY, FilterColumn.DESC, false))\n        .add(FilterColumn.create(\"date\", null, FilterColumn.DESC, false));\n  }"
    },
    {
        "idx": "1673",
        "vuln_id": "unknown-157",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/spring-projects/spring-security",
        "commit": "7cf37856c0b06775469bf0dea907bee8280b2a31",
        "method_before": "    private String calculateRedirectUrl(String contextPath, String url) {\n        if (!UrlUtils.isAbsoluteUrl(url)) {\n            if (contextRelative) {\n                return url;\n            } else {\n                return contextPath + url;\n            }\n        }\n\n        // Full URL, including http(s)://\n\n        if (!contextRelative) {\n            return url;\n        }\n\n        // Calculate the relative URL from the fully qualified URL, minus the scheme and base context.\n        url = url.substring(url.indexOf(\"://\") + 3); // strip off scheme\n        url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n        if (url.length() > 1 && url.charAt(0) == '/') {\n            url = url.substring(1);\n        }\n\n        return url;\n    }",
        "method_after": "    private String calculateRedirectUrl(String contextPath, String url) {\n        if (!UrlUtils.isAbsoluteUrl(url)) {\n            if (contextRelative) {\n                return url;\n            } else {\n                return contextPath + url;\n            }\n        }\n\n        // Full URL, including http(s)://\n\n        if (!contextRelative) {\n            return url;\n        }\n\n        // Calculate the relative URL from the fully qualified URL, minus the last\n        // occurrence of the scheme and base context.\n        url = url.substring(url.lastIndexOf(\"://\") + 3); // strip off scheme\n        url = url.substring(url.indexOf(contextPath) + contextPath.length());\n\n        if (url.length() > 1 && url.charAt(0) == '/') {\n            url = url.substring(1);\n        }\n\n        return url;\n    }"
    },
    {
        "idx": "1679",
        "vuln_id": "unknown-162",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/opencast/opencast",
        "commit": "e493d0df363322557d900b59fd4de078be915b23",
        "method_before": "  private void createSystemUsers() {\n    for (Organization organization : orgDirectoryService.getOrganizations()) {\n      JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(organization);\n\n      // Create the digest auth users with clear text passwords\n\n      // Role set for the system user\n      Set<JaxbRole> roleList = new HashSet<JaxbRole>();\n      for (String roleName : SecurityConstants.GLOBAL_SYSTEM_ROLES) {\n        roleList.add(new JaxbRole(roleName, jaxbOrganization));\n      }\n\n      // Create the system user\n      if (digestUsername != null && digestUserPass != null) {\n        logger.info(\"Creating the system digest user '{}'\", digestUsername);\n        User digestUser = new JaxbUser(digestUsername, digestUserPass, DIGEST_USER_NAME, null, getName(), true,\n                jaxbOrganization, roleList);\n        inMemoryUsers.add(digestUser);\n      }\n\n      String caUsername = organization.getProperties().get(CAPTURE_AGENT_USER_KEY);\n      String caUserPass = organization.getProperties().get(CAPTURE_AGENT_PASSWORD_KEY);\n      if (caUsername != null && caUserPass != null) {\n        // Role set for the capture agent user\n        Set<JaxbRole> caRoleList = new HashSet<>();\n        for (String roleName : SecurityConstants.GLOBAL_CAPTURE_AGENT_ROLES) {\n          caRoleList.add(new JaxbRole(roleName, jaxbOrganization));\n        }\n\n        // Add the organization anonymous role to the capture agent user\n        caRoleList.add(new JaxbRole(organization.getAnonymousRole(), jaxbOrganization));\n\n        String caExtraRoles = organization.getProperties().get(CAPTURE_AGENT_EXTRA_ROLES_KEY);\n        // Add any extra custom roles to the CA user\n        if (caExtraRoles != null) {\n          List<String> items = Arrays.asList(caExtraRoles.split(\"\\\\s*,\\\\s*\"));\n          for (String item : items) {\n            logger.debug(\"Adding custom role '{}' to capture agent user {}\", item, caUsername);\n            caRoleList.add(new JaxbRole(item, jaxbOrganization));\n          }\n        }\n\n        // Create the capture agent user\n        logger.info(\"Creating the capture agent digest user '{}'\", caUsername);\n        User caUser = new JaxbUser(caUsername, caUserPass, CAPTURE_AGENT_USER_NAME, null, getName(), true,\n                jaxbOrganization, caRoleList);\n        inMemoryUsers.add(caUser);\n      }\n    }\n  }",
        "method_after": "  private void createSystemUsers() {\n    for (Organization organization : orgDirectoryService.getOrganizations()) {\n      JaxbOrganization jaxbOrganization = JaxbOrganization.fromOrganization(organization);\n\n      // Create the digest auth users with clear text passwords\n\n      // Role set for the system user\n      Set<JaxbRole> roleList = new HashSet<JaxbRole>();\n      for (String roleName : SecurityConstants.GLOBAL_SYSTEM_ROLES) {\n        roleList.add(new JaxbRole(roleName, jaxbOrganization));\n      }\n\n      // Create the system user\n      if (digestUsername != null && digestUserPass != null) {\n        logger.info(\"Creating the system digest user '{}'\", digestUsername);\n        User digestUser = new JaxbUser(digestUsername, digestUserPass, DIGEST_USER_NAME, null, getName(), true,\n                jaxbOrganization, roleList);\n        inMemoryUsers.add(digestUser);\n      }\n\n      /* Deactivated due to security issue (CVE-2018-16154)\n      String caUsername = organization.getProperties().get(CAPTURE_AGENT_USER_KEY);\n      String caUserPass = organization.getProperties().get(CAPTURE_AGENT_PASSWORD_KEY);\n      if (caUsername != null && caUserPass != null) {\n        // Role set for the capture agent user\n        Set<JaxbRole> caRoleList = new HashSet<>();\n        for (String roleName : SecurityConstants.GLOBAL_CAPTURE_AGENT_ROLES) {\n          caRoleList.add(new JaxbRole(roleName, jaxbOrganization));\n        }\n\n        // Add the organization anonymous role to the capture agent user\n        caRoleList.add(new JaxbRole(organization.getAnonymousRole(), jaxbOrganization));\n\n        String caExtraRoles = organization.getProperties().get(CAPTURE_AGENT_EXTRA_ROLES_KEY);\n        // Add any extra custom roles to the CA user\n        if (caExtraRoles != null) {\n          List<String> items = Arrays.asList(caExtraRoles.split(\"\\\\s*,\\\\s*\"));\n          for (String item : items) {\n            logger.debug(\"Adding custom role '{}' to capture agent user {}\", item, caUsername);\n            caRoleList.add(new JaxbRole(item, jaxbOrganization));\n          }\n        }\n\n        // Create the capture agent user\n        logger.info(\"Creating the capture agent digest user '{}'\", caUsername);\n        User caUser = new JaxbUser(caUsername, caUserPass, CAPTURE_AGENT_USER_NAME, null, getName(), true,\n                jaxbOrganization, caRoleList);\n        inMemoryUsers.add(caUser);\n      }\n      */\n    }\n  }"
    },
    {
        "idx": "1701",
        "vuln_id": "unknown-182",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "454be8bb8c913be18298327a84ca45a280b61605"
    },
    {
        "idx": "1782",
        "vuln_id": "unknown-255",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/spring-projects/spring-amqp",
        "commit": "fddbdf7100ed0e444f74bbf7fa660a7a5d2dfc8f"
    },
    {
        "idx": "1827",
        "vuln_id": "unknown-53",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "f5f9a0aa78af9e0aad7f2be14fc6696d056c7f9f",
        "method_before": "    protected String getSubstitution(FormEntrySession session, FormSubmissionController controllerActions, Map<String, String> parameters) {\n        String expression = parameters.get(\"expression\");\n        String className = parameters.get(\"class\");\n        String complexExpression = parameters.get(\"complexExpression\");\n        if (expression != null && complexExpression != null)\n            throw new RuntimeException(\"Cannot specify both expression and complexExpression\");\n        if (expression == null && complexExpression == null)\n            throw new RuntimeException(\"Must specify expression or complexExpression for velocity\");\n        String value;\n        if (expression != null)\n            value = session.evaluateVelocityExpression(\"$!{\" + expression + \"}\");\n        else\n            value = session.evaluateVelocityExpression(complexExpression);\n        \n        // Enable date formatting \n    \tDateFormat fromFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss z yyyy\");\n    \tDateFormat fromFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n    \tDate d = null;\n    \ttry {\n        \td = fromFormat.parse(value);\n    \t}\n        catch (Exception e) {\n        \ttry {\n        \t\td = fromFormat2.parse(value);\n        \t}\n            catch (Exception e2) {\n            \t// Do nothing\n            }\n        }\n        if (d != null) {\n        \tString newFormat = parameters.get(\"format\");\n        \tDateFormat toFormat = new SimpleDateFormat(newFormat == null ? \"dd/MMM/yyyy\" : newFormat, Context.getLocale());\n        \tvalue = toFormat.format(d);\n        }\n        \n        // Enable translation via existing message sources\n        String codePrefix = parameters.get(\"codePrefix\");\n        if (codePrefix != null) {\n        \tString lookupCode = codePrefix + value;\n        \tString translatedValue = session.getContext().getTranslator().translate(Context.getLocale().toString(), lookupCode);\n        \tif (StringUtils.hasText(translatedValue) && !translatedValue.equals(lookupCode)) {\n        \t\tvalue = translatedValue;\n        \t}\n        }\n        \n        if (className != null) {\n            return \"<span class=\\\"\" + className + \"\\\">\" + StringEscapeUtils.escapeHtml(value) + \"</span>\";\n        } else {\n            return value;\n        }\n    }",
        "method_after": "    protected String getSubstitution(FormEntrySession session, FormSubmissionController controllerActions, Map<String, String> parameters) {\n        String expression = parameters.get(\"expression\");\n        String className = parameters.get(\"class\");\n        String complexExpression = parameters.get(\"complexExpression\");\n        if (expression != null && complexExpression != null)\n            throw new RuntimeException(\"Cannot specify both expression and complexExpression\");\n        if (expression == null && complexExpression == null)\n            throw new RuntimeException(\"Must specify expression or complexExpression for velocity\");\n        String value;\n        if (expression != null)\n            value = session.evaluateVelocityExpression(\"$!{\" + expression + \"}\");\n        else\n            value = session.evaluateVelocityExpression(complexExpression);\n        \n        // Enable date formatting \n    \tDateFormat fromFormat = new SimpleDateFormat(\"EEE MMM dd HH:mm:ss z yyyy\");\n    \tDateFormat fromFormat2 = new SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss.S\");\n    \tDate d = null;\n    \ttry {\n        \td = fromFormat.parse(value);\n    \t}\n        catch (Exception e) {\n        \ttry {\n        \t\td = fromFormat2.parse(value);\n        \t}\n            catch (Exception e2) {\n            \t// Do nothing\n            }\n        }\n        if (d != null) {\n        \tString newFormat = parameters.get(\"format\");\n        \tDateFormat toFormat = new SimpleDateFormat(newFormat == null ? \"dd/MMM/yyyy\" : newFormat, Context.getLocale());\n        \tvalue = toFormat.format(d);\n        }\n        \n        // Enable translation via existing message sources\n        String codePrefix = parameters.get(\"codePrefix\");\n        if (codePrefix != null) {\n        \tString lookupCode = codePrefix + value;\n        \tString translatedValue = session.getContext().getTranslator().translate(Context.getLocale().toString(), lookupCode);\n        \tif (StringUtils.hasText(translatedValue) && !translatedValue.equals(lookupCode)) {\n        \t\tvalue = translatedValue;\n        \t}\n        }\n        \n        value = StringEscapeUtils.escapeHtml(value);\n        \n        if (className != null) {\n            return \"<span class=\\\"\" + className + \"\\\">\" + value + \"</span>\";\n        } else {\n            return value;\n        }\n    }"
    },
    {
        "idx": "2",
        "vuln_id": "413684",
        "desc": "[]",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/eclipse/jetty.project",
        "commit": "2f08ba29487aff6624dbf947b1fbd845cdd33464"
    },
    {
        "idx": "204",
        "vuln_id": "CVE-2013-4366",
        "desc": "http/impl/client/HttpClientBuilder.java in Apache HttpClient 4.3.x before 4.3.1 does not ensure that X509HostnameVerifier is not null, which allows attackers to have unspecified impact via vectors involving hostname verification.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/apache/httpcomponents-client",
        "commit": "08140864e3e4c0994e094c4cf0507932baf6a66"
    },
    {
        "idx": "232",
        "vuln_id": "CVE-2014-0086",
        "desc": "The doFilter function in webapp/PushHandlerFilter.java in JBoss RichFaces 4.3.4, 4.3.5, and 5.x allows remote attackers to cause a denial of service (memory consumption and out-of-memory error) via a large number of malformed atmosphere push requests.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/pslegr/core-1",
        "commit": "8131f15003f5bec73d475d2b724472e4b87d0757",
        "method_before": "    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }",
        "method_after": "    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }"
    },
    {
        "idx": "305",
        "vuln_id": "CVE-2015-0899",
        "desc": "The MultiPageValidator implementation in Apache Struts 1 1.1 through 1.3.10 allows remote attackers to bypass intended access restrictions via a modified page parameter.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/kawasima/struts1-forever",
        "commit": "212bb0f7c57617b7b9c44cb1e056bd1e597c8e16",
        "method_before": "    protected void initOther() throws ServletException {\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }",
        "method_after": "    protected void initOther() throws ServletException {\n        PropertyUtils.addBeanIntrospector(\n                SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS);\n        PropertyUtils.clearDescriptors();\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }"
    },
    {
        "idx": "536",
        "vuln_id": "CVE-2017-1000243",
        "desc": "Jenkins Favorite Plugin 2.1.4 and older does not perform permission checks when changing favorite status, allowing any user to set any other user's favorites",
        "cwe_id": "CWE-862",
        "cwe_name": "Missing Authorization",
        "repo": "https://github.com/jenkinsci/favorite-plugin",
        "commit": "b6359532fe085d9ea6b7894e997e797806480777"
    },
    {
        "idx": "541",
        "vuln_id": "CVE-2017-1000388",
        "desc": "Jenkins Dependency Graph Viewer plugin 0.12 and earlier did not perform permission checks for the API endpoint that modifies the dependency graph, allowing anyone with Overall/Read permission to modify this data.",
        "cwe_id": "CWE-862",
        "cwe_name": "Missing Authorization",
        "repo": "https://github.com/jenkinsci/depgraph-view-plugin",
        "commit": "d442ff671965c279770b28e37dc63a6ab73c0f0e",
        "method_before": "    public EdgeOperation(String sourceJobName, String targetJobName) {\n        this.source = Jenkins.getInstance().getItemByFullName(sourceJobName.trim(), AbstractProject.class);\n        this.target = Jenkins.getInstance().getItemByFullName(targetJobName, AbstractProject.class);\n    }",
        "method_after": "    public EdgeOperation(String sourceJobName, String targetJobName) {\n        this.source = Jenkins.getInstance().getItemByFullName(sourceJobName.trim(), AbstractProject.class);\n        this.target = Jenkins.getInstance().getItemByFullName(targetJobName, AbstractProject.class);\n        source.checkPermission(Permission.CONFIGURE);\n        target.checkPermission(Permission.CONFIGURE);\n    }"
    },
    {
        "idx": "721",
        "vuln_id": "CVE-2018-1000089",
        "desc": "Anymail django-anymail version version 0.2 through 1.3 contains a CWE-532, CWE-209 vulnerability in WEBHOOK_AUTHORIZATION setting value that can result in An attacker with access to error logs could fabricate email tracking events. This attack appear to be exploitable via If you have exposed your Django error reports, an attacker could discover your ANYMAIL_WEBHOOK setting and use this to post fabricated or malicious Anymail tracking/inbound events to your app. This vulnerability appears to have been fixed in v1.4.",
        "cwe_id": "CWE-532",
        "cwe_name": "Insertion of Sensitive Information into Log File",
        "repo": "https://github.com/jenkinsci/pipeline-build-step-plugin",
        "commit": "3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3",
        "method_before": "    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }",
        "method_after": "    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        item.checkPermission(Item.BUILD);\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }"
    },
    {
        "idx": "744",
        "vuln_id": "CVE-2018-1000844",
        "desc": "Square Open Source Retrofit version Prior to commit 4a693c5aeeef2be6c7ecf80e7b5ec79f6ab59437 contains a XML External Entity (XXE) vulnerability in JAXB that can result in An attacker could use this to remotely read files from the file system or to perform SSRF.. This vulnerability appears to have been fixed in After commit 4a693c5aeeef2be6c7ecf80e7b5ec79f6ab59437.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/square/retrofit",
        "commit": "97057aaae42e54bfbee8acfa8af7dcf37e812342"
    },
    {
        "idx": "746",
        "vuln_id": "CVE-2018-1000854",
        "desc": "esigate.org esigate version 5.2 and earlier contains a CWE-74: Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection') vulnerability in ESI directive with user specified XSLT that can result in Remote Code Execution. This attack appear to be exploitable via Use of another weakness in backend application to reflect ESI directives. This vulnerability appears to have been fixed in 5.3.",
        "cwe_id": "CWE-74",
        "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
        "repo": "https://github.com/esigate/esigate",
        "commit": "30cad23a8f282600c9b045e1af09f6f8a65357b1"
    },
    {
        "idx": "786",
        "vuln_id": "CVE-2018-11784",
        "desc": "When the default servlet in Apache Tomcat versions 9.0.0.M1 to 9.0.11, 8.5.0 to 8.5.33 and 7.0.23 to 7.0.90 returned a redirect to a directory (e.g. redirecting to '/foo/' when the user requested '/foo') a specially crafted URL could be used to cause the redirect to be generated to any URI of the attackers choice.",
        "cwe_id": "CWE-601",
        "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "efb860b3ff8ebcf606199b8d0d432f76898040da",
        "method_before": "    private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        StringBuilder location = new StringBuilder(request.getRequestURI());\n        location.append('/');\n        if (request.getQueryString() != null) {\n            location.append('?');\n            location.append(request.getQueryString());\n        }\n        response.sendRedirect(response.encodeRedirectURL(location.toString()));\n    }",
        "method_after": "    private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        StringBuilder location = new StringBuilder(request.getRequestURI());\n        location.append('/');\n        if (request.getQueryString() != null) {\n            location.append('?');\n            location.append(request.getQueryString());\n        }\n        // Avoid protocol relative redirects\n        while (location.length() > 1 && location.charAt(1) == '/') {\n            location.deleteCharAt(0);\n        }\n        response.sendRedirect(response.encodeRedirectURL(location.toString()));\n    }"
    },
    {
        "idx": "848",
        "vuln_id": "CVE-2018-1304",
        "desc": "['The URL pattern of \"\" (the empty string) which exactly maps to the context root was not correctly handled in Apache Tomcat 9.0.0.M1 to 9.0.4, 8.5.0 to 8.5.27, 8.0.0.RC1 to 8.0.49 and 7.0.0 to 7.0.84 when used as part of a security constraint definition. This caused the constraint to be ignored. It was, therefore, possible for unauthorised users to gain access to web application resources that should have been protected. Only security constraints with a URL pattern of the empty string were affected.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat",
        "commit": "723ea6a5bc5e7bc49e5ef84273c3b3c164a6a4fd",
        "method_before": "    public SecurityConstraint [] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        // Are there any defined security constraints?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        // Check each defined security constraint\n        String uri = request.getRequestPathMB().toString();\n        // Bug47080 - in rare cases this may be null\n        // Mapper treats as '/' do the same to prevent NPE\n        if (uri == null) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    if(uri.equals(patterns[k])) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            // No applicable security constraint was found\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n    }",
        "method_after": "    public SecurityConstraint [] findSecurityConstraints(Request request,\n                                                         Context context) {\n\n        ArrayList<SecurityConstraint> results = null;\n        // Are there any defined security constraints?\n        SecurityConstraint constraints[] = context.findConstraints();\n        if ((constraints == null) || (constraints.length == 0)) {\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraints defined\");\n            return null;\n        }\n\n        // Check each defined security constraint\n        String uri = request.getRequestPathMB().toString();\n        // Bug47080 - in rare cases this may be null or \"\"\n        // Mapper treats as '/' do the same to prevent NPE\n        if (uri == null || uri.length() == 0) {\n            uri = \"/\";\n        }\n\n        String method = request.getMethod();\n        int i;\n        boolean found = false;\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length; k++) {\n                    // Exact match including special case for the context root.\n                    if(uri.equals(patterns[k]) || patterns[k].length() == 0 && uri.equals(\"/\")) {\n                        found = true;\n                        if(collection[j].findMethod(method)) {\n                            if(results == null) {\n                                results = new ArrayList<>();\n                            }\n                            results.add(constraints[i]);\n                        }\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        int longest = -1;\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                int length = -1;\n                for(int k=0; k < patterns.length; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"/\") && pattern.endsWith(\"/*\") &&\n                       pattern.length() >= longest) {\n\n                        if(pattern.length() == 2) {\n                            matched = true;\n                            length = pattern.length();\n                        } else if(pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-1) ||\n                                  (pattern.length()-2 == uri.length() &&\n                                   pattern.regionMatches(0,uri,0,\n                                                        pattern.length()-2))) {\n                            matched = true;\n                            length = pattern.length();\n                        }\n                    }\n                }\n                if(matched) {\n                    if(length > longest) {\n                        found = false;\n                        if(results != null) {\n                            results.clear();\n                        }\n                        longest = length;\n                    }\n                    if(collection[j].findMethod(method)) {\n                        found = true;\n                        if(results == null) {\n                            results = new ArrayList<>();\n                        }\n                        results.add(constraints[i]);\n                    }\n                }\n            }\n        }\n\n        if(found) {\n            return  resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            boolean matched = false;\n            int pos = -1;\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.startsWith(\"*.\")){\n                        int slash = uri.lastIndexOf('/');\n                        int dot = uri.lastIndexOf('.');\n                        if(slash >= 0 && dot > slash &&\n                           dot != uri.length()-1 &&\n                           uri.length()-dot == pattern.length()-1) {\n                            if(pattern.regionMatches(1,uri,dot,uri.length()-dot)) {\n                                matched = true;\n                                pos = j;\n                            }\n                        }\n                    }\n                }\n            }\n            if(matched) {\n                found = true;\n                if(collection[pos].findMethod(method)) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(found) {\n            return resultsToArray(results);\n        }\n\n        for (i = 0; i < constraints.length; i++) {\n            SecurityCollection [] collection = constraints[i].findCollections();\n\n            // If collection is null, continue to avoid an NPE\n            // See Bugzilla 30624\n            if ( collection == null) {\n                continue;\n            }\n\n            if (log.isDebugEnabled()) {\n                log.debug(\"  Checking constraint '\" + constraints[i] +\n                    \"' against \" + method + \" \" + uri + \" --> \" +\n                    constraints[i].included(uri, method));\n            }\n\n            for(int j=0; j < collection.length; j++){\n                String [] patterns = collection[j].findPatterns();\n\n                // If patterns is null, continue to avoid an NPE\n                // See Bugzilla 30624\n                if ( patterns == null) {\n                    continue;\n                }\n\n                boolean matched = false;\n                for(int k=0; k < patterns.length && !matched; k++) {\n                    String pattern = patterns[k];\n                    if(pattern.equals(\"/\")){\n                        matched = true;\n                    }\n                }\n                if(matched) {\n                    if(results == null) {\n                        results = new ArrayList<>();\n                    }\n                    results.add(constraints[i]);\n                }\n            }\n        }\n\n        if(results == null) {\n            // No applicable security constraint was found\n            if (log.isDebugEnabled())\n                log.debug(\"  No applicable constraint located\");\n        }\n        return resultsToArray(results);\n    }"
    },
    {
        "idx": "890",
        "vuln_id": "CVE-2018-15801",
        "desc": "Spring Security versions 5.1.x prior to 5.1.2 contain an authorization bypass vulnerability during JWT issuer validation. In order to be impacted, the same private key for an honest issuer and a malicious user must be used when signing JWTs. In that case, a malicious user could fashion signed JWTs with the malicious issuer URL that may be granted for the honest issuer.",
        "cwe_id": "CWE-345",
        "cwe_name": "Insufficient Verification of Data Authenticity",
        "repo": "https://github.com/spring-projects/spring-security",
        "commit": "c70b65c5df0e170a2d34d812b83db0b7bc71ea25"
    },
    {
        "idx": "934",
        "vuln_id": "CVE-2018-5968",
        "desc": "FasterXML jackson-databind through 2.8.11 and 2.9.x through 2.9.3 allows unauthenticated remote code execution because of an incomplete fix for the CVE-2017-7525 and CVE-2017-17485 deserialization flaws. This is exploitable via two different gadgets that bypass a blacklist.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "038b471e2efde2e8f96b4e0be958d3e5a1ff1d0"
    },
    {
        "idx": "969",
        "vuln_id": "CVE-2018-8030",
        "desc": "A Denial of Service vulnerability was found in Apache Qpid Broker-J versions 7.0.0-7.0.4 when AMQP protocols 0-8, 0-9 or 0-91 are used to publish messages with size greater than allowed maximum message size limit (100MB by default). The broker crashes due to the defect. AMQP protocols 0-10 and 1.0 are not affected.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/apache/qpid-broker-j",
        "commit": "025b48f3193e2b10b1c41d2bc3bcfc9cfc238a27",
        "method_before": "    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            publishContentHeader(new ContentHeaderBody(properties, bodySize));\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }",
        "method_after": "    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            else\n            {\n                publishContentHeader(new ContentHeaderBody(properties, bodySize));\n            }\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }"
    },
    {
        "idx": "981",
        "vuln_id": "CVE-2018-8718",
        "desc": "Cross-site request forgery (CSRF) vulnerability in the Mailer Plugin 1.20 for Jenkins 2.111 allows remote authenticated users to send unauthorized mail as an arbitrary user via a /descriptorByName/hudson.tasks.Mailer/sendTestMail request.",
        "cwe_id": "CWE-352",
        "cwe_name": "Cross-Site Request Forgery (CSRF)",
        "repo": "https://github.com/jenkinsci/mailer-plugin",
        "commit": "98e79cf904769907f83894e29f50ed6b3e7eb135",
        "method_before": "        public DescriptorImpl() {\n            load();\n            DESCRIPTOR = this;\n        }\n\n        public String getDisplayName() {\n            return Messages.Mailer_DisplayName();\n        }\n\n        public String getDefaultSuffix() {\n            return defaultSuffix;\n        }\n\n        public String getReplyToAddress() {\n            return replyToAddress;\n        }\n\n        public void setReplyToAddress(String address) {\n            this.replyToAddress = Util.fixEmpty(address);\n        }\n\n        /** JavaMail session. */\n        public Session createSession() {\n            return createSession(smtpHost,smtpPort,useSsl,smtpAuthUsername,smtpAuthPassword);\n        }\n        private static Session createSession(String smtpHost, String smtpPort, boolean useSsl, String smtpAuthUserName, Secret smtpAuthPassword) {\n            smtpPort = fixEmptyAndTrim(smtpPort);\n            smtpAuthUserName = fixEmptyAndTrim(smtpAuthUserName);\n\n            Properties props = new Properties(System.getProperties());\n            if(fixEmptyAndTrim(smtpHost)!=null)\n                props.put(\"mail.smtp.host\",smtpHost);\n            if (smtpPort!=null) {\n                props.put(\"mail.smtp.port\", smtpPort);\n            }\n            if (useSsl) {\n            \t/* This allows the user to override settings by setting system properties but\n            \t * also allows us to use the default SMTPs port of 465 if no port is already set.\n            \t * It would be cleaner to use smtps, but that's done by calling session.getTransport()...\n            \t * and thats done in mail sender, and it would be a bit of a hack to get it all to\n            \t * coordinate, and we can make it work through setting mail.smtp properties.\n            \t */\n            \tif (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                    String port = smtpPort==null?\"465\":smtpPort;\n                    props.put(\"mail.smtp.port\", port);\n                    props.put(\"mail.smtp.socketFactory.port\", port);\n            \t}\n            \tif (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n            \t\tprops.put(\"mail.smtp.socketFactory.class\",\"javax.net.ssl.SSLSocketFactory\");\n            \t}\n\t\t\t\tprops.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\t\t\t}\n            if(smtpAuthUserName!=null)\n                props.put(\"mail.smtp.auth\",\"true\");\n\n            // avoid hang by setting some timeout. \n            props.put(\"mail.smtp.timeout\",\"60000\");\n            props.put(\"mail.smtp.connectiontimeout\",\"60000\");\n\n            return Session.getInstance(props,getAuthenticator(smtpAuthUserName,Secret.toString(smtpAuthPassword)));\n        }\n\n        private static Authenticator getAuthenticator(final String smtpAuthUserName, final String smtpAuthPassword) {\n            if(smtpAuthUserName==null)    return null;\n            return new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(smtpAuthUserName,smtpAuthPassword);\n                }\n            };\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject json) throws FormException {\n            // this code is brain dead\n            smtpHost = nullify(json.getString(\"smtpServer\"));\n            setReplyToAddress(json.getString(\"replyToAddress\"));\n\n            defaultSuffix = nullify(json.getString(\"defaultSuffix\"));\n\n            if(json.has(\"useSMTPAuth\")) {\n                JSONObject auth = json.getJSONObject(\"useSMTPAuth\");\n                smtpAuthUsername = nullify(auth.getString(\"smtpAuthUserName\"));\n                smtpAuthPassword = Secret.fromString(nullify(auth.getString(\"smtpAuthPasswordSecret\")));\n            } else {\n                smtpAuthUsername = null;\n                smtpAuthPassword = null;\n            }\n            smtpPort = nullify(json.getString(\"smtpPort\"));\n            useSsl = json.getBoolean(\"useSsl\");\n            charset = json.getString(\"charset\");\n            if (charset == null || charset.length() == 0)\n            \tcharset = \"UTF-8\";\n            \n            save();\n            return true;\n        }\n\n        private String nullify(String v) {\n            if(v!=null && v.length()==0)    v=null;\n            return v;\n        }\n\n        public String getSmtpServer() {\n            return smtpHost;\n        }\n\n        /**\n         * Method added to pass findbugs verification when compiling against 1.642.1\n         * @return The JenkinsLocationConfiguration object.\n         * @throws IllegalStateException if the object is not available (e.g., Jenkins not fully initialized).\n         */\n        @SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n            justification = \"False positive. See https://sourceforge.net/p/findbugs/bugs/1411/\")\n        private JenkinsLocationConfiguration getJenkinsLocationConfiguration() {\n            final JenkinsLocationConfiguration jlc = JenkinsLocationConfiguration.get();\n            if (jlc == null) {\n                throw new IllegalStateException(\"JenkinsLocationConfiguration not available\");\n            }\n            return jlc;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getAdminAddress() {\n            return getJenkinsLocationConfiguration().getAdminAddress();\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getUrl() {\n            return getJenkinsLocationConfiguration().getUrl();\n        }\n\n        public String getSmtpAuthUserName() {\n            return smtpAuthUsername;\n        }\n\n        public String getSmtpAuthPassword() {\n            if (smtpAuthPassword==null) return null;\n            return Secret.toString(smtpAuthPassword);\n        }\n\n        public Secret getSmtpAuthPasswordSecret() {\n            return smtpAuthPassword;\n        }\n\n        public boolean getUseSsl() {\n        \treturn useSsl;\n        }\n\n        public String getSmtpPort() {\n        \treturn smtpPort;\n        }\n        \n        public String getCharset() {\n        \tString c = charset;\n        \tif (c == null || c.length() == 0)\tc = \"UTF-8\";\n        \treturn c;\n        }\n\n        public void setDefaultSuffix(String defaultSuffix) {\n            this.defaultSuffix = defaultSuffix;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setHudsonUrl(String hudsonUrl) {\n            getJenkinsLocationConfiguration().setUrl(hudsonUrl);\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setAdminAddress(String adminAddress) {\n            getJenkinsLocationConfiguration().setAdminAddress(adminAddress);\n        }\n\n        public void setSmtpHost(String smtpHost) {\n            this.smtpHost = smtpHost;\n        }\n\n        public void setUseSsl(boolean useSsl) {\n            this.useSsl = useSsl;\n        }\n\n        public void setSmtpPort(String smtpPort) {\n            this.smtpPort = smtpPort;\n        }\n        \n        public void setCharset(String chaset) {\n            this.charset = chaset;\n        }\n\n        public void setSmtpAuth(String userName, String password) {\n            this.smtpAuthUsername = userName;\n            this.smtpAuthPassword = Secret.fromString(password);\n        }\n\n        @Override\n        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            Mailer m = (Mailer)super.newInstance(req, formData);\n\n            if(hudsonUrl==null) {\n                // if Hudson URL is not configured yet, infer some default\n                hudsonUrl = Functions.inferHudsonURL(req);\n                save();\n            }\n\n            return m;\n        }\n\n        public FormValidation doAddressCheck(@QueryParameter String value) {\n            try {\n                new InternetAddress(value);\n                return FormValidation.ok();\n            } catch (AddressException e) {\n                return FormValidation.error(e.getMessage());\n            }\n        }\n\n        public FormValidation doCheckSmtpServer(@QueryParameter String value) {\n            try {\n                if (fixEmptyAndTrim(value)!=null)\n                    InetAddress.getByName(value);\n                return FormValidation.ok();\n            } catch (UnknownHostException e) {\n                return FormValidation.error(Messages.Mailer_Unknown_Host_Name()+value);\n            }\n        }\n\n        public FormValidation doCheckDefaultSuffix(@QueryParameter String value) {\n            if (value.matches(\"@[A-Za-z0-9.\\\\-]+\") || fixEmptyAndTrim(value)==null)\n                return FormValidation.ok();\n            else\n                return FormValidation.error(Messages.Mailer_Suffix_Error());\n        }\n\n        /**\n         * Send an email to the admin address\n         * @throws IOException\n         * @throws ServletException\n         * @throws InterruptedException\n         */\n        public FormValidation doSendTestMail(\n                @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n            try {\n                // TODO 1.590+ Jenkins.getActiveInstance\n                final Jenkins jenkins = Jenkins.getInstance();\n                if (jenkins == null) {\n                    throw new IOException(\"Jenkins instance is not ready\");\n                }\n                \n                if (!useSMTPAuth) {\n                    smtpAuthUserName = null;\n                    smtpAuthPasswordSecret = null;\n                }\n                \n                MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                msg.setFrom(stringToAddress(adminAddress, charset));\n                if (StringUtils.isNotBlank(replyToAddress)) {\n                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                }\n                msg.setSentDate(new Date());\n                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n\n                Transport.send(msg);                \n                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n            } catch (MessagingException e) {\n                return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n            }\n        }",
        "method_after": "        public DescriptorImpl() {\n            load();\n            DESCRIPTOR = this;\n        }\n\n        public String getDisplayName() {\n            return Messages.Mailer_DisplayName();\n        }\n\n        public String getDefaultSuffix() {\n            return defaultSuffix;\n        }\n\n        public String getReplyToAddress() {\n            return replyToAddress;\n        }\n\n        public void setReplyToAddress(String address) {\n            this.replyToAddress = Util.fixEmpty(address);\n        }\n\n        /** JavaMail session. */\n        public Session createSession() {\n            return createSession(smtpHost,smtpPort,useSsl,smtpAuthUsername,smtpAuthPassword);\n        }\n        private static Session createSession(String smtpHost, String smtpPort, boolean useSsl, String smtpAuthUserName, Secret smtpAuthPassword) {\n            smtpPort = fixEmptyAndTrim(smtpPort);\n            smtpAuthUserName = fixEmptyAndTrim(smtpAuthUserName);\n\n            Properties props = new Properties(System.getProperties());\n            if(fixEmptyAndTrim(smtpHost)!=null)\n                props.put(\"mail.smtp.host\",smtpHost);\n            if (smtpPort!=null) {\n                props.put(\"mail.smtp.port\", smtpPort);\n            }\n            if (useSsl) {\n            \t/* This allows the user to override settings by setting system properties but\n            \t * also allows us to use the default SMTPs port of 465 if no port is already set.\n            \t * It would be cleaner to use smtps, but that's done by calling session.getTransport()...\n            \t * and thats done in mail sender, and it would be a bit of a hack to get it all to\n            \t * coordinate, and we can make it work through setting mail.smtp properties.\n            \t */\n            \tif (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                    String port = smtpPort==null?\"465\":smtpPort;\n                    props.put(\"mail.smtp.port\", port);\n                    props.put(\"mail.smtp.socketFactory.port\", port);\n            \t}\n            \tif (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n            \t\tprops.put(\"mail.smtp.socketFactory.class\",\"javax.net.ssl.SSLSocketFactory\");\n            \t}\n\t\t\t\tprops.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\t\t\t}\n            if(smtpAuthUserName!=null)\n                props.put(\"mail.smtp.auth\",\"true\");\n\n            // avoid hang by setting some timeout. \n            props.put(\"mail.smtp.timeout\",\"60000\");\n            props.put(\"mail.smtp.connectiontimeout\",\"60000\");\n\n            return Session.getInstance(props,getAuthenticator(smtpAuthUserName,Secret.toString(smtpAuthPassword)));\n        }\n\n        private static Authenticator getAuthenticator(final String smtpAuthUserName, final String smtpAuthPassword) {\n            if(smtpAuthUserName==null)    return null;\n            return new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(smtpAuthUserName,smtpAuthPassword);\n                }\n            };\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject json) throws FormException {\n            // this code is brain dead\n            smtpHost = nullify(json.getString(\"smtpServer\"));\n            setReplyToAddress(json.getString(\"replyToAddress\"));\n\n            defaultSuffix = nullify(json.getString(\"defaultSuffix\"));\n\n            if(json.has(\"useSMTPAuth\")) {\n                JSONObject auth = json.getJSONObject(\"useSMTPAuth\");\n                smtpAuthUsername = nullify(auth.getString(\"smtpAuthUserName\"));\n                smtpAuthPassword = Secret.fromString(nullify(auth.getString(\"smtpAuthPasswordSecret\")));\n            } else {\n                smtpAuthUsername = null;\n                smtpAuthPassword = null;\n            }\n            smtpPort = nullify(json.getString(\"smtpPort\"));\n            useSsl = json.getBoolean(\"useSsl\");\n            charset = json.getString(\"charset\");\n            if (charset == null || charset.length() == 0)\n            \tcharset = \"UTF-8\";\n            \n            save();\n            return true;\n        }\n\n        private String nullify(String v) {\n            if(v!=null && v.length()==0)    v=null;\n            return v;\n        }\n\n        public String getSmtpServer() {\n            return smtpHost;\n        }\n\n        /**\n         * Method added to pass findbugs verification when compiling against 1.642.1\n         * @return The JenkinsLocationConfiguration object.\n         * @throws IllegalStateException if the object is not available (e.g., Jenkins not fully initialized).\n         */\n        @SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n            justification = \"False positive. See https://sourceforge.net/p/findbugs/bugs/1411/\")\n        private JenkinsLocationConfiguration getJenkinsLocationConfiguration() {\n            final JenkinsLocationConfiguration jlc = JenkinsLocationConfiguration.get();\n            if (jlc == null) {\n                throw new IllegalStateException(\"JenkinsLocationConfiguration not available\");\n            }\n            return jlc;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getAdminAddress() {\n            return getJenkinsLocationConfiguration().getAdminAddress();\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getUrl() {\n            return getJenkinsLocationConfiguration().getUrl();\n        }\n\n        public String getSmtpAuthUserName() {\n            return smtpAuthUsername;\n        }\n\n        public String getSmtpAuthPassword() {\n            if (smtpAuthPassword==null) return null;\n            return Secret.toString(smtpAuthPassword);\n        }\n\n        public Secret getSmtpAuthPasswordSecret() {\n            return smtpAuthPassword;\n        }\n\n        public boolean getUseSsl() {\n        \treturn useSsl;\n        }\n\n        public String getSmtpPort() {\n        \treturn smtpPort;\n        }\n        \n        public String getCharset() {\n        \tString c = charset;\n        \tif (c == null || c.length() == 0)\tc = \"UTF-8\";\n        \treturn c;\n        }\n\n        public void setDefaultSuffix(String defaultSuffix) {\n            this.defaultSuffix = defaultSuffix;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setHudsonUrl(String hudsonUrl) {\n            getJenkinsLocationConfiguration().setUrl(hudsonUrl);\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setAdminAddress(String adminAddress) {\n            getJenkinsLocationConfiguration().setAdminAddress(adminAddress);\n        }\n\n        public void setSmtpHost(String smtpHost) {\n            this.smtpHost = smtpHost;\n        }\n\n        public void setUseSsl(boolean useSsl) {\n            this.useSsl = useSsl;\n        }\n\n        public void setSmtpPort(String smtpPort) {\n            this.smtpPort = smtpPort;\n        }\n        \n        public void setCharset(String chaset) {\n            this.charset = chaset;\n        }\n\n        public void setSmtpAuth(String userName, String password) {\n            this.smtpAuthUsername = userName;\n            this.smtpAuthPassword = Secret.fromString(password);\n        }\n\n        @Override\n        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            Mailer m = (Mailer)super.newInstance(req, formData);\n\n            if(hudsonUrl==null) {\n                // if Hudson URL is not configured yet, infer some default\n                hudsonUrl = Functions.inferHudsonURL(req);\n                save();\n            }\n\n            return m;\n        }\n\n        public FormValidation doAddressCheck(@QueryParameter String value) {\n            try {\n                new InternetAddress(value);\n                return FormValidation.ok();\n            } catch (AddressException e) {\n                return FormValidation.error(e.getMessage());\n            }\n        }\n\n        public FormValidation doCheckSmtpServer(@QueryParameter String value) {\n            try {\n                if (fixEmptyAndTrim(value)!=null)\n                    InetAddress.getByName(value);\n                return FormValidation.ok();\n            } catch (UnknownHostException e) {\n                return FormValidation.error(Messages.Mailer_Unknown_Host_Name()+value);\n            }\n        }\n\n        public FormValidation doCheckDefaultSuffix(@QueryParameter String value) {\n            if (value.matches(\"@[A-Za-z0-9.\\\\-]+\") || fixEmptyAndTrim(value)==null)\n                return FormValidation.ok();\n            else\n                return FormValidation.error(Messages.Mailer_Suffix_Error());\n        }\n\n        /**\n         * Send an email to the admin address\n         * @throws IOException\n         * @throws ServletException\n         * @throws InterruptedException\n         */\n        @RequirePOST\n        public FormValidation doSendTestMail(\n                @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n            try {\n                // TODO 1.590+ Jenkins.getActiveInstance\n                final Jenkins jenkins = Jenkins.getInstance();\n                if (jenkins == null) {\n                    throw new IOException(\"Jenkins instance is not ready\");\n                }\n\n                jenkins.checkPermission(Jenkins.ADMINISTER);\n                \n                if (!useSMTPAuth) {\n                    smtpAuthUserName = null;\n                    smtpAuthPasswordSecret = null;\n                }\n                \n                MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                msg.setFrom(stringToAddress(adminAddress, charset));\n                if (StringUtils.isNotBlank(replyToAddress)) {\n                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                }\n                msg.setSentDate(new Date());\n                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n\n                Transport.send(msg);                \n                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n            } catch (MessagingException e) {\n                return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n            }\n        }"
    },
    {
        "idx": "1064",
        "vuln_id": "CVE-2019-3775",
        "desc": "Cloud Foundry UAA, versions prior to v70.0, allows a user to update their own email address. A remote authenticated user can impersonate a different user by changing their email address to that of a different user.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/cloudfoundry/uaa",
        "commit": "daeedbe499453b06856556f5e9f7e80d2d1ceb03",
        "method_before": "    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }",
        "method_after": "    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getEmails().containsAll(scimUserFromRequest.getEmails())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }"
    },
    {
        "idx": "1195",
        "vuln_id": "HTTPCLIENT-1803",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/httpcomponents-client",
        "commit": "0554271750599756d4946c0d7ba43d04b1a7b22"
    },
    {
        "idx": "1352",
        "vuln_id": "CVE-2017-2600",
        "desc": "In jenkins before versions 2.44, 2.32.2 node monitor data could be viewed by low privilege users via the remote API. These included system configuration and runtime information of these nodes (SECURITY-343).",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "0f92cd08a19207de2cceb6a2f4e3e9f92fdc0899"
    },
    {
        "idx": "1508",
        "vuln_id": "CVE-2019-17531",
        "desc": "A Polymorphic Typing issue was discovered in FasterXML jackson-databind 2.0.0 through 2.9.10. When Default Typing is enabled (either globally or for a specific property) for an externally exposed JSON endpoint and the service has the apache-log4j-extra (version 1.2.x) jar in the classpath, and an attacker can provide a JNDI service to access, it is possible to make the service execute a malicious payload.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "b5a304a98590b6bb766134f9261e6566dcbbb6d0"
    },
    {
        "idx": "1520",
        "vuln_id": "CVE-2019-19999",
        "desc": "Halo before 1.2.0-beta.1 allows Server Side Template Injection (SSTI) because TemplateClassResolver.SAFER_RESOLVER is not used in the FreeMarker configuration.",
        "cwe_id": "CWE-918",
        "cwe_name": "Server-Side Request Forgery (SSRF)",
        "repo": "https://github.com/halo-dev/halo",
        "commit": "dc3a73ee02ca183c509dedf703db28c80219c41c",
        "method_before": "    public FreeMarkerConfigurer freemarkerConfig(HaloProperties haloProperties) throws IOException, TemplateException {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPaths(FILE_PROTOCOL + haloProperties.getWorkDir() + \"templates/\", \"classpath:/templates/\");\n        configurer.setDefaultEncoding(\"UTF-8\");\n\n        Properties properties = new Properties();\n        properties.setProperty(\"auto_import\", \"/common/macro/common_macro.ftl as common,/common/macro/global_macro.ftl as global\");\n\n        configurer.setFreemarkerSettings(properties);\n\n        // Predefine configuration\n        freemarker.template.Configuration configuration = configurer.createConfiguration();\n        if (haloProperties.isProductionEnv()) {\n            configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n        }\n\n        // Set predefined freemarker configuration\n        configurer.setConfiguration(configuration);\n\n        return configurer;\n    }",
        "method_after": "    public FreeMarkerConfigurer freemarkerConfig(HaloProperties haloProperties) throws IOException, TemplateException {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPaths(FILE_PROTOCOL + haloProperties.getWorkDir() + \"templates/\", \"classpath:/templates/\");\n        configurer.setDefaultEncoding(\"UTF-8\");\n\n        Properties properties = new Properties();\n        properties.setProperty(\"auto_import\", \"/common/macro/common_macro.ftl as common,/common/macro/global_macro.ftl as global\");\n\n        configurer.setFreemarkerSettings(properties);\n\n        // Predefine configuration\n        freemarker.template.Configuration configuration = configurer.createConfiguration();\n\n        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n\n        if (haloProperties.isProductionEnv()) {\n            configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n        }\n\n        // Set predefined freemarker configuration\n        configurer.setConfiguration(configuration);\n\n        return configurer;\n    }"
    },
    {
        "idx": "1527",
        "vuln_id": "CVE-2019-3559",
        "desc": "Java Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00.",
        "cwe_id": "CWE-755",
        "cwe_name": "Improper Handling of Exceptional Conditions",
        "repo": "https://github.com/facebook/fbthrift",
        "commit": "a56346ceacad28bf470017a6bda1d5518d0bd943",
        "method_before": "  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      break;\n    }\n  }",
        "method_after": "  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      {\n        throw new TProtocolException(\n              TProtocolException.INVALID_DATA, \"Invalid type encountered during skipping: \" + type);\n      }\n    }\n  }"
    },
    {
        "idx": "1536",
        "vuln_id": "CVE-2020-10673",
        "desc": "['FasterXML jackson-databind 2.x before 2.9.10.4 mishandles the interaction between serialization gadgets and typing, related to com.caucho.config.types.ResourceRef (aka caucho-quercus).']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "1645efbd392989cf015f459a91c999e59c921b15"
    },
    {
        "idx": "1582",
        "vuln_id": "CVE-2020-35490",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.8 mishandles the interaction between serialization gadgets and typing, related to org.apache.commons.dbcp2.datasources.PerUserPoolDataSource.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "41b8bdb5ccc1d8edb71acf1c8234da235a24249d"
    },
    {
        "idx": "1583",
        "vuln_id": "CVE-2020-35728",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.8 mishandles the interaction between serialization gadgets and typing, related to com.oracle.wls.shaded.org.apache.xalan.lib.sql.JNDIConnectionPool (aka embedded Xalan in org.glassfish.web/javax.servlet.jsp.jstl).",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "1ca0388c2fb37ac6a06f1c188ae89c41e3e15e84"
    },
    {
        "idx": "1714",
        "vuln_id": "unknown-194",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/hadoop",
        "commit": "f382602de1860791c30cf6e24effc35aed4d9447"
    },
    {
        "idx": "1738",
        "vuln_id": "unknown-215",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/primefaces/primefaces",
        "commit": "a65c775f937d3802ddfe3f4f631a698d4f420bcb"
    },
    {
        "idx": "1757",
        "vuln_id": "unknown-232",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/qpid-broker-j",
        "commit": "a4c8ecf0ac4884f63cfd57c07c12a144863c896c",
        "method_before": "    public byte[] evaluateResponse(byte[] response) throws SaslException\n    {\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            throw new SaslException(\"Invalid PLAIN encoding, authzid null terminator not found\");\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            throw new SaslException(\"Invalid PLAIN encoding, authcid null terminator not found\");\n        }\n\n        PlainPasswordCallback passwordCb;\n        AuthorizeCallback authzCb;\n\n        try\n        {\n            // we do not currently support authcid in any meaningful way\n            String authzid = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, \"utf8\");\n\n            // TODO: should not get pwd as a String but as a char array...\n            int passwordLen = response.length - authcidNullPosition - 1;\n            String pwd = new String(response, authcidNullPosition + 1, passwordLen, \"utf8\");\n\n            // we do not care about the prompt but it throws if null\n            NameCallback nameCb = new NameCallback(\"prompt\", authzid);\n            passwordCb = new PlainPasswordCallback(\"prompt\", false, pwd);\n            authzCb = new AuthorizeCallback(authzid, authzid);\n\n            Callback[] callbacks = new Callback[]{nameCb, passwordCb, authzCb};\n            _cbh.handle(callbacks);\n\n        }\n        catch (IOException e)\n        {\n            if(e instanceof SaslException)\n            {\n                throw (SaslException) e;\n            }\n            throw new SaslException(\"Error processing data: \" + e, e);\n        }\n        catch (UnsupportedCallbackException e)\n        {\n            throw new SaslException(\"Unable to obtain data from callback handler: \" + e, e);\n        }\n\n        if (passwordCb.isAuthenticated())\n        {\n            _complete = true;\n        }\n\n        if (authzCb.isAuthorized() && _complete)\n        {\n            _authorizationId = authzCb.getAuthenticationID();\n            return null;\n        }\n        else\n        {\n            throw new SaslException(\"Authentication failed\");\n        }\n    }",
        "method_after": "    public byte[] evaluateResponse(byte[] response) throws SaslException\n    {\n        int authzidNullPosition = findNullPosition(response, 0);\n        if (authzidNullPosition < 0)\n        {\n            throw new SaslException(\"Invalid PLAIN encoding, authzid null terminator not found\");\n        }\n        int authcidNullPosition = findNullPosition(response, authzidNullPosition + 1);\n        if (authcidNullPosition < 0)\n        {\n            throw new SaslException(\"Invalid PLAIN encoding, authcid null terminator not found\");\n        }\n\n        PlainPasswordCallback passwordCb;\n        AuthorizeCallback authzCb;\n\n        try\n        {\n            // we do not currently support authcid in any meaningful way\n            String authzid = new String(response, authzidNullPosition + 1, authcidNullPosition - authzidNullPosition - 1, \"utf8\");\n\n            // TODO: should not get pwd as a String but as a char array...\n            int passwordLen = response.length - authcidNullPosition - 1;\n            String pwd = new String(response, authcidNullPosition + 1, passwordLen, \"utf8\");\n\n            // we do not care about the prompt but it throws if null\n            NameCallback nameCb = new NameCallback(\"prompt\", authzid);\n            passwordCb = new PlainPasswordCallback(\"prompt\", false, pwd);\n            authzCb = new AuthorizeCallback(authzid, authzid);\n\n            Callback[] callbacks = new Callback[]{nameCb, passwordCb, authzCb};\n            _cbh.handle(callbacks);\n\n        }\n        catch (IOException e)\n        {\n            if(e instanceof SaslException)\n            {\n                throw (SaslException) e;\n            }\n            throw new SaslException(\"Error processing data: \" + e, e);\n        }\n        catch (UnsupportedCallbackException e)\n        {\n            throw new SaslException(\"Unable to obtain data from callback handler: \" + e, e);\n        }\n        catch (IllegalArgumentException e)\n        {\n            throw new SaslException(\"Error processing SASL response: \" + e.getMessage(), e);\n        }\n\n        if (passwordCb.isAuthenticated())\n        {\n            _complete = true;\n        }\n\n        if (authzCb.isAuthorized() && _complete)\n        {\n            _authorizationId = authzCb.getAuthenticationID();\n            return null;\n        }\n        else\n        {\n            throw new SaslException(\"Authentication failed\");\n        }\n    }"
    },
    {
        "idx": "1779",
        "vuln_id": "unknown-252",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/cloudfoundry-incubator/credhub",
        "commit": "c6ad2d65ff4adb3a62625791392e39e4dde1aa7d",
        "method_before": "  public KMSEncryptionProvider(final EncryptionConfiguration configuration) {\n    super();\n\n    setChannelInfo();\n\n    SslContext sslContext;\n    try {\n      sslContext = GrpcSslContexts.forClient()\n        .trustManager(new ByteArrayInputStream(configuration.getCa().getBytes(StringUtil.UTF_8)))\n        .build();\n    } catch (SSLException e) {\n      throw new RuntimeException(e);\n    }\n\n    blockingStub = KeyManagementServiceGrpc.newBlockingStub(\n      NettyChannelBuilder.forAddress(new DomainSocketAddress(configuration.getEndpoint()))\n        .eventLoopGroup(group)\n        .channelType(channelType)\n        .keepAliveTime(GrpcUtil.DEFAULT_KEEPALIVE_TIME_NANOS, TimeUnit.NANOSECONDS)\n        .useTransportSecurity()\n        .sslContext(sslContext)\n        .overrideAuthority(configuration.getHost())\n        .build());\n  }",
        "method_after": "  public KMSEncryptionProvider(final EncryptionConfiguration configuration) {\n    super();\n\n    setChannelInfo();\n\n    SslContext sslContext;\n    try {\n      sslContext = GrpcSslContexts.forClient()\n        .trustManager(new ByteArrayInputStream(configuration.getCa().getBytes(StringUtil.UTF_8)))\n        .build();\n    } catch (SSLException e) {\n      throw new RuntimeException(e);\n    }\n\n    blockingStub = KeyManagementServiceGrpc.newBlockingStub(\n      NettyChannelBuilder.forAddress(new DomainSocketAddress(configuration.getEndpoint()))\n        .eventLoopGroup(group)\n        .channelType(channelType)\n        .keepAliveTime(DEFAULT_KEEPALIVE_TIMEOUT_NANOS, TimeUnit.NANOSECONDS)\n        .useTransportSecurity()\n        .sslContext(sslContext)\n        .overrideAuthority(configuration.getHost())\n        .build());\n  }"
    },
    {
        "idx": "1795",
        "vuln_id": "unknown-267",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/ranger",
        "commit": "93116a1c69dc795746b350dd12c94ddbe0e89fe2",
        "method_before": "\tpublic void start() {\n\t\tfinal Tomcat server = new Tomcat();\n\n\t\tString logDir =  null;\n\t\tlogDir = getConfig(\"logdir\");\n\t\tif (logDir == null) {\n\t\t\tlogDir = getConfig(\"kms.log.dir\");\n\t\t}\n\t\tString servername = getConfig(\"servername\");\n\t\tString hostName = getConfig(\"ranger.service.host\");\n\t\tint serverPort = getIntConfig(\"ranger.service.http.port\", 6181);\n\t\tint sslPort = getIntConfig(\"ranger.service.https.port\", -1);\n\t\tint shutdownPort = getIntConfig(\"ranger.service.shutdown.port\",DEFAULT_SHUTDOWN_PORT);\n\t\tString shutdownCommand = getConfig(\"ranger.service.shutdown.command\",DEFAULT_SHUTDOWN_COMMAND);\n\n\t\tserver.setHostname(hostName);\n\t\tserver.setPort(serverPort);\n\t\tserver.getServer().setPort(shutdownPort);\n\t\tserver.getServer().setShutdown(shutdownCommand);\n\n\t\tboolean isHttpsEnabled = Boolean.valueOf(getConfig(\"ranger.service.https.attrib.ssl.enabled\", \"false\"));\n\t\tboolean ajpEnabled = Boolean.valueOf(getConfig(\"ajp.enabled\", \"false\"));\n\n\t\tif (ajpEnabled) {\n\n\t\t\tConnector ajpConnector = new Connector(\n\t\t\t\t\t\"org.apache.coyote.ajp.AjpNioProtocol\");\n\t\t\tajpConnector.setPort(serverPort);\n\t\t\tajpConnector.setProperty(\"protocol\", \"AJP/1.3\");\n\n\t\t\tserver.getService().addConnector(ajpConnector);\n\n\t\t\t// Making this as a default connector\n\t\t\tserver.setConnector(ajpConnector);\n\t\t\tLOG.info(\"Created AJP Connector\");\n\t\t} else if ((sslPort > 0) && isHttpsEnabled) {\n\t\t\tConnector ssl = new Connector();\n\t\t\tssl.setPort(sslPort);\n\t\t\tssl.setSecure(true);\n\t\t\tssl.setScheme(\"https\");\n\t\t\tssl.setAttribute(\"SSLEnabled\", \"true\");\n\t\t\tssl.setAttribute(\"sslProtocol\", getConfig(\"ranger.service.https.attrib.ssl.protocol\", \"TLS\"));\n\t\t\tString clientAuth=getConfig(\"ranger.service.https.attrib.clientAuth\", \"false\");\n\t\t\tif(\"false\".equalsIgnoreCase(clientAuth)){\n\t\t\t\tclientAuth=getConfig(\"ranger.service.https.attrib.client.auth\", \"want\");\n\t\t\t}\n\t\t\tssl.setAttribute(\"clientAuth\",clientAuth);\n\t\t\tString providerPath=getConfig(\"ranger.credential.provider.path\");\n\t\t\tString keyAlias= getConfig(\"ranger.service.https.attrib.keystore.credential.alias\",\"keyStoreCredentialAlias\");\n\t\t\tString keystorePass=null;\n\t\t\tif(providerPath!=null && keyAlias!=null){\n\t\t\t\tkeystorePass=getDecryptedString(providerPath.trim(), keyAlias.trim());\n\t\t\t\tif(keystorePass==null || keystorePass.trim().isEmpty() || \"none\".equalsIgnoreCase(keystorePass.trim())){\n\t\t\t\t\tkeystorePass=getConfig(\"ranger.service.https.attrib.keystore.pass\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl.setAttribute(\"keyAlias\", getConfig(\"ranger.service.https.attrib.keystore.keyalias\",\"rangeradmin\"));\n\t\t\tssl.setAttribute(\"keystorePass\", keystorePass);\n\t\t\tssl.setAttribute(\"keystoreFile\", getKeystoreFile());\n\t\t\t\n                        String defaultEnabledProtocols = \"SSLv2Hello, TLSv1, TLSv1.1, TLSv1.2\";\n                        String enabledProtocols = getConfig(\"ranger.service.https.attrib.ssl.enabled.protocols\", defaultEnabledProtocols);\n\t\t\tssl.setAttribute(\"sslEnabledProtocols\", enabledProtocols);\n\t\t\tString ciphers = getConfig(\"ranger.tomcat.ciphers\");\n\t\t\tif (ciphers != null && ciphers.trim() != null && ciphers.trim().length() > 0) {\n\t\t\t\tssl.setAttribute(\"ciphers\", ciphers);\n\t\t\t}\n\t\t\tserver.getService().addConnector(ssl);\n\n\t\t\t//\n\t\t\t// Making this as a default connector\n\t\t\t//\n\t\t\tserver.setConnector(ssl);\n\t\t\t\n\t\t}\n\t\tupdateHttpConnectorAttribConfig(server);\n\t\t\n\t\tFile logDirectory = new File(logDir);\n\t\tif (!logDirectory.exists()) {\n\t\t\tlogDirectory.mkdirs();\n\t\t}\n\t\t\n\t\tAccessLogValve valve = new AccessLogValve();\n\t\tvalve.setRotatable(true);\n\t\tvalve.setAsyncSupported(true);\n\t\tvalve.setBuffered(false);\n\t\tvalve.setEnabled(true);\n\t\tvalve.setFileDateFormat(getConfig(\"ranger.accesslog.dateformat\", \"yyyy-MM-dd.HH\"));\n\t\tvalve.setDirectory(logDirectory.getAbsolutePath());\n\t\tvalve.setSuffix(\".log\");\n\t\t\n\t\tString logPattern = getConfig(\"ranger.accesslog.pattern\", \"%h %l %u %t \\\"%r\\\" %s %b\");\n\t\tvalve.setPattern(logPattern);\t\n\t\t\t\t\n\t\tserver.getHost().getPipeline().addValve(valve);\n\t\t\n\t\ttry {\n\t\t\tString webapp_dir = getConfig(\"xa.webapp.dir\");\n\t\t\tif (webapp_dir == null || webapp_dir.trim().isEmpty()) {\n\t\t\t\t// If webapp location property is not set, then let's derive\n\t\t\t\t// from catalina_base\n\t\t\t\tString catalina_base = getConfig(\"catalina.base\");\n\t\t\t\tif (catalina_base == null || catalina_base.trim().isEmpty()) {\n\t\t\t\t\tLOG.severe(\"Tomcat Server failed to start: catalina.base and/or xa.webapp.dir is not set\");\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t\twebapp_dir = catalina_base + File.separator + \"webapp\";\n\t\t\t\tLOG.info(\"Deriving webapp folder from catalina.base property. folder=\"\n\t\t\t\t\t\t+ webapp_dir);\n\t\t\t}\n\t\t\t\n\t\t\t//String webContextName = getConfig(\"xa.webapp.contextName\", \"/\");\n\t\t\tString webContextName = getConfig(\"ranger.contextName\", \"/\");\n\t\t\tif (webContextName == null) {\n\t\t\t\twebContextName = \"/\";\n\t\t\t} else if (!webContextName.startsWith(\"/\")) {\n\t\t\t\tLOG.info(\"Context Name [\" + webContextName\n\t\t\t\t\t\t+ \"] is being loaded as [ /\" + webContextName + \"]\");\n\t\t\t\twebContextName = \"/\" + webContextName;\n\t\t\t}\n\t\t\t\n\t\t\tFile wad = new File(webapp_dir);\n\t\t\tif (wad.isDirectory()) {\n\t\t\t\tLOG.info(\"Webapp file =\" + webapp_dir + \", webAppName = \"\n\t\t\t\t\t\t+ webContextName);\n\t\t\t} else if (wad.isFile()) {\n\t\t\t\tFile webAppDir = new File(DEFAULT_WEBAPPS_ROOT_FOLDER);\n\t\t\t\tif (!webAppDir.exists()) {\n\t\t\t\t\twebAppDir.mkdirs();\n\t\t\t\t}\n\t\t\t\tLOG.info(\"Webapp file =\" + webapp_dir + \", webAppName = \"\n\t\t\t\t\t\t+ webContextName);\n\t\t\t}\n\t\t\tLOG.info(\"Adding webapp [\" + webContextName + \"] = path [\"\n\t\t\t\t\t+ webapp_dir + \"] .....\");\n\t\t\tContext webappCtx = server.addWebapp(webContextName, new File(\n\t\t\t\t\twebapp_dir).getAbsolutePath());\n\t\t\twebappCtx.init();\n\t\t\tLOG.info(\"Finished init of webapp [\" + webContextName\n\t\t\t\t\t+ \"] = path [\" + webapp_dir + \"].\");\n\t\t} catch (ServletException e1) {\n\t\t\tLOG.severe(\"Tomcat Server failed to add webapp:\" + e1.toString());\n\t\t\te1.printStackTrace();\n\t\t} catch (LifecycleException lce) {\n\t\t\tLOG.severe(\"Tomcat Server failed to start webapp:\" + lce.toString());\n\t\t\tlce.printStackTrace();\n\t\t}\n\t\t\n\t\tif (servername.equalsIgnoreCase(ADMIN_SERVER_NAME)) {\n\t\t\tString keytab = getConfig(ADMIN_USER_KEYTAB);\n\t\t\tString principal = null;\n\t\t\ttry {\n\t\t\t\tprincipal = SecureClientLogin.getPrincipal(getConfig(ADMIN_USER_PRINCIPAL), hostName);\n\t\t\t} catch (IOException ignored) {\n\t\t\t\tLOG.warning(\"Failed to get ranger.admin.kerberos.principal. Reason: \" + ignored.toString());\n\t\t\t}\n\t\t\tString nameRules = getConfig(ADMIN_NAME_RULES);\n\t\t\tif (nameRules == null || nameRules.length() == 0) {\n\t\t\t\tLOG.info(\"Name is empty. Setting Name Rule as 'DEFAULT'\");\n\t\t\t\tnameRules = DEFAULT_NAME_RULE;\n\t\t\t}\n\t\t\tif (getConfig(AUTHENTICATION_TYPE) != null\n\t\t\t\t\t&& getConfig(AUTHENTICATION_TYPE).trim().equalsIgnoreCase(AUTH_TYPE_KERBEROS)\n\t\t\t\t\t&& SecureClientLogin.isKerberosCredentialExists(principal,keytab)) {\n\t\t\t\ttry{\n\t\t\t\t\tLOG.info(\"Provided Kerberos Credential : Principal = \"\n\t\t\t\t\t\t\t+ principal + \" and Keytab = \" + keytab);\n\t\t\t\t\tSubject sub = SecureClientLogin.loginUserFromKeytab(principal, keytab, nameRules);\n\t\t\t\t\tSubject.doAs(sub, new PrivilegedAction<Void>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Void run() {\n\t\t\t\t\t\t\tLOG.info(\"Starting Server using kerberos credential\");\n\t\t\t\t\t\t\tstartServer(server);\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.severe(\"Tomcat Server failed to start:\" + e.toString());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartServer(server);\n\t\t\t}\n\t\t} else {\n\t\t\tstartServer(server);\n\t\t}\n\t}",
        "method_after": "\tpublic void start() {\n\t\tfinal Tomcat server = new Tomcat();\n\n\t\tString logDir =  null;\n\t\tlogDir = getConfig(\"logdir\");\n\t\tif (logDir == null) {\n\t\t\tlogDir = getConfig(\"kms.log.dir\");\n\t\t}\n\t\tString servername = getConfig(\"servername\");\n\t\tString hostName = getConfig(\"ranger.service.host\");\n\t\tint serverPort = getIntConfig(\"ranger.service.http.port\", 6181);\n\t\tint sslPort = getIntConfig(\"ranger.service.https.port\", -1);\n\t\tint shutdownPort = getIntConfig(\"ranger.service.shutdown.port\",DEFAULT_SHUTDOWN_PORT);\n\t\tString shutdownCommand = getConfig(\"ranger.service.shutdown.command\",DEFAULT_SHUTDOWN_COMMAND);\n\n\t\tserver.setHostname(hostName);\n\t\tserver.setPort(serverPort);\n\t\tserver.getServer().setPort(shutdownPort);\n\t\tserver.getServer().setShutdown(shutdownCommand);\n\n\t\tboolean isHttpsEnabled = Boolean.valueOf(getConfig(\"ranger.service.https.attrib.ssl.enabled\", \"false\"));\n\t\tboolean ajpEnabled = Boolean.valueOf(getConfig(\"ajp.enabled\", \"false\"));\n\n\t\tif (ajpEnabled) {\n\n\t\t\tConnector ajpConnector = new Connector(\n\t\t\t\t\t\"org.apache.coyote.ajp.AjpNioProtocol\");\n\t\t\tajpConnector.setPort(serverPort);\n\t\t\tajpConnector.setProperty(\"protocol\", \"AJP/1.3\");\n\n\t\t\tserver.getService().addConnector(ajpConnector);\n\n\t\t\t// Making this as a default connector\n\t\t\tserver.setConnector(ajpConnector);\n\t\t\tLOG.info(\"Created AJP Connector\");\n\t\t} else if ((sslPort > 0) && isHttpsEnabled) {\n\t\t\tConnector ssl = new Connector();\n\t\t\tssl.setPort(sslPort);\n\t\t\tssl.setSecure(true);\n\t\t\tssl.setScheme(\"https\");\n\t\t\tssl.setAttribute(\"SSLEnabled\", \"true\");\n\t\t\tssl.setAttribute(\"sslProtocol\", getConfig(\"ranger.service.https.attrib.ssl.protocol\", \"TLS\"));\n\t\t\tString clientAuth=getConfig(\"ranger.service.https.attrib.clientAuth\", \"false\");\n\t\t\tif(\"false\".equalsIgnoreCase(clientAuth)){\n\t\t\t\tclientAuth=getConfig(\"ranger.service.https.attrib.client.auth\", \"want\");\n\t\t\t}\n\t\t\tssl.setAttribute(\"clientAuth\",clientAuth);\n\t\t\tString providerPath=getConfig(\"ranger.credential.provider.path\");\n\t\t\tString keyAlias= getConfig(\"ranger.service.https.attrib.keystore.credential.alias\",\"keyStoreCredentialAlias\");\n\t\t\tString keystorePass=null;\n\t\t\tif(providerPath!=null && keyAlias!=null){\n\t\t\t\tkeystorePass=getDecryptedString(providerPath.trim(), keyAlias.trim());\n\t\t\t\tif(keystorePass==null || keystorePass.trim().isEmpty() || \"none\".equalsIgnoreCase(keystorePass.trim())){\n\t\t\t\t\tkeystorePass=getConfig(\"ranger.service.https.attrib.keystore.pass\");\n\t\t\t\t}\n\t\t\t}\n\t\t\tssl.setAttribute(\"keyAlias\", getConfig(\"ranger.service.https.attrib.keystore.keyalias\",\"rangeradmin\"));\n\t\t\tssl.setAttribute(\"keystorePass\", keystorePass);\n\t\t\tssl.setAttribute(\"keystoreFile\", getKeystoreFile());\n\t\t\t\n                        String defaultEnabledProtocols = \"SSLv2Hello, TLSv1, TLSv1.1, TLSv1.2\";\n                        String enabledProtocols = getConfig(\"ranger.service.https.attrib.ssl.enabled.protocols\", defaultEnabledProtocols);\n\t\t\tssl.setAttribute(\"sslEnabledProtocols\", enabledProtocols);\n\t\t\tString ciphers = getConfig(\"ranger.tomcat.ciphers\");\n\t\t\tif (ciphers != null && ciphers.trim() != null && ciphers.trim().length() > 0) {\n\t\t\t\tssl.setAttribute(\"ciphers\", ciphers);\n\t\t\t}\n\t\t\tserver.getService().addConnector(ssl);\n\n\t\t\t//\n\t\t\t// Making this as a default connector\n\t\t\t//\n\t\t\tserver.setConnector(ssl);\n\t\t\t\n\t\t}\n\t\tupdateHttpConnectorAttribConfig(server);\n\t\t\n\t\tFile logDirectory = new File(logDir);\n\t\tif (!logDirectory.exists()) {\n\t\t\tlogDirectory.mkdirs();\n\t\t}\n\t\t\n\t\tAccessLogValve valve = new AccessLogValve();\n\t\tvalve.setRotatable(true);\n\t\tvalve.setAsyncSupported(true);\n\t\tvalve.setBuffered(false);\n\t\tvalve.setEnabled(true);\n\t\tvalve.setFileDateFormat(getConfig(\"ranger.accesslog.dateformat\", \"yyyy-MM-dd.HH\"));\n\t\tvalve.setDirectory(logDirectory.getAbsolutePath());\n\t\tvalve.setSuffix(\".log\");\n\t\t\n\t\tString logPattern = getConfig(\"ranger.accesslog.pattern\", \"%h %l %u %t \\\"%r\\\" %s %b\");\n\t\tvalve.setPattern(logPattern);\t\n\t\t\t\t\n\t\tserver.getHost().getPipeline().addValve(valve);\n\t\t\n\t\ttry {\n\t\t\tString webapp_dir = getConfig(\"xa.webapp.dir\");\n\t\t\tif (webapp_dir == null || webapp_dir.trim().isEmpty()) {\n\t\t\t\t// If webapp location property is not set, then let's derive\n\t\t\t\t// from catalina_base\n\t\t\t\tString catalina_base = getConfig(\"catalina.base\");\n\t\t\t\tif (catalina_base == null || catalina_base.trim().isEmpty()) {\n\t\t\t\t\tLOG.severe(\"Tomcat Server failed to start: catalina.base and/or xa.webapp.dir is not set\");\n\t\t\t\t\tSystem.exit(1);\n\t\t\t\t}\n\t\t\t\twebapp_dir = catalina_base + File.separator + \"webapp\";\n\t\t\t\tLOG.info(\"Deriving webapp folder from catalina.base property. folder=\"\n\t\t\t\t\t\t+ webapp_dir);\n\t\t\t}\n\t\t\t\n\t\t\t//String webContextName = getConfig(\"xa.webapp.contextName\", \"/\");\n\t\t\tString webContextName = getConfig(\"ranger.contextName\", \"/\");\n\t\t\tif (webContextName == null) {\n\t\t\t\twebContextName = \"/\";\n\t\t\t} else if (!webContextName.startsWith(\"/\")) {\n\t\t\t\tLOG.info(\"Context Name [\" + webContextName\n\t\t\t\t\t\t+ \"] is being loaded as [ /\" + webContextName + \"]\");\n\t\t\t\twebContextName = \"/\" + webContextName;\n\t\t\t}\n\t\t\t\n\t\t\tFile wad = new File(webapp_dir);\n\t\t\tif (wad.isDirectory()) {\n\t\t\t\tLOG.info(\"Webapp file =\" + webapp_dir + \", webAppName = \"\n\t\t\t\t\t\t+ webContextName);\n\t\t\t} else if (wad.isFile()) {\n\t\t\t\tFile webAppDir = new File(DEFAULT_WEBAPPS_ROOT_FOLDER);\n\t\t\t\tif (!webAppDir.exists()) {\n\t\t\t\t\twebAppDir.mkdirs();\n\t\t\t\t}\n\t\t\t\tLOG.info(\"Webapp file =\" + webapp_dir + \", webAppName = \"\n\t\t\t\t\t\t+ webContextName);\n\t\t\t}\n\t\t\tLOG.info(\"Adding webapp [\" + webContextName + \"] = path [\"\n\t\t\t\t\t+ webapp_dir + \"] .....\");\n\t\t\tContext webappCtx = server.addWebapp(webContextName, new File(\n\t\t\t\t\twebapp_dir).getAbsolutePath());\n\t\t\twebappCtx.init();\n\t\t\tLOG.info(\"Finished init of webapp [\" + webContextName\n\t\t\t\t\t+ \"] = path [\" + webapp_dir + \"].\");\n\t\t} catch (LifecycleException lce) {\n\t\t\tLOG.severe(\"Tomcat Server failed to start webapp:\" + lce.toString());\n\t\t\tlce.printStackTrace();\n\t\t}\n\t\t\n\t\tif (servername.equalsIgnoreCase(ADMIN_SERVER_NAME)) {\n\t\t\tString keytab = getConfig(ADMIN_USER_KEYTAB);\n\t\t\tString principal = null;\n\t\t\ttry {\n\t\t\t\tprincipal = SecureClientLogin.getPrincipal(getConfig(ADMIN_USER_PRINCIPAL), hostName);\n\t\t\t} catch (IOException ignored) {\n\t\t\t\tLOG.warning(\"Failed to get ranger.admin.kerberos.principal. Reason: \" + ignored.toString());\n\t\t\t}\n\t\t\tString nameRules = getConfig(ADMIN_NAME_RULES);\n\t\t\tif (nameRules == null || nameRules.length() == 0) {\n\t\t\t\tLOG.info(\"Name is empty. Setting Name Rule as 'DEFAULT'\");\n\t\t\t\tnameRules = DEFAULT_NAME_RULE;\n\t\t\t}\n\t\t\tif (getConfig(AUTHENTICATION_TYPE) != null\n\t\t\t\t\t&& getConfig(AUTHENTICATION_TYPE).trim().equalsIgnoreCase(AUTH_TYPE_KERBEROS)\n\t\t\t\t\t&& SecureClientLogin.isKerberosCredentialExists(principal,keytab)) {\n\t\t\t\ttry{\n\t\t\t\t\tLOG.info(\"Provided Kerberos Credential : Principal = \"\n\t\t\t\t\t\t\t+ principal + \" and Keytab = \" + keytab);\n\t\t\t\t\tSubject sub = SecureClientLogin.loginUserFromKeytab(principal, keytab, nameRules);\n\t\t\t\t\tSubject.doAs(sub, new PrivilegedAction<Void>() {\n\t\t\t\t\t\t@Override\n\t\t\t\t\t\tpublic Void run() {\n\t\t\t\t\t\t\tLOG.info(\"Starting Server using kerberos credential\");\n\t\t\t\t\t\t\tstartServer(server);\n\t\t\t\t\t\t\treturn null;\n\t\t\t\t\t\t}\n\t\t\t\t\t});\n\t\t\t\t} catch (Exception e) {\n\t\t\t\t\tLOG.severe(\"Tomcat Server failed to start:\" + e.toString());\n\t\t\t\t\te.printStackTrace();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tstartServer(server);\n\t\t\t}\n\t\t} else {\n\t\t\tstartServer(server);\n\t\t}\n\t}"
    },
    {
        "idx": "309",
        "vuln_id": "CVE-2015-1772",
        "desc": "The LDAP implementation in HiveServer2 in Apache Hive before 1.0.1 and 1.1.x before 1.1.1, as used in IBM InfoSphere BigInsights 3.0, 3.0.0.1, and 3.0.0.2 and other products, mishandles simple unauthenticated and anonymous bind configurations, which allows remote attackers to bypass authentication via a crafted LDAP request.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/apache/hive",
        "commit": "6929846a8120eaf094b914b4ca8af80b65f891c8",
        "method_before": "  public void Authenticate(String user, String password) throws AuthenticationException {\n\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n    env.put(Context.PROVIDER_URL, ldapURL);\n\n    // If the domain is available in the config, then append it unless domain is\n    // already part of the username. LDAP providers like Active Directory use a\n    // fully qualified user name like foo@bar.com.\n    if (!hasDomain(user) && ldapDomain != null) {\n      user  = user + \"@\" + ldapDomain;\n    }\n\n    // setup the security principal\n    String bindDN;\n    if (baseDN == null) {\n      bindDN = user;\n    } else {\n      bindDN = \"uid=\" + user + \",\" + baseDN;\n    }\n    env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n    env.put(Context.SECURITY_PRINCIPAL, bindDN);\n    env.put(Context.SECURITY_CREDENTIALS, password);\n\n    try {\n      // Create initial context\n      Context ctx = new InitialDirContext(env);\n      ctx.close();\n    } catch (NamingException e) {\n      throw new AuthenticationException(\"Error validating LDAP user\", e);\n    }\n  }",
        "method_after": "  public void Authenticate(String user, String password) throws AuthenticationException {\n\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n    env.put(Context.PROVIDER_URL, ldapURL);\n\n    // If the domain is available in the config, then append it unless domain is\n    // already part of the username. LDAP providers like Active Directory use a\n    // fully qualified user name like foo@bar.com.\n    if (!hasDomain(user) && ldapDomain != null) {\n      user  = user + \"@\" + ldapDomain;\n    }\n\n    if (password == null || password.isEmpty()) {\n      throw new AuthenticationException(\"Error validating LDAP user:\" +\n          \" a null or blank password has been provided\");\n    }\n\n    // setup the security principal\n    String bindDN;\n    if (baseDN == null) {\n      bindDN = user;\n    } else {\n      bindDN = \"uid=\" + user + \",\" + baseDN;\n    }\n    env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n    env.put(Context.SECURITY_PRINCIPAL, bindDN);\n    env.put(Context.SECURITY_CREDENTIALS, password);\n\n    try {\n      // Create initial context\n      Context ctx = new InitialDirContext(env);\n      ctx.close();\n    } catch (NamingException e) {\n      throw new AuthenticationException(\"Error validating LDAP user\", e);\n    }\n  }"
    },
    {
        "idx": "497",
        "vuln_id": "CVE-2016-6809",
        "desc": "Apache Tika before 1.14 allows Java code execution for serialized objects embedded in MATLAB files. The issue exists because Tika invokes JMatIO to do native deserialization.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/apache/tika",
        "commit": "8a68b5d474205cc91cbbb610d4a1c05af57f0610"
    },
    {
        "idx": "546",
        "vuln_id": "CVE-2017-1000395",
        "desc": "Jenkins 2.73.1 and earlier, 2.83 and earlier provides information about Jenkins user accounts which is generally available to anyone with Overall/Read permissions via the /user/(username)/api remote API. This included e.g. Jenkins users' email addresses if the Mailer Plugin is installed. The remote API now no longer includes information beyond the most basic (user ID and name) unless the user requesting it is a Jenkins administrator.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "7b1f8e96a8d97dd09e5e093fcdb010b3295acc77",
        "method_before": "    public List<UserProperty> getAllProperties() {\n        return Collections.unmodifiableList(properties);\n    }",
        "method_after": "    public List<UserProperty> getAllProperties() {\n        if (hasPermission(Jenkins.ADMINISTER)) {\n            return Collections.unmodifiableList(properties);\n        }\n\n        return Collections.emptyList();\n    }"
    },
    {
        "idx": "594",
        "vuln_id": "CVE-2017-13098",
        "desc": "BouncyCastle TLS prior to version 1.0.3, when configured to use the JCE (Java Cryptography Extension) for cryptographic functions, provides a weak Bleichenbacher oracle when any TLS cipher suite using RSA key exchange is negotiated. An attacker can recover the private key from a vulnerable application. This vulnerability is referred to as \"ROBOT.\"",
        "cwe_id": "CWE-203",
        "cwe_name": "Observable Discrepancy",
        "repo": "https://github.com/bcgit/bc-java",
        "commit": "a00b684465b38d722ca9a3543b8af8568e6bad5c"
    },
    {
        "idx": "660",
        "vuln_id": "CVE-2017-5650",
        "desc": "In Apache Tomcat 9.0.0.M1 to 9.0.0.M18 and 8.5.0 to 8.5.12, the handling of an HTTP/2 GOAWAY frame for a connection did not close streams associated with that connection that were currently waiting for a WINDOW_UPDATE before allowing the application to write more data. These waiting streams each consumed a thread. A malicious client could therefore construct a series of HTTP/2 requests that would consume all available processing threads.",
        "cwe_id": "CWE-404",
        "cwe_name": "Improper Resource Shutdown or Release",
        "repo": "https://github.com/apache/tomcat",
        "commit": "5496e193a89b8b8b3177e516358df2f07ab852b3",
        "method_before": "    private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }",
        "method_after": "    private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        for (Stream stream : streams.values()) {\n            // The connection is closing. Close the associated streams as no\n            // longer required.\n            stream.receiveReset(Http2Error.CANCEL.getCode());\n        }\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }"
    },
    {
        "idx": "777",
        "vuln_id": "CVE-2018-11758",
        "desc": "This affects Apache Cayenne 4.1.M1, 3.2.M1, 4.0.M2 to 4.0.M5, 4.0.B1, 4.0.B2, 4.0.RC1, 3.1, 3.1.1, 3.1.2. CayenneModeler is a desktop GUI tool shipped with Apache Cayenne and intended for editing Cayenne ORM models stored as XML files. If an attacker tricks a user of CayenneModeler into opening a malicious XML file, the attacker will be able to instruct the XML parser built into CayenneModeler to transfer files from a local machine to a remote machine controlled by the attacker. The cause of the issue is XML parser processing XML External Entity (XXE) declarations included in XML. The vulnerability is addressed in Cayenne by disabling XXE processing in all operations that require XML parsing.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/apache/cayenne",
        "commit": "6fc896b65ed871be33dcf453cde924bf73cf83db",
        "method_before": "\tpublic static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\n\t\t// Create a JAXP SAXParser\n\t\tSAXParser saxParser = spf.newSAXParser();\n\n\t\t// Get the encapsulated SAX XMLReader\n\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t// set default features\n\t\treader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\treturn reader;\n\t}",
        "method_after": "\tpublic static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\t// Create a JAXP SAXParser\n\t\tSAXParser saxParser = spf.newSAXParser();\n\n\t\t// Get the encapsulated SAX XMLReader\n\t\treturn saxParser.getXMLReader();\n\t}"
    },
    {
        "idx": "873",
        "vuln_id": "CVE-2018-1336",
        "desc": "An improper handing of overflow in the UTF-8 decoder with supplementary characters can lead to an infinite loop in the decoder causing a Denial of Service. Versions Affected: Apache Tomcat 9.0.0.M9 to 9.0.7, 8.5.0 to 8.5.30, 8.0.0.RC1 to 8.0.51, and 7.0.28 to 7.0.86.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "92cd494555598e99dd691712e8ee426a2f9c2e93",
        "method_before": "    private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                // If first byte is invalid, tail will be set to -1\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                // Additional checks to detect invalid sequences ASAP\n                // Checks derived from Unicode 6.2, Chapter 3, Table 3-7\n                // Check 2nd byte\n                int tailAvailable = inIndexLimit - inIndex - 1;\n                if (tailAvailable > 0) {\n                    // First byte C2..DF, second byte 80..BF\n                    if (jchar > 0x41 && jchar < 0x60 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E0, second byte A0..BF\n                    if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E1..EC, second byte 80..BF\n                    if (jchar > 0x60 && jchar < 0x6D &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte ED, second byte 80..9F\n                    if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte EE..EF, second byte 80..BF\n                    if (jchar > 0x6D && jchar < 0x70 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F0, second byte 90..BF\n                    if (jchar == 0x70 &&\n                            ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                            (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F1..F3, second byte 80..BF\n                    if (jchar > 0x70 && jchar < 0x74 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F4, second byte 80..8F\n                    if (jchar == 0x74 &&\n                            (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                }\n                // Check third byte if present and expected\n                if (tailAvailable > 1 && tail > 1) {\n                    if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(2);\n                    }\n                }\n                // Check fourth byte if present and expected\n                if (tailAvailable > 2 && tail > 2) {\n                    if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(3);\n                    }\n                }\n                if (tailAvailable < tail) {\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                CoderResult.OVERFLOW :\n                CoderResult.UNDERFLOW;\n    }",
        "method_after": "    private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                // If first byte is invalid, tail will be set to -1\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                // Additional checks to detect invalid sequences ASAP\n                // Checks derived from Unicode 6.2, Chapter 3, Table 3-7\n                // Check 2nd byte\n                int tailAvailable = inIndexLimit - inIndex - 1;\n                if (tailAvailable > 0) {\n                    // First byte C2..DF, second byte 80..BF\n                    if (jchar > 0x41 && jchar < 0x60 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E0, second byte A0..BF\n                    if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E1..EC, second byte 80..BF\n                    if (jchar > 0x60 && jchar < 0x6D &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte ED, second byte 80..9F\n                    if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte EE..EF, second byte 80..BF\n                    if (jchar > 0x6D && jchar < 0x70 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F0, second byte 90..BF\n                    if (jchar == 0x70 &&\n                            ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                            (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F1..F3, second byte 80..BF\n                    if (jchar > 0x70 && jchar < 0x74 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F4, second byte 80..8F\n                    if (jchar == 0x74 &&\n                            (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                }\n                // Check third byte if present and expected\n                if (tailAvailable > 1 && tail > 1) {\n                    if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(2);\n                    }\n                }\n                // Check fourth byte if present and expected\n                if (tailAvailable > 2 && tail > 2) {\n                    if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(3);\n                    }\n                }\n                if (tailAvailable < tail) {\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    // Encoded with 4 bytes. inIndex currently points\n                    // to the final byte. Move it back to first byte.\n                    inIndex -= 3;\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                CoderResult.OVERFLOW :\n                CoderResult.UNDERFLOW;\n    }"
    },
    {
        "idx": "905",
        "vuln_id": "CVE-2018-17201",
        "desc": "['Certain input files could make the code hang when Apache Sanselan 0.97-incubator was used to parse them, which could be used in a DoS attack. Note that Apache Sanselan (incubating) was renamed to Apache Commons Imaging.']",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/commons-imaging",
        "commit": "f5574bfe285edd79207fe8c30f53cb0af06e26bb",
        "method_before": "    private static void decompress(final InputStream in, final byte[] out)\n            throws IOException {\n        int position = 0;\n        final int total = out.length;\n\n        while (position < total) {\n            final int n = in.read();\n\n            if (n > 128) {\n                final int value = in.read();\n\n                for (int i = 0; i < (n & 0x7f); i++) {\n                    out[position++] = (byte) value;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    out[position++] = (byte) in.read();\n                }\n            }\n        }\n    }",
        "method_after": "    private static void decompress(final InputStream in, final byte[] out)\n            throws IOException,ImageReadException {\n        int position = 0;\n        final int total = out.length;\n\n        while (position < total) {\n            final int n = in.read();\n\n            if (n < 0) {\n                throw new ImageReadException(\"Error decompressing RGBE file\");\n            }\n\n            if (n > 128) {\n                final int value = in.read();\n\n                for (int i = 0; i < (n & 0x7f); i++) {\n                    out[position++] = (byte) value;\n                }\n            } else {\n                for (int i = 0; i < n; i++) {\n                    out[position++] = (byte) in.read();\n                }\n            }\n        }\n    }"
    },
    {
        "idx": "916",
        "vuln_id": "CVE-2018-19859",
        "desc": "OpenRefine before 3.2 beta allows directory traversal via a relative pathname in a ZIP archive.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/OpenRefine/OpenRefine",
        "commit": "e243e73e4064de87a913946bd320fbbe246da656",
        "method_before": "    static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }",
        "method_after": "    static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);     \n        // For CVE-2018-19859, issue #1840\n        if (!file.toPath().normalize().startsWith(dir.toPath().normalize())) {\n        \tthrow new IllegalArgumentException(\"Zip archives with files escaping their root directory are not allowed.\");\n        }\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }"
    },
    {
        "idx": "1015",
        "vuln_id": "CVE-2019-10219",
        "desc": "A vulnerability was found in Hibernate-Validator. The SafeHtml validator annotation fails to properly sanitize payloads consisting of potentially malicious code in HTML comments and instructions. This vulnerability can result in an XSS attack.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/hibernate/hibernate-validator",
        "commit": "124b7dd6d9a4ad24d4d49f74701f05a13e56ceee",
        "method_before": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}",
        "method_after": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tList<Node> childNodes = fragment.childNodes();\n\t\tfor ( Node node : childNodes ) {\n\t\t\tdocument.body().appendChild( node.clone() );\n\t\t}\n\n\t\treturn document;\n\t}"
    },
    {
        "idx": "1026",
        "vuln_id": "CVE-2019-10770",
        "desc": "All versions of io.ratpack:ratpack-core from 0.9.10 inclusive and before 1.7.6 are vulnerable to Cross-site Scripting (XSS). This affects the development mode error handler when an exception message contains untrusted data. Note the production mode error handler is not vulnerable - so for this to be utilized in production it would require users to not disable development mode.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/ratpack/ratpack",
        "commit": "a3cbb13be1527874528c3b99fc33517c0297b6d3"
    },
    {
        "idx": "1037",
        "vuln_id": "CVE-2019-12395",
        "desc": "In Webbukkit Dynmap 3.0-beta-3 or below, due to a missing login check in servlet/MapStorageHandler.java, an attacker can see a map image without login even if victim enables login-required in setting.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/webbukkit/dynmap",
        "commit": "641f142cd3ccdcbfb04eda3059be22dd9ed93783"
    },
    {
        "idx": "1473",
        "vuln_id": "CVE-2019-14892",
        "desc": "A flaw was discovered in jackson-databind in versions before 2.9.10, 2.8.11.5 and 2.6.7.3, where it would permit polymorphic deserialization of a malicious object using commons-configuration 1 and 2 JNDI classes. An attacker could use this flaw to execute arbitrary code.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "41b7f9b90149e9d44a65a8261a8deedc7186f6af"
    },
    {
        "idx": "1587",
        "vuln_id": "CVE-2020-36184",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.8 mishandles the interaction between serialization gadgets and typing, related to org.apache.tomcat.dbcp.dbcp2.datasources.PerUserPoolDataSource.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "567194c53ae91f0a14dc27239afb739b1c10448a"
    },
    {
        "idx": "1588",
        "vuln_id": "CVE-2020-36186",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.8 mishandles the interaction between serialization gadgets and typing, related to org.apache.tomcat.dbcp.dbcp.datasources.PerUserPoolDataSource.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "3e8fa3beea49ea62109df9e643c9cb678dabdde1"
    },
    {
        "idx": "1589",
        "vuln_id": "CVE-2020-36188",
        "desc": "FasterXML jackson-databind 2.x before 2.9.10.8 mishandles the interaction between serialization gadgets and typing, related to com.newrelic.agent.deps.ch.qos.logback.core.db.JNDIConnectionSource.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "33d96c13fe18a2dad01b19ce195548c9acea9da4"
    },
    {
        "idx": "1603",
        "vuln_id": "CVE-2021-21244",
        "desc": "OneDev is an all-in-one devops platform. In OneDev before version 4.0.3, There is a vulnerability that enabled pre-auth server side template injection via Bean validation message tampering. Full details in the reference GHSA. This issue was fixed in 4.0.3 by disabling validation interpolation completely.",
        "cwe_id": "CWE-94",
        "cwe_name": "Improper Control of Generation of Code ('Code Injection')",
        "repo": "https://github.com/theonedev/onedev",
        "commit": "4f5dc6fb9e50f2c41c4929b0d8c5824b2cca3d65",
        "method_before": "\t\tsuper.configure();\n\t\t\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\n\t\t\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\n\t\t\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\n\n\t\t\t@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation.byDefaultProvider().configure();\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}\n\t\t\t\n\t\t}).in(Singleton.class);\n\t\t\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\n\n\t\t// configure markdown\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\t\t\n\t\t\n\t\tconfigurePersistence();\n\t\tconfigureRestServices();\n\t\tconfigureWeb();\n\t\tconfigureBuild();\n\t\t\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\n\n\t\t/*\n\t\t * Declare bindings explicitly instead of using ImplementedBy annotation as\n\t\t * HK2 to guice bridge can only search in explicit bindings in Guice   \n\t\t */\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\n\t\tbind(PullRequestNotificationManager.class);\n\t\tbind(CommitNotificationManager.class);\n\t\tbind(BuildNotificationManager.class);\n\t\tbind(IssueNotificationManager.class);\n\t\tbind(EntityReferenceManager.class);\n\t\tbind(CodeCommentNotificationManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\n\t\tbind(Session.class).toProvider(SessionProvider.class);\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\n\t\tbind(WebHookManager.class);\n\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\n\t    \n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\n\t\tbind(BasicAuthenticationFilter.class);\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\n\t\tbind(ShiroFilter.class);\n\t\tinstall(new ShiroAopModule());\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\n\n            @Override\n            public void configure(FilterChainManager filterChainManager) {\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\n            }\n            \n        });\n        contributeFromPackage(Authenticator.class, Authenticator.class);\n        \n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\n\n\t\t\t@Override\n\t\t\tpublic Class<?> getAbstractClass() {\n\t\t\t\treturn JobExecutor.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Collection<Class<?>> getImplementations() {\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\n        \n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\n\t\t\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\n\t\t\n\t\tbind(GitFilter.class);\n\t\tbind(GitPreReceiveCallback.class);\n\t\tbind(GitPostReceiveCallback.class);\n\t\t\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\n\n\t\t\t@Override\n\t\t\tpublic ExecutorService get() {\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, \n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t\tif (!isShutdown())\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t        };\n\t\t\t}\n\t    \t\n\t    }).in(Singleton.class);\n\t    \n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\n\n\t\t\t@Override\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable task) {\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, \n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t    });\n\t}",
        "method_after": "\t\tsuper.configure();\n\t\t\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\n\t\t\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\n\t\t\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\n\n\t\t\t@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation\n\t\t\t\t\t\t.byDefaultProvider()\n\t\t\t\t\t\t.configure()\n\t\t\t\t\t\t.messageInterpolator(new ParameterMessageInterpolator());\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}\n\t\t\t\n\t\t}).in(Singleton.class);\n\t\t\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\n\n\t\t// configure markdown\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\t\t\n\t\t\n\t\tconfigurePersistence();\n\t\tconfigureRestServices();\n\t\tconfigureWeb();\n\t\tconfigureBuild();\n\t\t\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\n\n\t\t/*\n\t\t * Declare bindings explicitly instead of using ImplementedBy annotation as\n\t\t * HK2 to guice bridge can only search in explicit bindings in Guice   \n\t\t */\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\n\t\tbind(PullRequestNotificationManager.class);\n\t\tbind(CommitNotificationManager.class);\n\t\tbind(BuildNotificationManager.class);\n\t\tbind(IssueNotificationManager.class);\n\t\tbind(EntityReferenceManager.class);\n\t\tbind(CodeCommentNotificationManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\n\t\tbind(Session.class).toProvider(SessionProvider.class);\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\n\t\tbind(WebHookManager.class);\n\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\n\t    \n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\n\t\tbind(BasicAuthenticationFilter.class);\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\n\t\tbind(ShiroFilter.class);\n\t\tinstall(new ShiroAopModule());\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\n\n            @Override\n            public void configure(FilterChainManager filterChainManager) {\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\n            }\n            \n        });\n        contributeFromPackage(Authenticator.class, Authenticator.class);\n        \n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\n\n\t\t\t@Override\n\t\t\tpublic Class<?> getAbstractClass() {\n\t\t\t\treturn JobExecutor.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Collection<Class<?>> getImplementations() {\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\n        \n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\n\t\t\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\n\t\t\n\t\tbind(GitFilter.class);\n\t\tbind(GitPreReceiveCallback.class);\n\t\tbind(GitPostReceiveCallback.class);\n\t\t\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\n\n\t\t\t@Override\n\t\t\tpublic ExecutorService get() {\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, \n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t\tif (!isShutdown())\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t        };\n\t\t\t}\n\t    \t\n\t    }).in(Singleton.class);\n\t    \n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\n\n\t\t\t@Override\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable task) {\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, \n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t    });\n\t}"
    },
    {
        "idx": "1647",
        "vuln_id": "unknown-133",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/kiegroup/jbpm-designer",
        "commit": "b422cb462ffed496a93c017bb5519adfd84c4584",
        "method_before": "\tpublic JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}",
        "method_after": "\tpublic JBPMBpmn2ResourceImpl(URI uri) {\n\t\tsuper(uri);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DEFER_IDREF_RESOLUTION, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_DISABLE_NOTIFY, true);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_USE_XML_NAME_TO_FEATURE_MAP, xmlNameToFeatureMap);\n\n        // Switch off DTD external entity processing\n        Map parserFeatures = new HashMap();\n        parserFeatures.put(\"http://xml.org/sax/features/external-general-entities\", false);\n        this.getDefaultLoadOptions().put(XMLResource.OPTION_PARSER_FEATURES, parserFeatures);\n\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_ENCODING, \"UTF-8\");\n        this.getDefaultSaveOptions().put(XMLResource.OPTION_PROCESS_DANGLING_HREF, XMLResource.OPTION_PROCESS_DANGLING_HREF_DISCARD);\n\t}"
    },
    {
        "idx": "1652",
        "vuln_id": "unknown-138",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/halo-dev/halo",
        "commit": "f4c2ca2f8d313f4ce4f6393f8b625790d8c71d50",
        "method_before": "    public static Path tryToSkipZipParentFolder(@NonNull Path unzippedPath) throws IOException {\n        Assert.notNull(unzippedPath, \"Unzipped folder must not be  null\");\n\n        // TODO May cause a latent problem.\n        try (Stream<Path> pathStream = Files.list(unzippedPath)) {\n            List<Path> childrenPath = pathStream.collect(Collectors.toList());\n\n            if (childrenPath.size() == 1 && Files.isDirectory(childrenPath.get(0))) {\n                return childrenPath.get(0);\n            }\n            return unzippedPath;\n        }\n    }",
        "method_after": "    public static Path tryToSkipZipParentFolder(@NonNull Path unzippedPath) throws IOException {\n        Assert.notNull(unzippedPath, \"Unzipped folder must not be  null\");\n\n        // TODO May cause a latent problem.\n        try (Stream<Path> pathStream = Files.list(unzippedPath)) {\n            List<Path> childrenPath = pathStream.collect(Collectors.toList());\n\n            Path realPath = childrenPath.get(0);\n            if (childrenPath.size() == 1 && Files.isDirectory(realPath)) {\n                // Check directory traversal\n                checkDirectoryTraversal(unzippedPath, realPath);\n                return realPath;\n            }\n            return unzippedPath;\n        }\n    }"
    },
    {
        "idx": "1702",
        "vuln_id": "unknown-183",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/skywalking",
        "commit": "5197004d083fdc44112856e871afe6c4e61ba7a7"
    },
    {
        "idx": "1703",
        "vuln_id": "unknown-184",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/FasterXML/jackson-databind",
        "commit": "d30f036208ab1c60bd5ce429cb4f7f1a3e5682e8"
    },
    {
        "idx": "1715",
        "vuln_id": "unknown-195",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "ef28732262e2ef2eda6e61c2672e1d25602c662a",
        "method_before": "    public EncounterDetailSubmissionElement(FormEntryContext context, Map<String, Object> parameters) {\n\n        // Register Date and Time widgets, if appropriate\n        if (Boolean.TRUE.equals(parameters.get(\"date\"))) {\n\n            dateWidget = new DateWidget();\n            dateErrorWidget = new ErrorWidget();\n\n            if (context.getExistingEncounter() != null) {\n                dateWidget.setInitialValue(context.getExistingEncounter().getEncounterDatetime());\n            } else if (parameters.get(\"defaultDate\") != null) {\n                dateWidget.setInitialValue(parameters.get(\"defaultDate\"));\n            }\n\n            if (parameters.get(\"disallowMultipleEncountersOnDate\") != null\n                    && StringUtils.hasText((String) parameters.get(\"disallowMultipleEncountersOnDate\"))) {\n                dateWidget.setOnChangeFunction(\"existingEncounterOnDate(this, '\"\n                        + parameters.get(\"disallowMultipleEncountersOnDate\") + \"') \");\n            }\n\n            if (\"true\".equals(parameters.get(\"showTime\"))) {\n                timeWidget = new TimeWidget();\n                timeErrorWidget = new ErrorWidget();\n                if (context.getExistingEncounter() != null) {\n                    timeWidget.setInitialValue(context.getExistingEncounter().getEncounterDatetime());\n                } else if (parameters.get(\"defaultDate\") != null) {\n                    timeWidget.setInitialValue(parameters.get(\"defaultDate\"));\n                }\n                context.registerWidget(timeWidget);\n                context.registerErrorWidget(timeWidget, timeErrorWidget);\n            }\n            context.registerWidget(dateWidget);\n            context.registerErrorWidget(dateWidget, dateErrorWidget);\n\n            if (\"hidden\".equals(parameters.get(\"widget\"))) {\n                dateWidget.setHidden(true);\n                if (timeWidget != null) {\n                    timeWidget.setHidden(true);\n                }\n            }\n        }\n\n        // Register Provider widgets, if appropriate\n        if (Boolean.TRUE.equals(parameters.get(\"provider\"))) {\n\n            if (\"autocomplete\".equals(parameters.get(\"type\"))) {\n                providerWidget = new AutocompleteWidget(Person.class);\n            }else{\n                providerWidget = new DropdownWidget();\n            }\n            providerErrorWidget = new ErrorWidget();\n\n            List<Option> providerOptions = new ArrayList<Option>();\n            // If specific persons are specified, display only those persons in order\n            String personsParam = (String) parameters.get(\"persons\");\n            if (personsParam != null) {\n                for (String s : personsParam.split(\",\")) {\n                    Person p = HtmlFormEntryUtil.getPerson(s);\n                    if (p == null) {\n                        throw new RuntimeException(\"Cannot find Person: \" + s);\n                    }\n                    String label = p.getPersonName().getFullName();\n                    providerOptions.add(new Option(label, p.getId().toString(), false));\n                }\n                removeNonProviders(providerOptions);\n            }\n\n            // Only if specific person ids are not passed in do we get by user Role\n            if (providerOptions.isEmpty()) {\n\n                List<PersonStub> users = new ArrayList<PersonStub>();\n                List<Option> providerUsers = new ArrayList<Option>();\n\n                // If the \"role\" attribute is passed in, limit to users with this role\n                if (parameters.get(\"role\") != null) {\n                    Role role = Context.getUserService().getRole((String) parameters.get(\"role\"));\n                    if (role == null) {\n                        throw new RuntimeException(\"Cannot find role: \" + parameters.get(\"role\"));\n                    } else {\n                        users = Context.getService(HtmlFormEntryService.class).getUsersAsPersonStubs(role.getRole());\n                    }\n                }\n\n                // Otherwise, use default options appropriate to the underlying OpenMRS version\n                else {\n                    if (openmrsVersionDoesNotSupportProviders()) {\n                        // limit to users with the default OpenMRS PROVIDER role,\n                        String defaultRole = RoleConstants.PROVIDER;\n                        Role role = Context.getUserService().getRole(defaultRole);\n                        if (role != null) {\n                            users = Context.getService(HtmlFormEntryService.class).getUsersAsPersonStubs(role.getRole());\n                        }\n                        // If this role isn't used, default to all Users\n                        if (users.isEmpty()) {\n                            users = Context.getService(HtmlFormEntryService.class).getUsersAsPersonStubs(null);\n                        }\n                    } else {\n                        // in OpenMRS 1.9+, get all suitable providers\n                        users = getAllProvidersThatArePersonsAsPersonStubs();\n                    }\n                }\n\n                for (PersonStub personStub : users) {\n\n                    Option option = new Option(personStub.toString(), personStub.getId().toString(), false);\n                    providerUsers.add(option);\n                }\n                providerOptions.addAll(providerUsers);\n\n            }\n\n            // Set default values as appropriate\n            Person defaultProvider = null;\n            Option defProviderOption;\n            if (context.getExistingEncounter() != null) {\n                defaultProvider = EncounterCompatibility.getProvider(context.getExistingEncounter());\n                // this is done to avoid default provider being added twice due to that it can be added from the\n                // users = getAllProvidersThatArePersonsAsPersonStubs(); section with selected=\"false\", therefore this can't be caught when\n                // searching whether the options list contains the 'defaultProvider'\n            boolean defaultOptionPresent = false;\n              if(defaultProvider != null){\n                for(Option option: providerOptions){\n                  if(option.getValue().equals(defaultProvider.getId().toString())){\n                      defaultOptionPresent = true;\n                      providerOptions.remove(option);\n                      break;\n                  }\n                }\n              }\n              if(defaultOptionPresent)  {\n                  defProviderOption\n                     = new Option(defaultProvider.getPersonName().getFullName(), defaultProvider.getId().toString(), true);\n                   providerOptions.add(defProviderOption);\n              }\n\n            } else {\n                String defParam = (String) parameters.get(\"default\");\n                if (StringUtils.hasText(defParam)) {\n                    if (\"currentuser\".equalsIgnoreCase(defParam)) {\n                        defaultProvider = Context.getAuthenticatedUser().getPerson();\n                    } else {\n                        defaultProvider = HtmlFormEntryUtil.getPerson(defParam);\n                    }\n                    if (defaultProvider == null) {\n                        throw new IllegalArgumentException(\"Invalid default provider specified for encounter: \" + defParam);\n                    } else {\n                        defProviderOption\n                                = new Option(defaultProvider.getPersonName().getFullName(), defaultProvider.getId().toString(), true);\n                        for (Option option : providerOptions) {\n                            if (option.getValue().equals(defProviderOption.getValue())) {\n                                providerOptions.remove(option);\n                                break;\n                            }\n                        }\n                        providerOptions.add(defProviderOption);\n                    }\n\n                }\n            }\n            if (defaultProvider != null) {\n                providerWidget.setInitialValue(new PersonStub(defaultProvider));\n            }\n            Collections.sort(providerOptions,new OptionComparator());\n\n            if ((\"autocomplete\").equals(parameters.get(\"type\"))) {\n                providerWidget.addOption(new Option());\n                if (!providerOptions.isEmpty()) {\n                    providerWidget.setOptions(providerOptions);\n                }\n\n            } else {\n                // if initialValueIsSet=false, no initial/default provider, hence this shows the 'select input' field as first option\n                boolean initialValueIsSet = !(providerWidget.getInitialValue() == null);\n                providerWidget.addOption(new Option\n                        (Context.getMessageSourceService().getMessage(\"htmlformentry.chooseAProvider\"), \"\", !initialValueIsSet)); // if no initial or default value\n\n                if (!providerOptions.isEmpty()) {\n                    for (Option option : providerOptions) {\n                        providerWidget.addOption(option);\n                    }\n\n                }\n            }\n            context.registerWidget(providerWidget);\n            context.registerErrorWidget(providerWidget, providerErrorWidget);\n        }\n\n        if (Boolean.TRUE.equals(parameters.get(\"encounterType\"))) {\n            encounterTypeWidget = new EncounterTypeWidget();\n            encounterTypeErrorWidget = new ErrorWidget();\n            if (parameters.get(\"types\") != null) {\n                List<EncounterType> encounterTypes = new ArrayList<EncounterType>();\n                String[] temp = ((String) parameters.get(\"types\")).split(\",\");\n                for (String s : temp) {\n                    EncounterType type = HtmlFormEntryUtil.getEncounterType(s);\n                    if (type == null) {\n                        throw new RuntimeException(\"Cannot find encounter type: \" + s);\n                    }\n                    encounterTypes.add(type);\n                }\n\n               encounterTypeWidget.setOptions(encounterTypes);\n            }\n            // Set default values\n\n            EncounterType defaultEncounterType = null;\n            if (context.getExistingEncounter() != null) {\n                defaultEncounterType = context.getExistingEncounter().getEncounterType();\n            } else {\n                String defaultTypeId = (String) parameters.get(\"default\");\n                if (StringUtils.hasText(defaultTypeId)) {\n                    defaultEncounterType = HtmlFormEntryUtil.getEncounterType(defaultTypeId);\n                }\n            }\n\n            encounterTypeWidget.setInitialValue(defaultEncounterType);\n            context.registerWidget(encounterTypeWidget);\n            context.registerErrorWidget(encounterTypeWidget, encounterTypeErrorWidget);\n        }\n\n        // Register Location widgets, if appropriate\n        if (Boolean.TRUE.equals(parameters.get(\"location\"))) {\n\n                locationErrorWidget = new ErrorWidget();\n            List<Location> locations = new ArrayList<Location>();\n            List<Option> locationOptions = new ArrayList<Option>();\n\n            if (\"autocomplete\".equals(parameters.get(\"type\"))) {\n                locationWidget = new AutocompleteWidget(Location.class);\n            } else {\n                locationWidget = new DropdownWidget();\n            }\n\n            if (parameters.get(\"tags\") != null && parameters.get(\"orders\") != null) {\n                throw new RuntimeException(\"Using both \\\"order\\\" and \\\"tags\\\" attribute in an encounterLocation tag is not currently supported\");\n            }\n\n            // if the \"tags\" attribute has been specified, load all the locations referenced by tag\n            if (parameters.get(\"tags\") != null) {\n\n                List<LocationTag> tags = new ArrayList<LocationTag>();\n                String temp[] = ((String) parameters.get(\"tags\")).split(\",\");\n                for (String s : temp) {\n\n                    LocationTag tag = HtmlFormEntryUtil.getLocationTag(s);\n                    if (tag == null) {\n                        throw new RuntimeException(\"Cannot find tag: \" + tag);\n                    }\n                    tags.add(tag);\n                }\n                locations.addAll(Context.getLocationService().getLocationsHavingAnyTag(tags));\n            }\n            // If the \"order\" attribute is passed in, limit to the specified locations in order\n            else if (parameters.get(\"order\") != null) {\n\n                String[] temp = ((String) parameters.get(\"order\")).split(\",\");\n                for (String s : temp) {\n                    Location loc = HtmlFormEntryUtil.getLocation(s, context);\n                    if (loc == null) {\n                        throw new RuntimeException(\"Cannot find location: \" + loc);\n                    }\n                    locations.add(loc);\n                }\n\n            }\n\n            // if no locations have been specified by the order attribute, use all non-retired locations\n            if (locations.isEmpty()) {\n                locations = Context.getLocationService().getAllLocations(false);\n            }\n\n            // Set default values\n            Location defaultLocation = null;\n            if (context.getExistingEncounter() != null) {\n                defaultLocation = context.getExistingEncounter().getLocation();\n            } else {\n                String defaultLocId = (String) parameters.get(\"default\");\n                if (StringUtils.hasText(defaultLocId)) {\n                    defaultLocation = HtmlFormEntryUtil.getLocation(defaultLocId, context);\n                }\n            }\n            defaultLocation = defaultLocation == null ? context.getDefaultLocation() : defaultLocation;\n            locationWidget.setInitialValue(defaultLocation);\n\n            // if in EDIT mode, make sure that the default/selected location is one of the location options, so we don't accidentally lose it\n            if (defaultLocation != null && context.getMode().equals(Mode.EDIT)) {\n               if (!locations.contains(defaultLocation)) {\n                   locations.add(defaultLocation);\n               }\n            }\n\n            // now create the actual location options\n            for (Location location : locations) {\n                String label = HtmlFormEntryUtil.format(location);\n                Option option = new Option(label, location.getId().toString(), location.equals(defaultLocation));\n                locationOptions.add(option);\n            }\n\n            // sort options (if a specific order hasn't been specified\n            if (parameters.get(\"order\") == null) {\n                Collections.sort(locationOptions, new OptionComparator());\n            }\n\n            if (\"autocomplete\".equals(parameters.get(\"type\"))) {\n                locationWidget.addOption(new Option());\n                if (!locationOptions.isEmpty()) {\n                    locationWidget.setOptions(locationOptions);\n                }\n            } else {\n                boolean initialValueIsSet = !(locationWidget.getInitialValue() == null);\n                locationWidget.addOption(new Option\n                        (Context.getMessageSourceService().getMessage(\"htmlformentry.chooseALocation\"), \"\", !initialValueIsSet));\n                if (!locationOptions.isEmpty()) {\n                    for (Option option : locationOptions)\n                        locationWidget.addOption(option);\n                }\n            }\n            context.registerWidget(locationWidget);\n            context.registerErrorWidget(locationWidget, locationErrorWidget);\n        }\n\n\n        if (Boolean.TRUE.equals(parameters.get(\"showVoidEncounter\")) && context.getMode() == Mode.EDIT) { //only show void option if the encounter already exists.  And VIEW implies not voided.\n\t\t\tif (parameters.get(\"toggle\") != null) {\n\t\t\t\tToggleWidget toggleWidget = new ToggleWidget((String) parameters.get(\"toggle\"));\n\t\t\t\tvoidWidget = new CheckboxWidget(\" \" + Context.getMessageSourceService().getMessage(\"general.voided\"), (context.getExistingEncounter() != null && context.getExistingEncounter().isVoided().equals(true)) ? \"true\" : \"false\", toggleWidget.getTargetId(), toggleWidget.isToggleDim());\n\t\t\t} else {\n\t\t\t\tvoidWidget = new CheckboxWidget();\n\t\t\t}\n            voidWidget.setLabel(\" \" + Context.getMessageSourceService().getMessage(\"general.voided\"));\n            voidErrorWidget = new ErrorWidget();\n            if (context.getExistingEncounter() != null && context.getExistingEncounter().isVoided().equals(true))\n                voidWidget.setInitialValue(\"true\");\n            context.registerWidget(voidWidget);\n            context.registerErrorWidget(voidWidget, voidErrorWidget);\n        }\n\n        // set the id, if it has been specified\n        if (parameters.get(\"id\") != null) {\n            id = (String) parameters.get(\"id\");\n        }\n\n    }",
        "method_after": "    public EncounterDetailSubmissionElement(FormEntryContext context, Map<String, Object> parameters) {\n\n        // Register Date and Time widgets, if appropriate\n        if (Boolean.TRUE.equals(parameters.get(\"date\"))) {\n\n            dateWidget = new DateWidget();\n            dateErrorWidget = new ErrorWidget();\n\n            if (context.getExistingEncounter() != null) {\n                dateWidget.setInitialValue(context.getExistingEncounter().getEncounterDatetime());\n            } else if (parameters.get(\"defaultDate\") != null) {\n                dateWidget.setInitialValue(parameters.get(\"defaultDate\"));\n            }\n\n            if (parameters.get(\"disallowMultipleEncountersOnDate\") != null\n                    && StringUtils.hasText((String) parameters.get(\"disallowMultipleEncountersOnDate\"))) {\n                dateWidget.setOnChangeFunction(\"existingEncounterOnDate(this, '\"\n                        + parameters.get(\"disallowMultipleEncountersOnDate\") + \"') \");\n            }\n\n            if (\"true\".equals(parameters.get(\"showTime\"))) {\n                timeWidget = new TimeWidget();\n                timeErrorWidget = new ErrorWidget();\n                if (context.getExistingEncounter() != null) {\n                    timeWidget.setInitialValue(context.getExistingEncounter().getEncounterDatetime());\n                } else if (parameters.get(\"defaultDate\") != null) {\n                    timeWidget.setInitialValue(parameters.get(\"defaultDate\"));\n                }\n                context.registerWidget(timeWidget);\n                context.registerErrorWidget(timeWidget, timeErrorWidget);\n            }\n            context.registerWidget(dateWidget);\n            context.registerErrorWidget(dateWidget, dateErrorWidget);\n\n            if (\"hidden\".equals(parameters.get(\"widget\"))) {\n                dateWidget.setHidden(true);\n                if (timeWidget != null) {\n                    timeWidget.setHidden(true);\n                }\n            }\n        }\n\n        // Register Provider widgets, if appropriate\n        if (Boolean.TRUE.equals(parameters.get(\"provider\"))) {\n\n            if (\"autocomplete\".equals(parameters.get(\"type\"))) {\n                providerWidget = new AutocompleteWidget(Person.class);\n            }else{\n                providerWidget = new DropdownWidget();\n            }\n            providerErrorWidget = new ErrorWidget();\n\n            List<Option> providerOptions = new ArrayList<Option>();\n            // If specific persons are specified, display only those persons in order\n            String personsParam = (String) parameters.get(\"persons\");\n            if (personsParam != null) {\n                for (String s : personsParam.split(\",\")) {\n                    Person p = HtmlFormEntryUtil.getPerson(s);\n                    if (p == null) {\n                        throw new RuntimeException(\"Cannot find Person: \" + s);\n                    }\n                    String label = StringEscapeUtils.escapeHtml(p.getPersonName().getFullName());\n                    providerOptions.add(new Option(label, p.getId().toString(), false));\n                }\n                removeNonProviders(providerOptions);\n            }\n\n            // Only if specific person ids are not passed in do we get by user Role\n            if (providerOptions.isEmpty()) {\n\n                List<PersonStub> users = new ArrayList<PersonStub>();\n                List<Option> providerUsers = new ArrayList<Option>();\n\n                // If the \"role\" attribute is passed in, limit to users with this role\n                if (parameters.get(\"role\") != null) {\n                    Role role = Context.getUserService().getRole((String) parameters.get(\"role\"));\n                    if (role == null) {\n                        throw new RuntimeException(\"Cannot find role: \" + parameters.get(\"role\"));\n                    } else {\n                        users = Context.getService(HtmlFormEntryService.class).getUsersAsPersonStubs(role.getRole());\n                    }\n                }\n\n                // Otherwise, use default options appropriate to the underlying OpenMRS version\n                else {\n                    if (openmrsVersionDoesNotSupportProviders()) {\n                        // limit to users with the default OpenMRS PROVIDER role,\n                        String defaultRole = RoleConstants.PROVIDER;\n                        Role role = Context.getUserService().getRole(defaultRole);\n                        if (role != null) {\n                            users = Context.getService(HtmlFormEntryService.class).getUsersAsPersonStubs(role.getRole());\n                        }\n                        // If this role isn't used, default to all Users\n                        if (users.isEmpty()) {\n                            users = Context.getService(HtmlFormEntryService.class).getUsersAsPersonStubs(null);\n                        }\n                    } else {\n                        // in OpenMRS 1.9+, get all suitable providers\n                        users = getAllProvidersThatArePersonsAsPersonStubs();\n                    }\n                }\n\n                for (PersonStub personStub : users) {\n\n                    Option option = new Option(StringEscapeUtils.escapeHtml(personStub.toString()), personStub.getId().toString(), false);\n                    providerUsers.add(option);\n                }\n                providerOptions.addAll(providerUsers);\n\n            }\n\n            // Set default values as appropriate\n            Person defaultProvider = null;\n            Option defProviderOption;\n            if (context.getExistingEncounter() != null) {\n                defaultProvider = EncounterCompatibility.getProvider(context.getExistingEncounter());\n                // this is done to avoid default provider being added twice due to that it can be added from the\n                // users = getAllProvidersThatArePersonsAsPersonStubs(); section with selected=\"false\", therefore this can't be caught when\n                // searching whether the options list contains the 'defaultProvider'\n            boolean defaultOptionPresent = false;\n              if(defaultProvider != null){\n                for(Option option: providerOptions){\n                  if(option.getValue().equals(defaultProvider.getId().toString())){\n                      defaultOptionPresent = true;\n                      providerOptions.remove(option);\n                      break;\n                  }\n                }\n              }\n              if(defaultOptionPresent)  {\n                  defProviderOption\n                     = new Option(StringEscapeUtils.escapeHtml(defaultProvider.getPersonName().getFullName()), defaultProvider.getId().toString(), true);\n                   providerOptions.add(defProviderOption);\n              }\n\n            } else {\n                String defParam = (String) parameters.get(\"default\");\n                if (StringUtils.hasText(defParam)) {\n                    if (\"currentuser\".equalsIgnoreCase(defParam)) {\n                        defaultProvider = Context.getAuthenticatedUser().getPerson();\n                    } else {\n                        defaultProvider = HtmlFormEntryUtil.getPerson(defParam);\n                    }\n                    if (defaultProvider == null) {\n                        throw new IllegalArgumentException(\"Invalid default provider specified for encounter: \" + defParam);\n                    } else {\n                        defProviderOption\n                                = new Option(StringEscapeUtils.escapeHtml(defaultProvider.getPersonName().getFullName()), defaultProvider.getId().toString(), true);\n                        for (Option option : providerOptions) {\n                            if (option.getValue().equals(defProviderOption.getValue())) {\n                                providerOptions.remove(option);\n                                break;\n                            }\n                        }\n                        providerOptions.add(defProviderOption);\n                    }\n\n                }\n            }\n            if (defaultProvider != null) {\n                providerWidget.setInitialValue(new PersonStub(defaultProvider));\n            }\n            Collections.sort(providerOptions,new OptionComparator());\n\n            if ((\"autocomplete\").equals(parameters.get(\"type\"))) {\n                providerWidget.addOption(new Option());\n                if (!providerOptions.isEmpty()) {\n                    providerWidget.setOptions(providerOptions);\n                }\n\n            } else {\n                // if initialValueIsSet=false, no initial/default provider, hence this shows the 'select input' field as first option\n                boolean initialValueIsSet = !(providerWidget.getInitialValue() == null);\n                providerWidget.addOption(new Option\n                        (Context.getMessageSourceService().getMessage(\"htmlformentry.chooseAProvider\"), \"\", !initialValueIsSet)); // if no initial or default value\n\n                if (!providerOptions.isEmpty()) {\n                    for (Option option : providerOptions) {\n                        providerWidget.addOption(option);\n                    }\n\n                }\n            }\n            context.registerWidget(providerWidget);\n            context.registerErrorWidget(providerWidget, providerErrorWidget);\n        }\n\n        if (Boolean.TRUE.equals(parameters.get(\"encounterType\"))) {\n            encounterTypeWidget = new EncounterTypeWidget();\n            encounterTypeErrorWidget = new ErrorWidget();\n            if (parameters.get(\"types\") != null) {\n                List<EncounterType> encounterTypes = new ArrayList<EncounterType>();\n                String[] temp = ((String) parameters.get(\"types\")).split(\",\");\n                for (String s : temp) {\n                    EncounterType type = HtmlFormEntryUtil.getEncounterType(s);\n                    if (type == null) {\n                        throw new RuntimeException(\"Cannot find encounter type: \" + s);\n                    }\n                    encounterTypes.add(type);\n                }\n\n               encounterTypeWidget.setOptions(encounterTypes);\n            }\n            // Set default values\n\n            EncounterType defaultEncounterType = null;\n            if (context.getExistingEncounter() != null) {\n                defaultEncounterType = context.getExistingEncounter().getEncounterType();\n            } else {\n                String defaultTypeId = (String) parameters.get(\"default\");\n                if (StringUtils.hasText(defaultTypeId)) {\n                    defaultEncounterType = HtmlFormEntryUtil.getEncounterType(defaultTypeId);\n                }\n            }\n\n            encounterTypeWidget.setInitialValue(defaultEncounterType);\n            context.registerWidget(encounterTypeWidget);\n            context.registerErrorWidget(encounterTypeWidget, encounterTypeErrorWidget);\n        }\n\n        // Register Location widgets, if appropriate\n        if (Boolean.TRUE.equals(parameters.get(\"location\"))) {\n\n                locationErrorWidget = new ErrorWidget();\n            List<Location> locations = new ArrayList<Location>();\n            List<Option> locationOptions = new ArrayList<Option>();\n\n            if (\"autocomplete\".equals(parameters.get(\"type\"))) {\n                locationWidget = new AutocompleteWidget(Location.class);\n            } else {\n                locationWidget = new DropdownWidget();\n            }\n\n            if (parameters.get(\"tags\") != null && parameters.get(\"orders\") != null) {\n                throw new RuntimeException(\"Using both \\\"order\\\" and \\\"tags\\\" attribute in an encounterLocation tag is not currently supported\");\n            }\n\n            // if the \"tags\" attribute has been specified, load all the locations referenced by tag\n            if (parameters.get(\"tags\") != null) {\n\n                List<LocationTag> tags = new ArrayList<LocationTag>();\n                String temp[] = ((String) parameters.get(\"tags\")).split(\",\");\n                for (String s : temp) {\n\n                    LocationTag tag = HtmlFormEntryUtil.getLocationTag(s);\n                    if (tag == null) {\n                        throw new RuntimeException(\"Cannot find tag: \" + tag);\n                    }\n                    tags.add(tag);\n                }\n                locations.addAll(Context.getLocationService().getLocationsHavingAnyTag(tags));\n            }\n            // If the \"order\" attribute is passed in, limit to the specified locations in order\n            else if (parameters.get(\"order\") != null) {\n\n                String[] temp = ((String) parameters.get(\"order\")).split(\",\");\n                for (String s : temp) {\n                    Location loc = HtmlFormEntryUtil.getLocation(s, context);\n                    if (loc == null) {\n                        throw new RuntimeException(\"Cannot find location: \" + loc);\n                    }\n                    locations.add(loc);\n                }\n\n            }\n\n            // if no locations have been specified by the order attribute, use all non-retired locations\n            if (locations.isEmpty()) {\n                locations = Context.getLocationService().getAllLocations(false);\n            }\n\n            // Set default values\n            Location defaultLocation = null;\n            if (context.getExistingEncounter() != null) {\n                defaultLocation = context.getExistingEncounter().getLocation();\n            } else {\n                String defaultLocId = (String) parameters.get(\"default\");\n                if (StringUtils.hasText(defaultLocId)) {\n                    defaultLocation = HtmlFormEntryUtil.getLocation(defaultLocId, context);\n                }\n            }\n            defaultLocation = defaultLocation == null ? context.getDefaultLocation() : defaultLocation;\n            locationWidget.setInitialValue(defaultLocation);\n\n            // if in EDIT mode, make sure that the default/selected location is one of the location options, so we don't accidentally lose it\n            if (defaultLocation != null && context.getMode().equals(Mode.EDIT)) {\n               if (!locations.contains(defaultLocation)) {\n                   locations.add(defaultLocation);\n               }\n            }\n\n            // now create the actual location options\n            for (Location location : locations) {\n                String label = HtmlFormEntryUtil.format(location);\n                Option option = new Option(label, location.getId().toString(), location.equals(defaultLocation));\n                locationOptions.add(option);\n            }\n\n            // sort options (if a specific order hasn't been specified\n            if (parameters.get(\"order\") == null) {\n                Collections.sort(locationOptions, new OptionComparator());\n            }\n\n            if (\"autocomplete\".equals(parameters.get(\"type\"))) {\n                locationWidget.addOption(new Option());\n                if (!locationOptions.isEmpty()) {\n                    locationWidget.setOptions(locationOptions);\n                }\n            } else {\n                boolean initialValueIsSet = !(locationWidget.getInitialValue() == null);\n                locationWidget.addOption(new Option\n                        (Context.getMessageSourceService().getMessage(\"htmlformentry.chooseALocation\"), \"\", !initialValueIsSet));\n                if (!locationOptions.isEmpty()) {\n                    for (Option option : locationOptions)\n                        locationWidget.addOption(option);\n                }\n            }\n            context.registerWidget(locationWidget);\n            context.registerErrorWidget(locationWidget, locationErrorWidget);\n        }\n\n\n        if (Boolean.TRUE.equals(parameters.get(\"showVoidEncounter\")) && context.getMode() == Mode.EDIT) { //only show void option if the encounter already exists.  And VIEW implies not voided.\n\t\t\tif (parameters.get(\"toggle\") != null) {\n\t\t\t\tToggleWidget toggleWidget = new ToggleWidget((String) parameters.get(\"toggle\"));\n\t\t\t\tvoidWidget = new CheckboxWidget(\" \" + Context.getMessageSourceService().getMessage(\"general.voided\"), (context.getExistingEncounter() != null && context.getExistingEncounter().isVoided().equals(true)) ? \"true\" : \"false\", toggleWidget.getTargetId(), toggleWidget.isToggleDim());\n\t\t\t} else {\n\t\t\t\tvoidWidget = new CheckboxWidget();\n\t\t\t}\n            voidWidget.setLabel(\" \" + Context.getMessageSourceService().getMessage(\"general.voided\"));\n            voidErrorWidget = new ErrorWidget();\n            if (context.getExistingEncounter() != null && context.getExistingEncounter().isVoided().equals(true))\n                voidWidget.setInitialValue(\"true\");\n            context.registerWidget(voidWidget);\n            context.registerErrorWidget(voidWidget, voidErrorWidget);\n        }\n\n        // set the id, if it has been specified\n        if (parameters.get(\"id\") != null) {\n            id = (String) parameters.get(\"id\");\n        }\n\n    }"
    },
    {
        "idx": "1724",
        "vuln_id": "unknown-202",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "835f85ed22b9f788e23b6f49893698770e9fcfe3",
        "method_before": "    private void postWorkDirectory() {\n\n        // Acquire (or calculate) the work directory path\n        String workDir = getWorkDir();\n        if (workDir == null || workDir.length() == 0) {\n\n            // Retrieve our parent (normally a host) name\n            String hostName = null;\n            String engineName = null;\n            String hostWorkDir = null;\n            Container parentHost = getParent();\n            if (parentHost != null) {\n                hostName = parentHost.getName();\n                if (parentHost instanceof StandardHost) {\n                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                }\n                Container parentEngine = parentHost.getParent();\n                if (parentEngine != null) {\n                   engineName = parentEngine.getName();\n                }\n            }\n            if ((hostName == null) || (hostName.length() < 1))\n                hostName = \"_\";\n            if ((engineName == null) || (engineName.length() < 1))\n                engineName = \"_\";\n\n            String temp = getPath();\n            if (temp.startsWith(\"/\"))\n                temp = temp.substring(1);\n            temp = temp.replace('/', '_');\n            temp = temp.replace('\\\\', '_');\n            if (temp.length() < 1)\n                temp = \"_\";\n            if (hostWorkDir != null ) {\n                workDir = hostWorkDir + File.separator + temp;\n            } else {\n                workDir = \"work\" + File.separator + engineName +\n                    File.separator + hostName + File.separator + temp;\n            }\n            setWorkDir(workDir);\n        }\n\n        // Create this directory if necessary\n        File dir = new File(workDir);\n        if (!dir.isAbsolute()) {\n            File catalinaHome = engineBase();\n            String catalinaHomePath = null;\n            try {\n                catalinaHomePath = catalinaHome.getCanonicalPath();\n                dir = new File(catalinaHomePath, workDir);\n            } catch (IOException e) {\n            }\n        }\n        dir.mkdirs();\n\n        // Set the appropriate servlet context attribute\n        getServletContext().setAttribute(ServletContext.TEMPDIR, dir);\n        if (getServletContext() instanceof ApplicationContext)\n            ((ApplicationContext) getServletContext()).setAttributeReadOnly\n                (ServletContext.TEMPDIR);\n\n    }",
        "method_after": "    private void postWorkDirectory() {\n\n        // Acquire (or calculate) the work directory path\n        String workDir = getWorkDir();\n        if (workDir == null || workDir.length() == 0) {\n\n            // Retrieve our parent (normally a host) name\n            String hostName = null;\n            String engineName = null;\n            String hostWorkDir = null;\n            Container parentHost = getParent();\n            if (parentHost != null) {\n                hostName = parentHost.getName();\n                if (parentHost instanceof StandardHost) {\n                    hostWorkDir = ((StandardHost)parentHost).getWorkDir();\n                }\n                Container parentEngine = parentHost.getParent();\n                if (parentEngine != null) {\n                   engineName = parentEngine.getName();\n                }\n            }\n            if ((hostName == null) || (hostName.length() < 1))\n                hostName = \"_\";\n            if ((engineName == null) || (engineName.length() < 1))\n                engineName = \"_\";\n\n            String temp = getPath();\n            if (temp.startsWith(\"/\"))\n                temp = temp.substring(1);\n            temp = temp.replace('/', '_');\n            temp = temp.replace('\\\\', '_');\n            if (temp.length() < 1)\n                temp = \"_\";\n            if (hostWorkDir != null ) {\n                workDir = hostWorkDir + File.separator + temp;\n            } else {\n                workDir = \"work\" + File.separator + engineName +\n                    File.separator + hostName + File.separator + temp;\n            }\n            setWorkDir(workDir);\n        }\n\n        // Create this directory if necessary\n        File dir = new File(workDir);\n        if (!dir.isAbsolute()) {\n            File catalinaHome = engineBase();\n            String catalinaHomePath = null;\n            try {\n                catalinaHomePath = catalinaHome.getCanonicalPath();\n                dir = new File(catalinaHomePath, workDir);\n            } catch (IOException e) {\n            }\n        }\n        dir.mkdirs();\n\n        // Set the appropriate servlet context attribute\n        if (context == null) {\n            getServletContext();\n        }\n        context.setAttribute(ServletContext.TEMPDIR, dir);\n        context.setAttributeReadOnly(ServletContext.TEMPDIR);\n    }"
    },
    {
        "idx": "1742",
        "vuln_id": "unknown-219",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "25251de791a6a7be13f2f3d3a66119a77025272d",
        "method_before": "        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n            } else {\n                original = Thread.currentThread().getContextClassLoader();\n            }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(JspDocumentParser.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        JspDocumentParser.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }",
        "method_after": "        if (initialized)\n            return;\n\n        String blockExternalString = ctxt.getInitParameter(\n                Constants.XML_BLOCK_EXTERNAL_INIT_PARAM);\n        boolean blockExternal;\n        if (blockExternalString == null) {\n            blockExternal = true;\n        } else {\n            blockExternal = Boolean.parseBoolean(blockExternalString);\n        }\n\n        TagPluginParser parser;\n        ClassLoader original;\n        if (Constants.IS_SECURITY_ENABLED) {\n            PrivilegedGetTccl pa = new PrivilegedGetTccl();\n            original = AccessController.doPrivileged(pa);\n        } else {\n            original = Thread.currentThread().getContextClassLoader();\n        }\n        try {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa =\n                        new PrivilegedSetTccl(TagPluginManager.class.getClassLoader());\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(\n                        TagPluginManager.class.getClassLoader());\n            }\n\n            parser = new TagPluginParser(ctxt, blockExternal);\n\n        } finally {\n            if (Constants.IS_SECURITY_ENABLED) {\n                PrivilegedSetTccl pa = new PrivilegedSetTccl(original);\n                AccessController.doPrivileged(pa);\n            } else {\n                Thread.currentThread().setContextClassLoader(original);\n            }\n        }\n\n        try {\n            Enumeration<URL> urls =\n                    ctxt.getClassLoader().getResources(META_INF_JASPER_TAG_PLUGINS_XML);\n            if (urls != null) {\n                while (urls.hasMoreElements()) {\n                    URL url = urls.nextElement();\n                    parser.parse(url);\n                }\n            }\n\n            URL url = ctxt.getResource(TAG_PLUGINS_XML);\n            if (url != null) {\n                parser.parse(url);\n            }\n        } catch (IOException | SAXException e) {\n            throw new JasperException(e);\n        }\n\n        Map<String, String> plugins = parser.getPlugins();\n        tagPlugins = new HashMap<>(plugins.size());\n        for (Map.Entry<String, String> entry : plugins.entrySet()) {\n            try {\n                String tagClass = entry.getKey();\n                String pluginName = entry.getValue();\n                Class<?> pluginClass = ctxt.getClassLoader().loadClass(pluginName);\n                TagPlugin plugin = (TagPlugin) pluginClass.newInstance();\n                tagPlugins.put(tagClass, plugin);\n            } catch (Exception e) {\n                err.jspError(e);\n            }\n        }\n        initialized = true;\n    }"
    },
    {
        "idx": "1859",
        "vuln_id": "unknown-82",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/apache/tomcat80",
        "commit": "d49a03728ac7e3c800b1b0ce0eeccd8a5a21bb91",
        "method_before": "    protected boolean parseChunkHeader()\n        throws IOException {\n\n        int result = 0;\n        boolean eol = false;\n        boolean readDigit = false;\n        boolean extension = false;\n\n        while (!eol) {\n\n            if (pos >= lastValid) {\n                if (readBytes() <= 0)\n                    return false;\n            }\n\n            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {\n                parseCRLF(false);\n                eol = true;\n            } else if (buf[pos] == Constants.SEMI_COLON && !extension) {\n                // First semi-colon marks the start of the extension. Further\n                // semi-colons may appear to separate multiple chunk-extensions.\n                // These need to be processed as part of parsing the extensions.\n                extension = true;\n                extensionSize++;\n            } else if (!extension) {\n                //don't read data after the trailer\n                int charValue = HexUtils.getDec(buf[pos]);\n                if (charValue != -1) {\n                    readDigit = true;\n                    result *= 16;\n                    result += charValue;\n                } else {\n                    //we shouldn't allow invalid, non hex characters\n                    //in the chunked header\n                    return false;\n                }\n            } else {\n                // Extension 'parsing'\n                // Note that the chunk-extension is neither parsed nor\n                // validated. Currently it is simply ignored.\n                extensionSize++;\n                if (maxExtensionSize > -1 && extensionSize > maxExtensionSize) {\n                    throw new IOException(\"maxExtensionSize exceeded\");\n                }\n            }\n\n            // Parsing the CRLF increments pos\n            if (!eol) {\n                pos++;\n            }\n\n        }\n\n        if (!readDigit)\n            return false;\n\n        if (result == 0)\n            endChunk = true;\n\n        remaining = result;\n        if (remaining < 0)\n            return false;\n\n        return true;\n\n    }",
        "method_after": "    protected boolean parseChunkHeader()\n        throws IOException {\n\n        int result = 0;\n        boolean eol = false;\n        int readDigit = 0;\n        boolean extension = false;\n\n        while (!eol) {\n\n            if (pos >= lastValid) {\n                if (readBytes() <= 0)\n                    return false;\n            }\n\n            if (buf[pos] == Constants.CR || buf[pos] == Constants.LF) {\n                parseCRLF(false);\n                eol = true;\n            } else if (buf[pos] == Constants.SEMI_COLON && !extension) {\n                // First semi-colon marks the start of the extension. Further\n                // semi-colons may appear to separate multiple chunk-extensions.\n                // These need to be processed as part of parsing the extensions.\n                extension = true;\n                extensionSize++;\n            } else if (!extension) {\n                //don't read data after the trailer\n                int charValue = HexUtils.getDec(buf[pos]);\n                if (charValue != -1 && readDigit < 8) {\n                    readDigit++;\n                    result = (result << 4) | charValue;\n                } else {\n                    //we shouldn't allow invalid, non hex characters\n                    //in the chunked header\n                    return false;\n                }\n            } else {\n                // Extension 'parsing'\n                // Note that the chunk-extension is neither parsed nor\n                // validated. Currently it is simply ignored.\n                extensionSize++;\n                if (maxExtensionSize > -1 && extensionSize > maxExtensionSize) {\n                    throw new IOException(\"maxExtensionSize exceeded\");\n                }\n            }\n\n            // Parsing the CRLF increments pos\n            if (!eol) {\n                pos++;\n            }\n\n        }\n\n        if (readDigit == 0 || result < 0)\n            return false;\n\n        if (result == 0)\n            endChunk = true;\n\n        remaining = result;\n        if (remaining < 0)\n            return false;\n\n        return true;\n\n    }"
    },
    {
        "idx": "1863",
        "vuln_id": "unknown-86",
        "desc": "Not Mapping",
        "cwe_id": "Not Mapping",
        "cwe_name": "Not Mapping",
        "repo": "https://github.com/hibernate/hibernate-validator",
        "commit": "124b7dd6d9a4ad24d4d49f74701f05a13e56ceee",
        "method_before": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}",
        "method_after": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tList<Node> childNodes = fragment.childNodes();\n\t\tfor ( Node node : childNodes ) {\n\t\t\tdocument.body().appendChild( node.clone() );\n\t\t}\n\n\t\treturn document;\n\t}"
    }
]