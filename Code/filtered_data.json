[
    {
        "idx": "19",
        "vuln_id": "CVE-2007-5461",
        "desc": "Absolute path traversal vulnerability in Apache Tomcat 4.0.0 through 4.0.6, 4.1.0, 5.0.0, 5.5.0 through 5.5.25, and 6.0.0 through 6.0.14, under certain configurations, allows remote authenticated users to read arbitrary files via a WebDAV write request that specifies an entity with a SYSTEM tag.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "901292cf9d7d8225f8a3b96c7583e2bd8b41772d",
        "method_before": "    protected DocumentBuilder getDocumentBuilder()\n        throws ServletException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch(ParserConfigurationException e) {\n            throw new ServletException\n                (sm.getString(\"webdavservlet.jaxpfailed\"));\n        }\n        return documentBuilder;\n    }",
        "method_after": "    protected DocumentBuilder getDocumentBuilder()\n        throws ServletException {\n        DocumentBuilder documentBuilder = null;\n        DocumentBuilderFactory documentBuilderFactory = null;\n        try {\n            documentBuilderFactory = DocumentBuilderFactory.newInstance();\n            documentBuilderFactory.setNamespaceAware(true);\n            documentBuilderFactory.setExpandEntityReferences(false);\n            documentBuilder = documentBuilderFactory.newDocumentBuilder();\n        } catch(ParserConfigurationException e) {\n            throw new ServletException\n                (sm.getString(\"webdavservlet.jaxpfailed\"));\n        }\n        return documentBuilder;\n    }"
    },
    {
        "idx": "64",
        "vuln_id": "CVE-2010-4172",
        "desc": "Multiple cross-site scripting (XSS) vulnerabilities in the Manager application in Apache Tomcat 6.0.12 through 6.0.29 and 7.0.0 through 7.0.4 allow remote attackers to inject arbitrary web script or HTML via the (1) orderBy or (2) sort parameter to sessionsList.jsp, or unspecified input to (3) sessionDetail.jsp or (4) java/org/apache/catalina/manager/JspHelper.java, related to use of untrusted web applications.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "5971f9392edc6d70808b2599b062b050fcd11d23",
        "method_before": "    private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return locale.toString();//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }",
        "method_after": "    private static String localeToString(Locale locale) {\n        if (locale != null) {\n            return escapeXml(locale.toString());//locale.getDisplayName();\n        } else {\n            return \"\";\n        }\n    }"
    },
    {
        "idx": "205",
        "vuln_id": "CVE-2013-4378",
        "desc": "Cross-site scripting (XSS) vulnerability in HtmlSessionInformationsReport.java in JavaMelody 1.46 and earlier allows remote attackers to inject arbitrary web script or HTML via a crafted X-Forwarded-For header.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/javamelody/javamelody",
        "commit": "aacbc46151ff4ac1ca34ce0899c2a6113071c66e",
        "method_before": "\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"'>\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"</a>\");\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getLastAccess()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getAge()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\n\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getAttributeCount()));\n\t\twrite(nextColumnAlignCenter);\n\t\tif (session.isSerializable()) {\n\t\t\twrite(\"#oui#\");\n\t\t} else {\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\n\t\t}\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getSerializedSize()));\n\t\tfinal String nextColumn = \"</td><td>\";\n\t\twrite(nextColumn);\n\t\tfinal String remoteAddr = session.getRemoteAddr();\n\t\tif (remoteAddr == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\twrite(remoteAddr);\n\t\t}\n\t\twrite(nextColumnAlignCenter);\n\t\twriteCountry(session);\n\t\tif (displayUser) {\n\t\t\twrite(nextColumn);\n\t\t\tfinal String remoteUser = session.getRemoteUser();\n\t\t\tif (remoteUser == null) {\n\t\t\t\twrite(\"&nbsp;\");\n\t\t\t} else {\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n\t\t\t}\n\t\t}\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\n\t\twrite(A_HREF_PART_SESSIONS);\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\t\twrite(urlEncode(session.getId()));\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\t\twrite(\"</a>\");\n\t\twrite(\"</td>\");\n\t}",
        "method_after": "\tprivate void writeSession(SessionInformations session, boolean displayUser) throws IOException {\n\t\tfinal String nextColumnAlignRight = \"</td><td align='right'>\";\n\t\tfinal String nextColumnAlignCenter = \"</td><td align='center'>\";\n\t\twrite(\"<td><a href='?part=sessions&amp;sessionId=\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"'>\");\n\t\twrite(htmlEncodeButNotSpace(session.getId()));\n\t\twrite(\"</a>\");\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getLastAccess()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(durationFormat.format(session.getAge()));\n\t\twrite(nextColumnAlignRight);\n\t\twrite(expiryFormat.format(session.getExpirationDate()));\n\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getAttributeCount()));\n\t\twrite(nextColumnAlignCenter);\n\t\tif (session.isSerializable()) {\n\t\t\twrite(\"#oui#\");\n\t\t} else {\n\t\t\twrite(\"<span class='severe'>#non#</span>\");\n\t\t}\n\t\twrite(nextColumnAlignRight);\n\t\twrite(integerFormat.format(session.getSerializedSize()));\n\t\tfinal String nextColumn = \"</td><td>\";\n\t\twrite(nextColumn);\n\t\tfinal String remoteAddr = session.getRemoteAddr();\n\t\tif (remoteAddr == null) {\n\t\t\twrite(\"&nbsp;\");\n\t\t} else {\n\t\t\twrite(htmlEncodeButNotSpace(remoteAddr));\n\t\t}\n\t\twrite(nextColumnAlignCenter);\n\t\twriteCountry(session);\n\t\tif (displayUser) {\n\t\t\twrite(nextColumn);\n\t\t\tfinal String remoteUser = session.getRemoteUser();\n\t\t\tif (remoteUser == null) {\n\t\t\t\twrite(\"&nbsp;\");\n\t\t\t} else {\n\t\t\t\twriteDirectly(htmlEncodeButNotSpace(remoteUser));\n\t\t\t}\n\t\t}\n\t\twrite(\"</td><td align='center' class='noPrint'>\");\n\t\twrite(A_HREF_PART_SESSIONS);\n\t\twrite(\"&amp;action=invalidate_session&amp;sessionId=\");\n\t\twrite(urlEncode(session.getId()));\n\t\twrite(\"' onclick=\\\"javascript:return confirm('\"\n\t\t\t\t+ getStringForJavascript(\"confirm_invalidate_session\") + \"');\\\">\");\n\t\twrite(\"<img width='16' height='16' src='?resource=user-trash.png' alt='#invalidate_session#' title='#invalidate_session#' />\");\n\t\twrite(\"</a>\");\n\t\twrite(\"</td>\");\n\t}"
    },
    {
        "idx": "227",
        "vuln_id": "CVE-2014-0035",
        "desc": "The SymmetricBinding in Apache CXF before 2.6.13 and 2.7.x before 2.7.10, when EncryptBeforeSigning is enabled and the UsernameToken policy is set to an EncryptedSupportingToken, transmits the UsernameToken in cleartext, which allows remote attackers to obtain sensitive information by sniffing the network.",
        "cwe_id": "CWE-310",
        "cwe_name": "Cryptographic Issues",
        "repo": "https://github.com/apache/cxf",
        "commit": "5df3f72f1a26b7c9ac2888ab65e41f4105706580",
        "method_before": "    private void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            if (encryptionToken != null) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken \n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isEncryptSignature() \n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n                    \n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys \n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, encrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }",
        "method_after": "    private void doEncryptBeforeSign() {\n        try {\n            AbstractTokenWrapper encryptionWrapper = getEncryptionToken();\n            assertTokenWrapper(encryptionWrapper);\n            AbstractToken encryptionToken = encryptionWrapper.getToken();\n            List<WSEncryptionPart> encrParts = getEncryptedParts();\n            List<WSEncryptionPart> sigParts = getSignedParts();\n            \n            if (encryptionToken != null) {\n                //The encryption token can be an IssuedToken or a \n                //SecureConversationToken\n                String tokenId = null;\n                SecurityToken tok = null;\n                if (encryptionToken instanceof IssuedToken \n                    || encryptionToken instanceof KerberosToken\n                    || encryptionToken instanceof SecureConversationToken\n                    || encryptionToken instanceof SecurityContextToken\n                    || encryptionToken instanceof SpnegoContextToken) {\n                    tok = getSecurityToken();\n                } else if (encryptionToken instanceof X509Token) {\n                    if (isRequestor()) {\n                        tokenId = setupEncryptedKey(encryptionWrapper, encryptionToken);\n                    } else {\n                        tokenId = getEncryptedKey();\n                    }\n                } else if (encryptionToken instanceof UsernameToken) {\n                    if (isRequestor()) {\n                        tokenId = setupUTDerivedKey((UsernameToken)encryptionToken);\n                    } else {\n                        tokenId = getUTDerivedKey();\n                    }\n                }\n                assertToken(encryptionToken);\n                if (tok == null) {\n                    //if (tokenId == null || tokenId.length() == 0) {\n                        //REVISIT - no tokenId?   Exception?\n                    //}\n                    if (tokenId != null && tokenId.startsWith(\"#\")) {\n                        tokenId = tokenId.substring(1);\n                    }\n                    \n                    /*\n                     * Get hold of the token from the token storage\n                     */\n                    tok = tokenStore.getToken(tokenId);\n                }\n    \n                boolean attached = false;\n                if (isTokenRequired(encryptionToken.getIncludeTokenType())) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                } else if (encryptionToken instanceof X509Token && isRequestor()) {\n                    Element el = tok.getToken();\n                    this.addEncryptedKeyElement(cloneElement(el));\n                    attached = true;\n                }\n                \n                WSSecBase encr = doEncryption(encryptionWrapper, tok, attached, encrParts, true);\n                \n                handleEncryptedSignedHeaders(encrParts, sigParts);\n                \n                if (timestampEl != null) {\n                    WSEncryptionPart timestampPart = \n                        convertToEncryptionPart(timestampEl.getElement());\n                    sigParts.add(timestampPart);        \n                }\n                \n                addSupportingTokens(sigParts);\n                if (!isRequestor()) {\n                    addSignatureConfirmation(sigParts);\n                }\n                \n                //Sign the message\n                //We should use the same key in the case of EncryptBeforeSig\n                if (sigParts.size() > 0) {\n                    signatures.add(this.doSignature(sigParts, encryptionWrapper, encryptionToken, \n                                                    tok, attached));\n                }\n                \n                if (isRequestor()) {\n                    this.doEndorse();\n                }\n                \n                //Check for signature protection and encryption of UsernameToken\n                if (sbinding.isEncryptSignature() \n                    || encryptedTokensList.size() > 0 && isRequestor()) {\n                    List<WSEncryptionPart> secondEncrParts = new ArrayList<WSEncryptionPart>();\n                    \n                    //Now encrypt the signature using the above token\n                    if (sbinding.isEncryptSignature()) {\n                        if (this.mainSigId != null) {\n                            WSEncryptionPart sigPart = \n                                new WSEncryptionPart(this.mainSigId, \"Element\");\n                            sigPart.setElement(bottomUpElement);\n                            secondEncrParts.add(sigPart);\n                        }\n                        if (sigConfList != null && !sigConfList.isEmpty()) {\n                            secondEncrParts.addAll(sigConfList);\n                        }\n                        assertPolicy(\n                            new QName(sbinding.getName().getNamespaceURI(), SPConstants.ENCRYPT_SIGNATURE));\n                    }\n                    \n                    if (isRequestor()) {\n                        secondEncrParts.addAll(encryptedTokensList);\n                    }\n                    \n                    Element secondRefList = null;\n                    \n                    if (encryptionToken.getDerivedKeys() == DerivedKeys.RequireDerivedKeys \n                        && !secondEncrParts.isEmpty()) {\n                        secondRefList = ((WSSecDKEncrypt)encr).encryptForExternalRef(null, \n                                secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    } else if (!secondEncrParts.isEmpty()) {\n                        //Encrypt, get hold of the ref list and add it\n                        secondRefList = ((WSSecEncrypt)encr).encryptForRef(null, secondEncrParts);\n                        this.addDerivedKeyElement(secondRefList);\n                    }\n                }\n            }\n        } catch (RuntimeException ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw ex;\n        } catch (Exception ex) {\n            LOG.log(Level.FINE, ex.getMessage(), ex);\n            throw new Fault(ex);\n        }\n    }"
    },
    {
        "idx": "269",
        "vuln_id": "CVE-2014-2059",
        "desc": "Directory traversal vulnerability in the CLI job creation (hudson/cli/CreateJobCommand.java) in Jenkins before 1.551 and LTS before 1.532.2 allows remote authenticated users to overwrite arbitrary files via the job name.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "ad38d8480f20ce3cbf8fec3e2003bc83efda4f7d",
        "method_before": "    protected int run() throws Exception {\n        Jenkins h = Jenkins.getInstance();\n        h.checkPermission(Item.CREATE);\n\n        if (h.getItemByFullName(name)!=null) {\n            stderr.println(\"Job '\"+name+\"' already exists\");\n            return -1;\n        }\n\n        ModifiableTopLevelItemGroup ig = h;\n        int i = name.lastIndexOf('/');\n        if (i > 0) {\n            String group = name.substring(0, i);\n            Item item = h.getItemByFullName(group);\n            if (item == null) {\n                throw new IllegalArgumentException(\"Unknown ItemGroup \" + group);\n            }\n\n            if (item instanceof ModifiableTopLevelItemGroup) {\n                ig = (ModifiableTopLevelItemGroup) item;\n            } else {\n                throw new IllegalArgumentException(\"Can't create job from CLI in \" + group);\n            }\n            name = name.substring(i + 1);\n        }\n\n        ig.createProjectFromXML(name, stdin);\n        return 0;\n    }",
        "method_after": "    protected int run() throws Exception {\n        Jenkins h = Jenkins.getInstance();\n        h.checkPermission(Item.CREATE);\n\n        if (h.getItemByFullName(name)!=null) {\n            stderr.println(\"Job '\"+name+\"' already exists\");\n            return -1;\n        }\n\n        ModifiableTopLevelItemGroup ig = h;\n        int i = name.lastIndexOf('/');\n        if (i > 0) {\n            String group = name.substring(0, i);\n            Item item = h.getItemByFullName(group);\n            if (item == null) {\n                throw new IllegalArgumentException(\"Unknown ItemGroup \" + group);\n            }\n\n            if (item instanceof ModifiableTopLevelItemGroup) {\n                ig = (ModifiableTopLevelItemGroup) item;\n            } else {\n                throw new IllegalArgumentException(\"Can't create job from CLI in \" + group);\n            }\n            name = name.substring(i + 1);\n        }\n\n        Jenkins.checkGoodName(name);\n        ig.createProjectFromXML(name, stdin);\n        return 0;\n    }"
    },
    {
        "idx": "274",
        "vuln_id": "CVE-2014-2066",
        "desc": "Session fixation vulnerability in Jenkins before 1.551 and LTS before 1.532.2 allows remote attackers to hijack web sessions via vectors involving the \"override\" of Jenkins cookies.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "8ac74c350779921598f9d5edfed39dd35de8842a",
        "method_before": "        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession();\n    }",
        "method_after": "        super.onSuccessfulAuthentication(request,response,authResult);\n        // make sure we have a session to store this successful authentication, given that we no longer\n        // let HttpSessionContextIntegrationFilter2 to create sessions.\n        // HttpSessionContextIntegrationFilter stores the updated SecurityContext object into this session later\n        // (either when a redirect is issued, via its HttpResponseWrapper, or when the execution returns to its\n        // doFilter method.\n        request.getSession().invalidate();\n        request.getSession();\n    }"
    },
    {
        "idx": "276",
        "vuln_id": "CVE-2014-2068",
        "desc": "The doIndex function in hudson/util/RemotingDiagnostics.java in CloudBees Jenkins before 1.551 and LTS before 1.532.2 allows remote authenticated users with the ADMINISTER permission to obtain sensitive information via vectors related to heapDump.",
        "cwe_id": "CWE-264",
        "cwe_name": "Permissions, Privileges, and Access Controls",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "0530a6645aac10fec005614211660e98db44b5eb",
        "method_before": "        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.ADMINISTER);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }",
        "method_after": "        public void doHeapDump(StaplerRequest req, StaplerResponse rsp) throws IOException, InterruptedException {\n            owner.checkPermission(Jenkins.RUN_SCRIPTS);\n            rsp.setContentType(\"application/octet-stream\");\n\n            FilePath dump = obtain();\n            try {\n                dump.copyTo(rsp.getCompressedOutputStream(req));\n            } finally {\n                dump.delete();\n            }\n        }"
    },
    {
        "idx": "379",
        "vuln_id": "CVE-2016-0768",
        "desc": "PostgreSQL PL/Java after 9.0 does not honor access controls on large objects.",
        "cwe_id": "CWE-284",
        "cwe_name": "Improper Access Control",
        "repo": "https://github.com/tada/pljava",
        "commit": "675254b0f17b76f05e72cba2e3b8d3e548ae7a43",
        "method_before": "\tprivate static void languages( Connection c, Statement s)\n\tthrows SQLException\n\t{\n\t\tSavepoint p = null;\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE java IS '\" +\n\t\t\t\t\"Trusted/sandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE javau IS '\" +\n\t\t\t\t\"Untrusted/unsandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\t}",
        "method_after": "\tprivate static void languages( Connection c, Statement s)\n\tthrows SQLException\n\t{\n\t\tSavepoint p = null;\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE TRUSTED LANGUAGE java HANDLER sqlj.java_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE java IS '\" +\n\t\t\t\t\"Trusted/sandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\ts.execute(\"REVOKE USAGE ON LANGUAGE java FROM PUBLIC\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\n\t\ttry\n\t\t{\n\t\t\tp = c.setSavepoint();\n\t\t\ts.execute(\n\t\t\t\t\"CREATE LANGUAGE javaU HANDLER sqlj.javau_call_handler\");\n\t\t\ts.execute(\n\t\t\t\t\"COMMENT ON LANGUAGE javau IS '\" +\n\t\t\t\t\"Untrusted/unsandboxed language for routines and types in \" +\n\t\t\t\t\"Java; http://tada.github.io/pljava/'\");\n\t\t\tc.releaseSavepoint(p);\n\t\t}\n\t\tcatch ( SQLException sqle )\n\t\t{\n\t\t\tc.rollback(p);\n\t\t\tif ( ! \"42710\".equals(sqle.getSQLState()) )\n\t\t\t\tthrow sqle;\n\t\t}\n\t}"
    },
    {
        "idx": "527",
        "vuln_id": "CVE-2016-8747",
        "desc": "An information disclosure issue was discovered in Apache Tomcat 8.5.7 to 8.5.9 and 9.0.0.M11 to 9.0.0.M15 in reverse-proxy configurations. Http11InputBuffer.java allows remote attackers to read data that was intended to be associated with a different request.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/apache/tomcat",
        "commit": "452c8094a665ef6375530e81c033da4eeb2e4865",
        "method_before": "    void nextRequest() {\n        request.recycle();\n\n        // Copy leftover bytes to the beginning of the buffer\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n        }\n        // Always reset pos to zero\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n    }",
        "method_after": "    void nextRequest() {\n        request.recycle();\n\n        // Copy leftover bytes to the beginning of the buffer\n        if (byteBuffer.remaining() > 0 && byteBuffer.position() > 0) {\n            byteBuffer.compact();\n            byteBuffer.flip();\n        }\n        // Always reset pos to zero\n        byteBuffer.limit(byteBuffer.limit() - byteBuffer.position()).position(0);\n\n        // Recycle filters\n        for (int i = 0; i <= lastActiveFilter; i++) {\n            activeFilters[i].recycle();\n        }\n\n        // Reset pointers\n        lastActiveFilter = -1;\n        parsingHeader = true;\n        swallowInput = true;\n\n        headerParsePos = HeaderParsePosition.HEADER_START;\n        parsingRequestLine = true;\n        parsingRequestLinePhase = 0;\n        parsingRequestLineEol = false;\n        parsingRequestLineStart = 0;\n        parsingRequestLineQPos = -1;\n        headerData.recycle();\n    }"
    },
    {
        "idx": "560",
        "vuln_id": "CVE-2017-12197",
        "desc": "It was found that libpam4j up to and including 1.8 did not properly validate user accounts when authenticating. A user with a valid password for a disabled account would be able to bypass security restrictions and possibly access sensitive information.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/letonez/libpam4j",
        "commit": "84f32f4001fc6bdcc125ccc959081de022d18b6d",
        "method_before": "    public UnixUser authenticate(String username, String password) throws PAMException {\n        this.password = password;\n        try {\n            check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n            check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n            check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n            // several different error code seem to be used to represent authentication failures\n//            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n\n            PointerByReference r = new PointerByReference();\n            check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n            String userName = r.getValue().getString(0);\n            passwd pwd = libc.getpwnam(userName);\n            if(pwd==null)\n                throw new PAMException(\"Authentication succeeded but no user information is available\");\n            return new UnixUser(userName,pwd);\n        } finally {\n            this.password = null;\n        }\n    }",
        "method_after": "    public UnixUser authenticate(String username, String password) throws PAMException {\n        this.password = password;\n        try {\n            check(libpam.pam_set_item(pht,PAM_USER,username),\"pam_set_item failed\");\n            check(libpam.pam_authenticate(pht,0),\"pam_authenticate failed\");\n            check(libpam.pam_setcred(pht,0),\"pam_setcred failed\");\n            check(libpam.pam_acct_mgmt(pht,0),\"pam_acct_mgmt failed\");\n\n            PointerByReference r = new PointerByReference();\n            check(libpam.pam_get_item(pht,PAM_USER,r),\"pam_get_item failed\");\n            String userName = r.getValue().getString(0);\n            passwd pwd = libc.getpwnam(userName);\n            if(pwd==null)\n                throw new PAMException(\"Authentication succeeded but no user information is available\");\n            return new UnixUser(userName,pwd);\n        } finally {\n            this.password = null;\n        }\n    }"
    },
    {
        "idx": "611",
        "vuln_id": "CVE-2017-2670",
        "desc": "It was found in Undertow before 1.3.28 that with non-clean TCP close, the Websocket server gets into infinite loop on every IO thread, effectively causing DoS.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/undertow-io/undertow",
        "commit": "9bfe9fbbb595d51157b61693f072895f7dbadd1d",
        "method_before": "    void resumeReadsInternal(boolean wakeup) {\n        synchronized (lock) {\n            boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n            state |= STATE_READS_RESUMED;\n            if (!alreadyResumed || wakeup) {\n                if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                    state |= STATE_IN_LISTENER_LOOP;\n                    getFramedChannel().runInIoThread(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                boolean moreData;\n                                do {\n                                    ChannelListener<? super R> listener = getReadListener();\n                                    if (listener == null || !isReadResumed()) {\n                                        return;\n                                    }\n                                    ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                    //if writes are shutdown or we become active then we stop looping\n                                    //we stop when writes are shutdown because we can't flush until we are active\n                                    //although we may be flushed as part of a batch\n                                    moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                }\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED) && moreData);\n                            } finally {\n                                state &= ~STATE_IN_LISTENER_LOOP;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }",
        "method_after": "    void resumeReadsInternal(boolean wakeup) {\n        synchronized (lock) {\n            boolean alreadyResumed = anyAreSet(state, STATE_READS_RESUMED);\n            state |= STATE_READS_RESUMED;\n            if (!alreadyResumed || wakeup) {\n                if (!anyAreSet(state, STATE_IN_LISTENER_LOOP)) {\n                    state |= STATE_IN_LISTENER_LOOP;\n                    getFramedChannel().runInIoThread(new Runnable() {\n\n                        @Override\n                        public void run() {\n                            try {\n                                boolean moreData;\n                                do {\n                                    ChannelListener<? super R> listener = getReadListener();\n                                    if (listener == null || !isReadResumed()) {\n                                        return;\n                                    }\n                                    ChannelListeners.invokeChannelListener((R) AbstractFramedStreamSourceChannel.this, listener);\n                                    //if writes are shutdown or we become active then we stop looping\n                                    //we stop when writes are shutdown because we can't flush until we are active\n                                    //although we may be flushed as part of a batch\n                                    moreData = (frameDataRemaining > 0 && data != null) || !pendingFrameData.isEmpty() || anyAreSet(state, STATE_WAITNG_MINUS_ONE);\n                                }\n                                while (allAreSet(state, STATE_READS_RESUMED) && allAreClear(state, STATE_CLOSED | STATE_STREAM_BROKEN) && moreData);\n                            } finally {\n                                state &= ~STATE_IN_LISTENER_LOOP;\n                            }\n                        }\n                    });\n                }\n            }\n        }\n    }"
    },
    {
        "idx": "864",
        "vuln_id": "CVE-2018-1324",
        "desc": "A specially crafted ZIP archive can be used to cause an infinite loop inside of Apache Commons Compress' extra field parser used by the ZipFile and ZipArchiveInputStream classes in versions 1.11 to 1.15. This can be used to mount a denial of service attack against services that use Compress' zip package.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "2a2f1dc48e22a34ddb72321a4db211da91aa933b",
        "method_before": "    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (int i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }",
        "method_after": "    public void parseCentralDirectoryFormat(final byte[] data, final int offset, final int length) {\n        this.format = ZipShort.getValue(data, offset);\n        this.algId = EncryptionAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 2));\n        this.bitlen = ZipShort.getValue(data, offset + 4);\n        this.flags = ZipShort.getValue(data, offset + 6);\n        this.rcount = ZipLong.getValue(data, offset + 8);\n\n        if (rcount > 0) {\n            this.hashAlg = HashAlgorithm.getAlgorithmByCode(ZipShort.getValue(data, offset + 12));\n            this.hashSize = ZipShort.getValue(data, offset + 14);\n            // srlist... hashed public keys\n            for (long i = 0; i < this.rcount; i++) {\n                for (int j = 0; j < this.hashSize; j++) {\n                    //  ZipUtil.signedByteToUnsignedInt(data[offset + 16 + (i * this.hashSize) + j]));\n                }\n            }\n        }\n    }"
    },
    {
        "idx": "906",
        "vuln_id": "CVE-2018-17202",
        "desc": "Certain input files could make the code to enter into an infinite loop when Apache Sanselan 0.97-incubator was used to parse them, which could be used in a DoS attack. Note that Apache Sanselan (incubating) was renamed to Apache Commons Imaging.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-imaging",
        "commit": "6a79d35d6654d895d0a4b73b3a9282ec9aaeeb06",
        "method_before": "    private int extend(int v, final int t) {\n        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n        int vt = (1 << (t - 1));\n        while (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }",
        "method_after": "    private int extend(int v, final int t) {\n        // \"EXTEND\", section F.2.2.1, figure F.12, page 105 of T.81\n        int vt = (1 << (t - 1));\n        if (v < vt) {\n            vt = (-1 << t) + 1;\n            v += vt;\n        }\n        return v;\n    }"
    },
    {
        "idx": "922",
        "vuln_id": "CVE-2018-1999044",
        "desc": "A denial of service vulnerability exists in Jenkins 2.137 and earlier, 2.121.2 and earlier in CronTab.java that allows attackers with Overall/Read permission to have a request handling thread enter an infinite loop.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "e5046911c57e60a1d6d8aca9b21bd9093b0f3763",
        "method_before": "        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,i-offset);\n        }",
        "method_after": "        private CalendarField(String displayName, int field, int min, int offset, boolean redoAdjustmentIfModified, CalendarField lowerField) {\n            this.displayName = displayName;\n            this.field = field;\n            this.min = min;\n            this.redoAdjustmentIfModified= redoAdjustmentIfModified;\n            this.lowerField = lowerField;\n            this.offset = offset;\n        }\n\n        /**\n         * Gets the current value of this field in the given calendar.\n         */\n        int valueOf(Calendar c) {\n            return c.get(field)+offset;\n        }\n\n        void addTo(Calendar c, int i) {\n            c.add(field,i);\n        }\n\n        void setTo(Calendar c, int i) {\n            c.set(field,Math.min(i-offset, c.getActualMaximum(field)));\n        }"
    },
    {
        "idx": "927",
        "vuln_id": "CVE-2018-20157",
        "desc": "The data import functionality in OpenRefine through 3.1 allows an XML External Entity (XXE) attack through a crafted (zip) file, allowing attackers to read arbitrary files.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/OpenRefine/OpenRefine",
        "commit": "6a0d7d56e4ffb420316ce7849fde881344fbf881",
        "method_before": "    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }",
        "method_after": "    final static private XMLStreamReader createXMLStreamReader(InputStream inputStream) throws XMLStreamException, IOException {\n        XMLInputFactory factory = XMLInputFactory.newInstance();\n        factory.setProperty(XMLInputFactory.IS_COALESCING, true);\n        factory.setProperty(XMLInputFactory.IS_REPLACING_ENTITY_REFERENCES, true);\n        factory.setProperty(XMLInputFactory.SUPPORT_DTD, false);\n        \n        return factory.createXMLStreamReader(wrapPrefixRemovingInputStream(inputStream));\n    }"
    },
    {
        "idx": "995",
        "vuln_id": "CVE-2019-0225",
        "desc": "A specially crafted url could be used to access files under the ROOT directory of the application on Apache JSPWiki 2.9.0 to 2.11.0.M2, which could be used by an attacker to obtain registered users' details.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/apache/jspwiki",
        "commit": "88d89d6523802c044cfcb7930cba40d8eeb21da2",
        "method_before": "    public String getForwardPage( HttpServletRequest request )\n    {\n        return request.getPathInfo();\n    }",
        "method_after": "    public String getForwardPage( HttpServletRequest request )\n    {\n        return \"Wiki.jsp\";\n    }"
    },
    {
        "idx": "1047",
        "vuln_id": "CVE-2019-17513",
        "desc": "An issue was discovered in Ratpack before 1.7.5. Due to a misuse of the Netty library class DefaultHttpHeaders, there is no validation that headers lack HTTP control characters. Thus, if untrusted data is used to construct HTTP headers with Ratpack, HTTP Response Splitting can occur.",
        "cwe_id": "CWE-74",
        "cwe_name": "Improper Neutralization of Special Elements in Output Used by a Downstream Component ('Injection')",
        "repo": "https://github.com/ratpack/ratpack",
        "commit": "efb910d38a96494256f36675ef0e5061097dd77d",
        "method_before": "  private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders(false);\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }",
        "method_after": "  private void newRequest(ChannelHandlerContext ctx, HttpRequest nettyRequest) throws Exception {\n    if (!nettyRequest.decoderResult().isSuccess()) {\n      LOGGER.debug(\"Failed to decode HTTP request.\", nettyRequest.decoderResult().cause());\n      sendError(ctx, HttpResponseStatus.BAD_REQUEST);\n      return;\n    }\n\n    Headers requestHeaders = new NettyHeadersBackedHeaders(nettyRequest.headers());\n\n    //Find the content length we will use this as an indicator of a body\n    Long contentLength = HttpUtil.getContentLength(nettyRequest, -1L);\n    String transferEncoding = requestHeaders.get(HttpHeaderNames.TRANSFER_ENCODING);\n\n    //If there is a content length or transfer encoding that indicates there is a body\n    boolean hasBody = (contentLength > 0) || (transferEncoding != null);\n\n    RequestBody requestBody = hasBody ? new RequestBody(contentLength, nettyRequest, ctx) : null;\n\n    Channel channel = ctx.channel();\n\n    if (requestBody != null) {\n      channel.attr(BODY_ACCUMULATOR_KEY).set(requestBody);\n    }\n    InetSocketAddress remoteAddress = (InetSocketAddress) channel.remoteAddress();\n    InetSocketAddress socketAddress = (InetSocketAddress) channel.localAddress();\n\n    ConnectionIdleTimeout connectionIdleTimeout = ConnectionIdleTimeout.of(channel);\n\n    DefaultRequest request = new DefaultRequest(\n      clock.instant(),\n      requestHeaders,\n      nettyRequest.method(),\n      nettyRequest.protocolVersion(),\n      nettyRequest.uri(),\n      remoteAddress,\n      socketAddress,\n      serverRegistry.get(ServerConfig.class),\n      requestBody,\n      connectionIdleTimeout,\n      channel.attr(CLIENT_CERT_KEY).get()\n    );\n\n    HttpHeaders nettyHeaders = new DefaultHttpHeaders();\n    MutableHeaders responseHeaders = new NettyHeadersBackedMutableHeaders(nettyHeaders);\n    AtomicBoolean transmitted = new AtomicBoolean(false);\n\n    DefaultResponseTransmitter responseTransmitter = new DefaultResponseTransmitter(transmitted, channel, clock, nettyRequest, request, nettyHeaders, requestBody);\n\n    ctx.channel().attr(DefaultResponseTransmitter.ATTRIBUTE_KEY).set(responseTransmitter);\n\n    Action<Action<Object>> subscribeHandler = thing -> {\n      transmitted.set(true);\n      ctx.channel().attr(CHANNEL_SUBSCRIBER_ATTRIBUTE_KEY).set(thing);\n    };\n\n    DefaultContext.RequestConstants requestConstants = new DefaultContext.RequestConstants(\n      applicationConstants,\n      request,\n      channel,\n      responseTransmitter,\n      subscribeHandler\n    );\n\n    Response response = new DefaultResponse(responseHeaders, ctx.alloc(), responseTransmitter);\n    requestConstants.response = response;\n\n    DefaultContext.start(channel.eventLoop(), requestConstants, serverRegistry, handlers, execution -> {\n      if (!transmitted.get()) {\n        Handler lastHandler = requestConstants.handler;\n        StringBuilder description = new StringBuilder();\n        description\n          .append(\"No response sent for \")\n          .append(request.getMethod().getName())\n          .append(\" request to \")\n          .append(request.getUri());\n\n        if (lastHandler != null) {\n          description.append(\" (last handler: \");\n\n          if (lastHandler instanceof DescribingHandler) {\n            ((DescribingHandler) lastHandler).describeTo(description);\n          } else {\n            DescribingHandlers.describeTo(lastHandler, description);\n          }\n          description.append(\")\");\n        }\n\n        String message = description.toString();\n        LOGGER.warn(message);\n\n        response.getHeaders().clear();\n\n        ByteBuf body;\n        if (development) {\n          CharBuffer charBuffer = CharBuffer.wrap(message);\n          body = ByteBufUtil.encodeString(ctx.alloc(), charBuffer, CharsetUtil.UTF_8);\n          response.contentType(HttpHeaderConstants.PLAIN_TEXT_UTF8);\n        } else {\n          body = Unpooled.EMPTY_BUFFER;\n        }\n\n        response.getHeaders().set(HttpHeaderConstants.CONTENT_LENGTH, body.readableBytes());\n        responseTransmitter.transmit(HttpResponseStatus.INTERNAL_SERVER_ERROR, body);\n      }\n    });\n  }"
    },
    {
        "idx": "1110",
        "vuln_id": "CVE-2020-1695",
        "desc": "A flaw was found in all resteasy 3.x.x versions prior to 3.12.0.Final and all resteasy 4.x.x versions prior to 4.6.0.Final, where an improper input validation results in returning an illegal header that integrates into the server's response. This flaw may result in an injection, which leads to unexpected behavior when the HTTP response is constructed.",
        "cwe_id": "CWE-20",
        "cwe_name": "Other",
        "repo": "https://github.com/resteasy/Resteasy",
        "commit": "acf15f2a8067f7e4cf5838342cecfa0b78a174fb",
        "method_before": "   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }",
        "method_after": "   protected static boolean isValid(String str)\n   {\n      if (str == null || str.length() == 0) return false;\n      for (int i = 0; i < str.length(); i++) {\n         switch (str.charAt(i))\n         {\n            case '/':\n            case '\\\\':\n            case '?':\n            case ':':\n            case '<':\n            case '>':\n            case ';':\n            case '(':\n            case ')':\n            case '@':\n            case ',':\n            case '[':\n            case ']':\n            case '=':\n            case '\\n':\n               return false;\n            default:\n               break;\n         }\n      }\n      return true;\n   }"
    },
    {
        "idx": "1112",
        "vuln_id": "CVE-2020-1698",
        "desc": "A flaw was found in keycloak in versions before 9.0.0. A logged exception in the HttpMethod class may leak the password given as parameter. The highest threat from this vulnerability is to data confidentiality.",
        "cwe_id": "CWE-532",
        "cwe_name": "Insertion of Sensitive Information into Log File",
        "repo": "https://github.com/keycloak/keycloak",
        "commit": "62c9e1577618470832ede22dcedd46cba15b1836",
        "method_before": "    public R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n    }",
        "method_after": "    public R execute(HttpResponseProcessor<R> responseProcessor) {\n        byte[] bytes = null;\n\n        try {\n            for (Map.Entry<String, String> header : this.headers.entrySet()) {\n                this.builder.setHeader(header.getKey(), header.getValue());\n            }\n\n            preExecute(this.builder);\n\n            HttpResponse response = this.httpClient.execute(this.builder.build());\n            HttpEntity entity = response.getEntity();\n\n            if (entity != null) {\n                bytes = EntityUtils.toByteArray(entity);\n            }\n\n            StatusLine statusLine = response.getStatusLine();\n            int statusCode = statusLine.getStatusCode();\n\n            if (statusCode < 200 || statusCode >= 300) {\n                throw new HttpResponseException(\"Unexpected response from server: \" + statusCode + \" / \" + statusLine.getReasonPhrase(), statusCode, statusLine.getReasonPhrase(), bytes);\n            }\n\n            if (bytes == null) {\n                return null;\n            }\n\n            return responseProcessor.process(bytes);\n        } catch (HttpResponseException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(\"Error executing http method [\" + builder.getMethod() + \"]. Response : \" + String.valueOf(bytes), e);\n        }\n    }"
    },
    {
        "idx": "1135",
        "vuln_id": "CVE-2020-4070",
        "desc": "In CSS Validator less than or equal to commit 54d68a1, there is a cross-site scripting vulnerability in handling URIs. A user would have to click on a specifically crafted validator link to trigger it. This has been patched in commit e5c09a9.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/w3c/css-validator",
        "commit": "e5c09a9119167d3064db786d5f00d730b584a53b",
        "method_before": "    public void parseURL(ApplContext ac, URL url, String title,\n                         String kind, String media,\n                         int origin) {\n        boolean doneref = false;\n        URL ref = ac.getReferrer();\n        setWarningLevel(ac.getWarningLevel());\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseURL(\" + url + \", \"\n                    + title + \", \"\n                    + kind + \", \" + media + \", \"\n                    + origin + \")\");\n        }\n        if (kind != null) {\n            kind = kind.trim().toLowerCase();\n            if (!kind.equals(\"stylesheet\") && !kind.equals(\"alternate stylesheet\")) {\n                return;\n            }\n        }\n        try {\n            ac.setOrigin(origin);\n//\t    if (cssFouffa == null) {\n            cssFouffa = new CssFouffa(ac, url);\n            cssFouffa.addListener(this);\n//\t    } else {\n//\t\tcssFouffa.ReInit(ac, url);\n//\t    }\n\n            //\t    cssFouffa.setResponse(res);\n\n            // removed plh 2001-03-08\n            // cssFouffa.setOrigin(origin);\n            //\t    cssFouffa.setDefaultMedium(defaultmedium);\n            //\t    cssFouffa.doConfig();\n            if (media == null) {\n                if (ac.getCssVersion() != CssVersion.CSS1) {\n                    if (ac.getMedium() == null) {\n                        media = \"all\";\n                    } else {\n                        media = ac.getMedium();\n                    }\n                }\n            }\n            AtRuleMedia m = AtRuleMedia.getInstance(ac.getCssVersion());\n            try {\n                if (media != null) {\n                    addMedias(m, media, ac);\n                }\n                cssFouffa.setAtRule(m);\n            } catch (org.w3c.css.util.InvalidParamException e) {\n                Errors er = new Errors();\n                er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                        -1, e));\n                notifyErrors(er);\n                return;\n            }\n            ac.setReferrer(url);\n            doneref = true;\n            cssFouffa.parseStyle();\n        } catch (Exception e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(Messages.escapeString(url.toString()),\n                    -1, e));\n            notifyErrors(er);\n        } finally {\n            if (doneref) {\n                ac.setReferrer(ref);\n            }\n        }\n    }",
        "method_after": "    public void parseURL(ApplContext ac, URL url, String title,\n                         String kind, String media,\n                         int origin) {\n        boolean doneref = false;\n        URL ref = ac.getReferrer();\n        setWarningLevel(ac.getWarningLevel());\n        if (Util.onDebug) {\n            System.err.println(\"StyleSheet.parseURL(\" + url + \", \"\n                    + title + \", \"\n                    + kind + \", \" + media + \", \"\n                    + origin + \")\");\n        }\n        if (kind != null) {\n            kind = kind.trim().toLowerCase();\n            if (!kind.equals(\"stylesheet\") && !kind.equals(\"alternate stylesheet\")) {\n                return;\n            }\n        }\n        try {\n            ac.setOrigin(origin);\n//\t    if (cssFouffa == null) {\n            cssFouffa = new CssFouffa(ac, url);\n            cssFouffa.addListener(this);\n//\t    } else {\n//\t\tcssFouffa.ReInit(ac, url);\n//\t    }\n\n            //\t    cssFouffa.setResponse(res);\n\n            // removed plh 2001-03-08\n            // cssFouffa.setOrigin(origin);\n            //\t    cssFouffa.setDefaultMedium(defaultmedium);\n            //\t    cssFouffa.doConfig();\n            if (media == null) {\n                if (ac.getCssVersion() != CssVersion.CSS1) {\n                    if (ac.getMedium() == null) {\n                        media = \"all\";\n                    } else {\n                        media = ac.getMedium();\n                    }\n                }\n            }\n            AtRuleMedia m = AtRuleMedia.getInstance(ac.getCssVersion());\n            try {\n                if (media != null) {\n                    addMedias(m, media, ac);\n                }\n                cssFouffa.setAtRule(m);\n            } catch (org.w3c.css.util.InvalidParamException e) {\n                Errors er = new Errors();\n                er.addError(new org.w3c.css.parser.CssError(url.toString(),\n                        -1, e));\n                notifyErrors(er);\n                return;\n            }\n            ac.setReferrer(url);\n            doneref = true;\n            cssFouffa.parseStyle();\n        } catch (Exception e) {\n            Errors er = new Errors();\n            er.addError(new org.w3c.css.parser.CssError(Messages.escapeString(url.toString()),\n                    -1, new Exception(Messages.escapeString(e.getMessage()))));\n            notifyErrors(er);\n        } finally {\n            if (doneref) {\n                ac.setReferrer(ref);\n            }\n        }\n    }"
    },
    {
        "idx": "1561",
        "vuln_id": "CVE-2020-21522",
        "desc": "An issue was discovered in halo V1.1.3. A Zip Slip Directory Traversal Vulnerability in the backend,the attacker can overwrite some files, such as ftl files, .bashrc files in the user directory, and finally get the permissions of the operating system.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/halo-dev/halo",
        "commit": "d59877a9ce82b53ec27c7f012a5703280e2cfd4f",
        "method_before": "    public static void checkDirectoryTraversal(@NonNull Path parentPath, @NonNull Path pathToCheck) {\n        Assert.notNull(parentPath, \"Parent path must not be null\");\n        Assert.notNull(pathToCheck, \"Path to check must not be null\");\n\n        if (pathToCheck.startsWith(parentPath.normalize())) {\n            return;\n        }\n\n        throw new ForbiddenException(\"\u4f60\u6ca1\u6709\u6743\u9650\u8bbf\u95ee \" + pathToCheck).setErrorData(pathToCheck);\n    }",
        "method_after": "    public static void checkDirectoryTraversal(@NonNull Path parentPath, @NonNull Path pathToCheck) {\n        Assert.notNull(parentPath, \"Parent path must not be null\");\n        Assert.notNull(pathToCheck, \"Path to check must not be null\");\n\n        if (pathToCheck.normalize().startsWith(parentPath)) {\n            return;\n        }\n\n        throw new ForbiddenException(\"\u4f60\u6ca1\u6709\u6743\u9650\u8bbf\u95ee \" + pathToCheck).setErrorData(pathToCheck);\n    }"
    },
    {
        "idx": "82",
        "vuln_id": "CVE-2011-1582",
        "desc": "Apache Tomcat 7.0.12 and 7.0.13 processes the first request to a servlet without following security constraints that have been configured through annotations, which allows remote attackers to bypass intended access restrictions via HTTP requests. NOTE: this vulnerability exists because of an incomplete fix for CVE-2011-1088, CVE-2011-1183, and CVE-2011-1419.",
        "cwe_id": "CWE-264",
        "cwe_name": "Permissions, Privileges, and Access Controls",
        "repo": "https://github.com/apache/tomcat",
        "commit": "299b26af66793438c323ea6b18462fa44683080f",
        "method_before": "    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParentClassLoader().loadClass(getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }",
        "method_after": "    public void servletSecurityAnnotationScan() throws ServletException {\n        if (getServlet() == null) {\n            Class<?> clazz = null;\n            try {\n                clazz = getParent().getLoader().getClassLoader().loadClass(\n                        getServletClass());\n                processServletSecurityAnnotation(clazz);\n            } catch (ClassNotFoundException e) {\n                // Safe to ignore. No class means no annotations to process\n            }\n        } else {\n            if (servletSecurityAnnotationScanRequired) {\n                processServletSecurityAnnotation(getServlet().getClass());\n            }\n        }\n    }"
    },
    {
        "idx": "512",
        "vuln_id": "CVE-2016-7051",
        "desc": "XmlMapper in the Jackson XML dataformat component (aka jackson-dataformat-xml) before 2.7.8 and 2.8.x before 2.8.4 allows remote attackers to conduct server-side request forgery (SSRF) attacks via vectors related to a DTD.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/FasterXML/jackson-dataformat-xml",
        "commit": "eeff2c312e9d4caa8c9f27b8f740c7529d00524a",
        "method_before": "    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }",
        "method_after": "    protected XmlFactory(ObjectCodec oc, int xpFeatures, int xgFeatures,\n            XMLInputFactory xmlIn, XMLOutputFactory xmlOut,\n            String nameForTextElem)\n    {\n        super(oc);\n        _xmlParserFeatures = xpFeatures;\n        _xmlGeneratorFeatures = xgFeatures;\n        _cfgNameForTextElement = nameForTextElem;\n        if (xmlIn == null) {\n            xmlIn = XMLInputFactory.newInstance();\n            // as per [dataformat-xml#190], disable external entity expansion by default\n            xmlIn.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, Boolean.FALSE);\n            // and ditto wrt [dataformat-xml#211], SUPPORT_DTD\n            xmlIn.setProperty(XMLInputFactory.SUPPORT_DTD, Boolean.FALSE);\n        }\n        if (xmlOut == null) {\n            xmlOut = XMLOutputFactory.newInstance();\n        }\n        _initFactories(xmlIn, xmlOut);\n        _xmlInputFactory = xmlIn;\n        _xmlOutputFactory = xmlOut;\n    }"
    },
    {
        "idx": "593",
        "vuln_id": "CVE-2017-12795",
        "desc": "OpenMRS openmrs-module-htmlformentry 3.3.2 is affected by: (Improper Input Validation).",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/openmrs/openmrs-module-htmlformentry",
        "commit": "86f35221c8a57cdd7557ce731a56b90db216c8e0",
        "method_before": "\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}",
        "method_after": "\tpublic void handleRequest(Model model, @RequestParam(value = \"filePath\", required = false) String filePath,\n\t                          @RequestParam(value = \"patientId\", required = false) Integer pId,\n\t                          @RequestParam(value = \"isFileUpload\", required = false) boolean isFileUpload,\n\t                          HttpServletRequest request) throws Exception {\n\n        Context.requirePrivilege(\"Manage Forms\");\n\t\t\n\t\tif (log.isDebugEnabled())\n\t\t\tlog.debug(\"In reference data...\");\n\t\t\n\t\tmodel.addAttribute(\"previewHtml\", \"\");\n\t\tString message = \"\";\n\t\tFile f = null;\n\t\ttry {\n\t\t\tif (isFileUpload) {\n\t\t\t\tMultipartHttpServletRequest multipartRequest = (MultipartHttpServletRequest) request;\n\t\t\t\tMultipartFile multipartFile = multipartRequest.getFile(\"htmlFormFile\");\n\t\t\t\tif (multipartFile != null) {\n\t\t\t\t\t//use the same file for the logged in user\n\t\t\t\t\tf = new File(SystemUtils.JAVA_IO_TMPDIR, TEMP_HTML_FORM_FILE_PREFIX\n\t\t\t\t\t        + Context.getAuthenticatedUser().getSystemId());\n\t\t\t\t\tif (!f.exists())\n\t\t\t\t\t\tf.createNewFile();\n\t\t\t\t\t\n\t\t\t\t\tfilePath = f.getAbsolutePath();\n\t\t\t\t\tFileOutputStream fileOut = new FileOutputStream(f);\n\t\t\t\t\tIOUtils.copy(multipartFile.getInputStream(), fileOut);\n\t\t\t\t\tfileOut.close();\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tif (StringUtils.hasText(filePath)) {\n\t\t\t\t\tf = new File(filePath);\n\t\t\t\t} else {\n\t\t\t\t\tmessage = \"You must specify a file path to preview from file\";\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\tif (f != null && f.exists() && f.canRead()) {\n\t\t\t\tmodel.addAttribute(\"filePath\", filePath);\n\t\t\t\t\n\t\t\t\tStringWriter writer = new StringWriter();\n\t\t\t\tIOUtils.copy(new FileInputStream(f), writer, \"UTF-8\");\n\t\t\t\tString xml = writer.toString();\n\t\t\t\t\n\t\t\t\tPatient p = null;\n\t\t\t\tif (pId != null) {\n\t\t\t\t\tp = Context.getPatientService().getPatient(pId);\n\t\t\t\t} else {\n\t\t\t\t\tp = HtmlFormEntryUtil.getFakePerson();\n\t\t\t\t}\n\t\t\t\tHtmlForm fakeForm = new HtmlForm();\n\t\t\t\tfakeForm.setXmlData(xml);\n\t\t\t\tFormEntrySession fes = new FormEntrySession(p, null, Mode.ENTER, fakeForm, request.getSession());\n\t\t\t\tString html = fes.getHtmlToDisplay();\n\t\t\t\tif (fes.getFieldAccessorJavascript() != null) {\n                \thtml += \"<script>\" + fes.getFieldAccessorJavascript() + \"</script>\";\n                }\n\t\t\t\tmodel.addAttribute(\"previewHtml\", html);\n\t\t\t\t//clear the error message\n\t\t\t\tmessage = \"\";\n\t\t\t} else {\n\t\t\t\tmessage = \"Please specify a valid file path or select a valid file.\";\n\t\t\t}\n\t\t}\n\t\tcatch (Exception e) {\n\t\t\tlog.error(\"An error occurred while loading the html.\", e);\n\t\t\tmessage = \"An error occurred while loading the html. \" + e.getMessage();\n\t\t}\n\t\t\n\t\tmodel.addAttribute(\"message\", message);\n\t\tmodel.addAttribute(\"isFileUpload\", isFileUpload);\n\t}"
    },
    {
        "idx": "695",
        "vuln_id": "CVE-2017-8028",
        "desc": "In Pivotal Spring-LDAP versions 1.3.0 - 2.3.1, when connected to some LDAP servers, when no additional attributes are bound, and when using LDAP BindAuthenticator with org.springframework.ldap.core.support.DefaultTlsDirContextAuthenticationStrategy as the authentication strategy, and setting userSearch, authentication is allowed with an arbitrary password when the username is correct. This occurs because some LDAP vendors require an explicit operation for the LDAP bind to take effect.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/spring-projects/spring-ldap",
        "commit": "08e8ae289bbd1b581986c7238604a147119c1336",
        "method_before": "\tprotected void applyAuthentication(LdapContext ctx, String userDn, String password) throws NamingException {\n\t\tctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION);\n\t\tctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDn);\n\t\tctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n\t}",
        "method_after": "\tprotected void applyAuthentication(LdapContext ctx, String userDn, String password) throws NamingException {\n\t\tctx.addToEnvironment(Context.SECURITY_AUTHENTICATION, SIMPLE_AUTHENTICATION);\n\t\tctx.addToEnvironment(Context.SECURITY_PRINCIPAL, userDn);\n\t\tctx.addToEnvironment(Context.SECURITY_CREDENTIALS, password);\n\t\t// Force reconnect with user credentials\n\t\tctx.reconnect(null);\n\t}"
    },
    {
        "idx": "714",
        "vuln_id": "CVE-2018-1000008",
        "desc": "Jenkins PMD Plugin 3.49 and earlier processes XML external entities in files it parses as part of the build process, allowing attackers with user permissions in Jenkins to extract secrets from the Jenkins master, perform server-side request forgery, or denial-of-service attacks.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/jenkinsci/pmd-plugin",
        "commit": "f88399a021c22e30cb8fbac5200471d69f1b6224",
        "method_before": "    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            Digester digester = new Digester();\n            digester.setValidating(false);\n            digester.setClassLoader(PmdParser.class.getClassLoader());\n\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }",
        "method_after": "    public Collection<FileAnnotation> parse(final InputStream file, final String moduleName) throws InvocationTargetException {\n        try {\n            SecureDigester digester = new SecureDigester(PmdParser.class);\n\n            String rootXPath = \"pmd\";\n            digester.addObjectCreate(rootXPath, Pmd.class);\n            digester.addSetProperties(rootXPath);\n\n            String fileXPath = \"pmd/file\";\n            digester.addObjectCreate(fileXPath, hudson.plugins.pmd.parser.File.class);\n            digester.addSetProperties(fileXPath);\n            digester.addSetNext(fileXPath, \"addFile\", hudson.plugins.pmd.parser.File.class.getName());\n\n            String bugXPath = \"pmd/file/violation\";\n            digester.addObjectCreate(bugXPath, Violation.class);\n            digester.addSetProperties(bugXPath);\n            digester.addCallMethod(bugXPath, \"setMessage\", 0);\n            digester.addSetNext(bugXPath, \"addViolation\", Violation.class.getName());\n\n            Pmd module = (Pmd)digester.parse(file);\n            if (module == null) {\n                throw new SAXException(\"Input stream is not a PMD file.\");\n            }\n\n            return convert(module, moduleName);\n        }\n        catch (IOException exception) {\n            throw new InvocationTargetException(exception);\n        }\n        catch (SAXException exception) {\n            throw new InvocationTargetException(exception);\n        }\n    }"
    },
    {
        "idx": "719",
        "vuln_id": "CVE-2018-1000067",
        "desc": "An improper authorization vulnerability exists in Jenkins versions 2.106 and earlier, and LTS 2.89.3 and earlier, that allows an attacker to have Jenkins submit HTTP GET requests and get limited information about the response.",
        "cwe_id": "CWE-918",
        "cwe_name": "Server-Side Request Forgery (SSRF)",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "2d16b459205730d85e51499c2457109b234ca9d9",
        "method_before": "    public static class DescriptorImpl extends Descriptor<ProxyConfiguration> {\n        @Override\n        public String getDisplayName() {\n            return \"Proxy Configuration\";\n        }\n\n        public FormValidation doCheckPort(@QueryParameter String value) {\n            value = Util.fixEmptyAndTrim(value);\n            if (value == null) {\n                return FormValidation.ok();\n            }\n            int port;\n            try {\n                port = Integer.parseInt(value);\n            } catch (NumberFormatException e) {\n                return FormValidation.error(Messages.PluginManager_PortNotANumber());\n            }\n            if (port < 0 || port > 65535) {\n                return FormValidation.error(Messages.PluginManager_PortNotInRange(0, 65535));\n            }\n            return FormValidation.ok();\n        }\n\n        @RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n                \n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n                \n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n            \n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }",
        "method_after": "    public static class DescriptorImpl extends Descriptor<ProxyConfiguration> {\n        @Override\n        public String getDisplayName() {\n            return \"Proxy Configuration\";\n        }\n\n        public FormValidation doCheckPort(@QueryParameter String value) {\n            value = Util.fixEmptyAndTrim(value);\n            if (value == null) {\n                return FormValidation.ok();\n            }\n            int port;\n            try {\n                port = Integer.parseInt(value);\n            } catch (NumberFormatException e) {\n                return FormValidation.error(Messages.PluginManager_PortNotANumber());\n            }\n            if (port < 0 || port > 65535) {\n                return FormValidation.error(Messages.PluginManager_PortNotInRange(0, 65535));\n            }\n            return FormValidation.ok();\n        }\n\n        @RequirePOST\n        public FormValidation doValidateProxy(\n                @QueryParameter(\"testUrl\") String testUrl, @QueryParameter(\"name\") String name, @QueryParameter(\"port\") int port,\n                @QueryParameter(\"userName\") String userName, @QueryParameter(\"password\") String password,\n                @QueryParameter(\"noProxyHost\") String noProxyHost) {\n\n            Jenkins.getInstance().checkPermission(Jenkins.ADMINISTER);\n\n            if (Util.fixEmptyAndTrim(testUrl) == null) {\n                return FormValidation.error(Messages.ProxyConfiguration_TestUrlRequired());\n            }\n\n            String host = testUrl;\n            try {\n                URL url = new URL(testUrl);\n                host = url.getHost();\n            } catch (MalformedURLException e) {\n                return FormValidation.error(Messages.ProxyConfiguration_MalformedTestUrl(testUrl));\n            }\n\n            GetMethod method = null;\n            try {\n                method = new GetMethod(testUrl);\n                method.getParams().setParameter(\"http.socket.timeout\", DEFAULT_CONNECT_TIMEOUT_MILLIS > 0 ? DEFAULT_CONNECT_TIMEOUT_MILLIS : new Integer(30 * 1000));\n                \n                HttpClient client = new HttpClient();\n                if (Util.fixEmptyAndTrim(name) != null && !isNoProxyHost(host, noProxyHost)) {\n                    client.getHostConfiguration().setProxy(name, port);\n                    Credentials credentials = createCredentials(userName, password);\n                    AuthScope scope = new AuthScope(AuthScope.ANY_HOST, AuthScope.ANY_PORT);\n                    client.getState().setProxyCredentials(scope, credentials);\n                }\n                \n                int code = client.executeMethod(method);\n                if (code != HttpURLConnection.HTTP_OK) {\n                    return FormValidation.error(Messages.ProxyConfiguration_FailedToConnect(testUrl, code));\n                }\n            } catch (IOException e) {\n                return FormValidation.error(e, Messages.ProxyConfiguration_FailedToConnectViaProxy(testUrl));\n            } finally {\n                if (method != null) {\n                    method.releaseConnection();\n                }\n            }\n            \n            return FormValidation.ok(Messages.ProxyConfiguration_Success());\n        }"
    },
    {
        "idx": "780",
        "vuln_id": "CVE-2018-11771",
        "desc": "When reading a specially crafted ZIP archive, the read method of Apache Commons Compress 1.7 to 1.17's ZipArchiveInputStream can fail to return the correct EOF indication after the end of the stream has been reached. When combined with a java.io.InputStreamReader this can lead to an infinite stream, which can be used to mount a denial of service attack against services that use Compress' zip package.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "a41ce6892cb0590b2e658704434ac0dbcb6834c8",
        "method_before": "    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                return -1;\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }",
        "method_after": "    private int readStored(final byte[] buffer, final int offset, final int length) throws IOException {\n\n        if (current.hasDataDescriptor) {\n            if (lastStoredEntry == null) {\n                readStoredEntry();\n            }\n            return lastStoredEntry.read(buffer, offset, length);\n        }\n\n        final long csize = current.entry.getSize();\n        if (current.bytesRead >= csize) {\n            return -1;\n        }\n\n        if (buf.position() >= buf.limit()) {\n            buf.position(0);\n            final int l = in.read(buf.array());\n            if (l == -1) {\n                buf.limit(0);\n                throw new IOException(\"Truncated ZIP file\");\n            }\n            buf.limit(l);\n\n            count(l);\n            current.bytesReadFromStream += l;\n        }\n\n        int toRead = Math.min(buf.remaining(), length);\n        if ((csize - current.bytesRead) < toRead) {\n            // if it is smaller than toRead then it fits into an int\n            toRead = (int) (csize - current.bytesRead);\n        }\n        buf.get(buffer, offset, toRead);\n        current.bytesRead += toRead;\n        return toRead;\n    }"
    },
    {
        "idx": "882",
        "vuln_id": "CVE-2018-15531",
        "desc": "JavaMelody before 1.74.0 has XXE via parseSoapMethodName in bull/javamelody/PayloadNameRequestWrapper.java.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/javamelody/javamelody",
        "commit": "ef111822562d0b9365bd3e671a75b65bd0613353",
        "method_before": "\tprivate static String parseSoapMethodName(InputStream stream, String charEncoding) {\n\t\ttry {\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfinal XMLStreamReader xmlReader;\n\t\t\tif (charEncoding != null) {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\n\t\t\t} else {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\n\t\t\t}\n\n\t\t\t//best-effort parsing\n\n\t\t\t//start document, go to first tag\n\t\t\txmlReader.nextTag();\n\n\t\t\t//expect first tag to be \"Envelope\"\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\t//scan for body tag\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\txmlReader.nextTag();\n\n\t\t\t//tag is method name\n\t\t\treturn \".\" + xmlReader.getLocalName();\n\t\t} catch (final XMLStreamException e) {\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\n\t\t\t//failed\n\t\t\treturn null;\n\t\t}\n\t}",
        "method_after": "\tprivate static String parseSoapMethodName(InputStream stream, String charEncoding) {\n\t\ttry {\n\t\t\t// newInstance() et pas newFactory() pour java 1.5 (issue 367)\n\t\t\tfinal XMLInputFactory factory = XMLInputFactory.newInstance();\n\t\t\tfactory.setProperty(XMLInputFactory.SUPPORT_DTD, false); // disable DTDs entirely for that factory\n\t\t\tfactory.setProperty(XMLInputFactory.IS_SUPPORTING_EXTERNAL_ENTITIES, false); // disable external entities\n\t\t\tfinal XMLStreamReader xmlReader;\n\t\t\tif (charEncoding != null) {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream, charEncoding);\n\t\t\t} else {\n\t\t\t\txmlReader = factory.createXMLStreamReader(stream);\n\t\t\t}\n\n\t\t\t//best-effort parsing\n\n\t\t\t//start document, go to first tag\n\t\t\txmlReader.nextTag();\n\n\t\t\t//expect first tag to be \"Envelope\"\n\t\t\tif (!\"Envelope\".equals(xmlReader.getLocalName())) {\n\t\t\t\tLOG.debug(\"Unexpected first tag of SOAP request: '\" + xmlReader.getLocalName()\n\t\t\t\t\t\t+ \"' (expected 'Envelope')\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\t//scan for body tag\n\t\t\tif (!scanForChildTag(xmlReader, \"Body\")) {\n\t\t\t\tLOG.debug(\"Unable to find SOAP 'Body' tag\");\n\t\t\t\treturn null; //failed\n\t\t\t}\n\n\t\t\txmlReader.nextTag();\n\n\t\t\t//tag is method name\n\t\t\treturn \".\" + xmlReader.getLocalName();\n\t\t} catch (final XMLStreamException e) {\n\t\t\tLOG.debug(\"Unable to parse SOAP request\", e);\n\t\t\t//failed\n\t\t\treturn null;\n\t\t}\n\t}"
    },
    {
        "idx": "1010",
        "vuln_id": "CVE-2019-1010245",
        "desc": "The Linux Foundation ONOS SDN Controller 1.15 and earlier versions is affected by: Improper Input Validation. The impact is: A remote attacker can execute arbitrary commands on the controller. The component is: apps/yang/src/main/java/org/onosproject/yang/impl/YangLiveCompilerManager.java. The attack vector is: network connectivity. The fixed version is: 1.15.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/opennetworkinglab/onos",
        "commit": "c6455baca3ad15813ffb4f2a78f56b897c9ee5b6",
        "method_before": "    public static String getValidModelId(String id) throws\n            IllegalArgumentException {\n        // checking weather modelId contains the alphanumeric character or not.\n        if (id.matches(\".*[A-Za-z0-9].*\")) {\n            // replacing special characters with '_'\n            id = id.replaceAll(\"[\\\\s\\\\/:*?\\\"\\\\[\\\\]<>|$@!#%&(){}';.,-]\", \"_\");\n            // remove leading and trailing underscore\n            id = id.replaceAll(\"^_+|_+$\", \"\");\n            // replacing the consecutive underscores '_' to single _\n            id = id.replaceAll(\"_+\", \"_\");\n            return id;\n        } else {\n            throw new IllegalArgumentException(\"Invalid model id \" + id);\n        }\n    }",
        "method_after": "    public static String getValidModelId(String id) throws\n            IllegalArgumentException {\n        // checking whether modelId contains the alphanumeric character or not.\n        if (id.matches(\".*[A-Za-z0-9].*\")) {\n            // replacing special characters with '_'\n            id = id.replaceAll(\"[\\\\s\\\\/:*?\\\"\\\\[\\\\]<>|$@!#%&(){}'`;.,-]\", \"_\");\n            // remove leading and trailing underscore\n            id = id.replaceAll(\"^_+|_+$\", \"\");\n            // replacing the consecutive underscores '_' to single _\n            id = id.replaceAll(\"_+\", \"_\");\n            return id;\n        } else {\n            throw new IllegalArgumentException(\"Invalid model id \" + id);\n        }\n    }"
    },
    {
        "idx": "1034",
        "vuln_id": "CVE-2019-11772",
        "desc": "In Eclipse OpenJ9 prior to 0.15, the String.getBytes(int, int, byte[], int) method does not verify that the provided byte array is non-null nor that the provided index is in bounds when compiled by the JIT. This allows arbitrary writes to any 32-bit address or beyond the end of a byte array within Java code run under a SecurityManager.",
        "cwe_id": "CWE-787",
        "cwe_name": "Out-of-bounds Write",
        "repo": "https://github.com/eclipse/openj9",
        "commit": "f1244665be5ac08b1e16f6ed80574529a62392cb",
        "method_before": "\tpublic void getBytes(int start, int end, byte[] data, int index) {\n\t\tif (0 <= start && start <= end && end <= lengthInternal()) {\n\t\t\t// Check if the String is compressed\n\t\t\tif (enableCompression && (null == compressionFlag || coder == LATIN1)) {\n\t\t\t\tcompressedArrayCopy(value, start, data, index, end - start);\n\t\t\t} else {\n\t\t\t\tcompress(value, start, data, index, end - start);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new StringIndexOutOfBoundsException();\n\t\t}\n\t}",
        "method_after": "\tpublic void getBytes(int start, int end, byte[] data, int index) {\n\t\tif (0 <= start && start <= end && end <= lengthInternal() && 0 <= index && ((end - start) <= (data.length - index))) {\n\t\t\t// Check if the String is compressed\n\t\t\tif (enableCompression && (null == compressionFlag || coder == LATIN1)) {\n\t\t\t\tcompressedArrayCopy(value, start, data, index, end - start);\n\t\t\t} else {\n\t\t\t\tcompress(value, start, data, index, end - start);\n\t\t\t}\n\t\t} else {\n\t\t\tthrow new StringIndexOutOfBoundsException();\n\t\t}\n\t}"
    },
    {
        "idx": "538",
        "vuln_id": "CVE-2017-1000355",
        "desc": "Jenkins versions 2.56 and earlier as well as 2.46.1 LTS and earlier are vulnerable to an XStream: Java crash when trying to instantiate void/Void.",
        "cwe_id": "CWE-502",
        "cwe_name": "Deserialization of Untrusted Data",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "701ea95a52afe53bee28f76a3f96eb0e578852e9",
        "method_before": "    private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }",
        "method_after": "    private void init() {\n        // list up types that should be marshalled out like a value, without referential integrity tracking.\n        addImmutableType(Result.class);\n\n        // http://www.openwall.com/lists/oss-security/2017/04/03/4\n        denyTypes(new Class[] { void.class, Void.class });\n\n        registerConverter(new RobustCollectionConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new RobustMapConverter(getMapper()), 10);\n        registerConverter(new ImmutableMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSortedSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableSetConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ImmutableListConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new ConcurrentHashMapConverter(getMapper(),getReflectionProvider()),10);\n        registerConverter(new CopyOnWriteMap.Tree.ConverterImpl(getMapper()),10); // needs to override MapConverter\n        registerConverter(new DescribableList.ConverterImpl(getMapper()),10); // explicitly added to handle subtypes\n        registerConverter(new Label.ConverterImpl(),10);\n\n        // this should come after all the XStream's default simpler converters,\n        // but before reflection-based one kicks in.\n        registerConverter(new AssociatedConverterImpl(this), -10);\n\n        registerConverter(new BlacklistedTypesConverter(), PRIORITY_VERY_HIGH); // SECURITY-247 defense\n\n        registerConverter(new DynamicProxyConverter(getMapper()) { // SECURITY-105 defense\n            @Override public boolean canConvert(Class type) {\n                return /* this precedes NullConverter */ type != null && super.canConvert(type);\n            }\n            @Override public Object unmarshal(HierarchicalStreamReader reader, UnmarshallingContext context) {\n                throw new ConversionException(\"<dynamic-proxy> not supported\");\n            }\n        }, PRIORITY_VERY_HIGH);\n    }"
    },
    {
        "idx": "716",
        "vuln_id": "CVE-2018-1000054",
        "desc": "Jenkins CCM Plugin 3.1 and earlier processes XML external entities in files it parses as part of the build process, allowing attackers with user permissions in Jenkins to extract secrets from the Jenkins master, perform server-side request forgery, or denial-of-service attacks.",
        "cwe_id": "CWE-918",
        "cwe_name": "Server-Side Request Forgery (SSRF)",
        "repo": "https://github.com/jenkinsci/ccm-plugin",
        "commit": "066cb43b4413b3490d822ec8b8a32072ebd213ca",
        "method_before": "\tprivate Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tDigester digester = new Digester();\n\t\tdigester.setValidating(false);\n\t\tdigester.setClassLoader(CcmParser.class.getClassLoader());\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}",
        "method_after": "\tprivate Ccm parseCCMXmlFile(InputStream ccmXmlFile) throws IOException, SAXException {\n\t\tSecureDigester digester = new SecureDigester(CcmParser.class);\n\n\t\tString rootXPath = \"ccm\";\n\t\tdigester.addObjectCreate(rootXPath, Ccm.class);\n\t\tdigester.addSetProperties(rootXPath);\n\n\t\tString fileMetric = \"ccm/metric\";\n\t\tdigester.addObjectCreate(fileMetric, Metric.class);\n\t\tdigester.addSetProperties(fileMetric);\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/complexity\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/unit\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/classification\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/file\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/startLineNumber\");\n\t\tdigester.addBeanPropertySetter(\"ccm/metric/endLineNumber\");\n\t\tdigester.addSetNext(fileMetric, \"addMetric\", Metric.class.getName());\n\n\t\treturn (Ccm)digester.parse(ccmXmlFile);\n\t}"
    },
    {
        "idx": "720",
        "vuln_id": "CVE-2018-1000068",
        "desc": "An improper input validation vulnerability exists in Jenkins versions 2.106 and earlier, and LTS 2.89.3 and earlier, that allows an attacker to access plugin resource files in the META-INF and WEB-INF directories that should not be accessible, if the Jenkins home directory is on a case-insensitive file system.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "8830d68f5fe21f344be3496984bc4470bfcd0564",
        "method_before": "    public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || path.contains(\"META-INF\") || path.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }",
        "method_after": "    public void doDynamic(StaplerRequest req, StaplerResponse rsp) throws IOException, ServletException {\n        String path = req.getRestOfPath();\n\n        String pathUC = path.toUpperCase(Locale.ENGLISH);\n        if (path.isEmpty() || path.contains(\"..\") || path.contains(\"%\") || pathUC.contains(\"META-INF\") || pathUC.contains(\"WEB-INF\")) {\n            LOGGER.warning(\"rejecting possibly malicious \" + req.getRequestURIWithQueryString());\n            rsp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n            return;\n        }\n\n        // Stapler routes requests like the \"/static/.../foo/bar/zot\" to be treated like \"/foo/bar/zot\"\n        // and this is used to serve long expiration header, by using Jenkins.VERSION_HASH as \"...\"\n        // to create unique URLs. Recognize that and set a long expiration header.\n        String requestPath = req.getRequestURI().substring(req.getContextPath().length());\n        boolean staticLink = requestPath.startsWith(\"/static/\");\n\n        long expires = staticLink ? TimeUnit2.DAYS.toMillis(365) : -1;\n\n        // use serveLocalizedFile to support automatic locale selection\n        rsp.serveLocalizedFile(req, new URL(wrapper.baseResourceURL, '.' + path), expires);\n    }"
    },
    {
        "idx": "831",
        "vuln_id": "CVE-2018-12691",
        "desc": "Time-of-check to time-of-use (TOCTOU) race condition in org.onosproject.acl (aka the access control application) in ONOS v1.13 and earlier allows attackers to bypass network access control via data plane packet injection.",
        "cwe_id": "CWE-362",
        "cwe_name": "Concurrent Execution using Shared Resource with Improper Synchronization ('Race Condition')",
        "repo": "https://github.com/opennetworkinglab/onos",
        "commit": "4b931a988e2f6b547769ba70c815aaea4fe6b5d0",
        "method_before": "    private class InternalHostListener implements HostListener {\n\n        /**\n         * Generate new ACL flow rules for new host following the given ACL rule.\n         */\n        private void processHostAddedEvent(HostEvent event, AclRule rule) {\n            DeviceId deviceId = event.subject().location().deviceId();\n            for (IpAddress address : event.subject().ipAddresses()) {\n                if ((rule.srcIp() != null) ?\n                        (checkIpInCidr(address.getIp4Address(), rule.srcIp())) :\n                        (checkIpInCidr(address.getIp4Address(), rule.dstIp()))) {\n                    if (!aclStore.checkIfRuleWorksInDevice(rule.id(), deviceId)) {\n                        List<RuleId> allowingRuleList = aclStore\n                                .getAllowingRuleByDenyingRule(rule.id());\n                        if (allowingRuleList != null) {\n                            for (RuleId allowingRuleId : allowingRuleList) {\n                                generateAclFlow(aclStore.getAclRule(allowingRuleId), deviceId);\n                            }\n                        }\n                        generateAclFlow(rule, deviceId);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void event(HostEvent event) {\n            // if a new host appears and an existing rule denies\n            // its traffic, a new ACL flow rule is generated.\n            if (event.type() == HostEvent.Type.HOST_ADDED) {\n                DeviceId deviceId = event.subject().location().deviceId();\n                if (mastershipService.getLocalRole(deviceId) == MastershipRole.MASTER) {\n                    for (AclRule rule : aclStore.getAclRules()) {\n                        if (rule.action() != AclRule.Action.ALLOW) {\n                            processHostAddedEvent(event, rule);\n                        }\n                    }\n                }\n            }\n        }",
        "method_after": "    private class InternalHostListener implements HostListener {\n\n        /**\n         * Generate new ACL flow rules for new or updated host following the given ACL rule.\n         */\n        private void processHostAddedEvent(HostEvent event, AclRule rule) {\n            DeviceId deviceId = event.subject().location().deviceId();\n            for (IpAddress address : event.subject().ipAddresses()) {\n                if ((rule.srcIp() != null) ?\n                        (checkIpInCidr(address.getIp4Address(), rule.srcIp())) :\n                        (checkIpInCidr(address.getIp4Address(), rule.dstIp()))) {\n                    if (!aclStore.checkIfRuleWorksInDevice(rule.id(), deviceId)) {\n                        List<RuleId> allowingRuleList = aclStore\n                                .getAllowingRuleByDenyingRule(rule.id());\n                        if (allowingRuleList != null) {\n                            for (RuleId allowingRuleId : allowingRuleList) {\n                                generateAclFlow(aclStore.getAclRule(allowingRuleId), deviceId);\n                            }\n                        }\n                        generateAclFlow(rule, deviceId);\n                    }\n                }\n            }\n        }\n\n        @Override\n        public void event(HostEvent event) {\n            // if a new host appears or is updated and an existing rule denies\n            // its traffic, a new ACL flow rule is generated.\n            if (event.type() == HostEvent.Type.HOST_ADDED || event.type() == HostEvent.Type.HOST_UPDATED) {\n                DeviceId deviceId = event.subject().location().deviceId();\n                if (mastershipService.getLocalRole(deviceId) == MastershipRole.MASTER) {\n                    for (AclRule rule : aclStore.getAclRules()) {\n                        if (rule.action() != AclRule.Action.ALLOW) {\n                            processHostAddedEvent(event, rule);\n                        }\n                    }\n                }\n            }\n        }"
    },
    {
        "idx": "857",
        "vuln_id": "CVE-2018-1320",
        "desc": "Apache Thrift Java client library versions 0.5.0 through 0.11.0 can bypass SASL negotiation isComplete validation in the org.apache.thrift.transport.TSaslTransport class. An assert used to determine if the SASL handshake had successfully completed could be disabled in production settings making the validation incomplete.",
        "cwe_id": "CWE-295",
        "cwe_name": "Improper Certificate Validation",
        "repo": "https://github.com/apache/thrift",
        "commit": "d973409661f820d80d72c0034d06a12348c8705e",
        "method_before": "  public void open() throws TTransportException {\n    /*\n     * readSaslHeader is used to tag whether the SASL header has been read properly.\n     * If there is a problem in reading the header, there might not be any\n     * data in the stream, possibly a TCP health check from load balancer.\n     */\n    boolean readSaslHeader = false;\n\n    LOGGER.debug(\"opening transport {}\", this);\n    if (sasl != null && sasl.isComplete())\n      throw new TTransportException(\"SASL transport already open\");\n\n    if (!underlyingTransport.isOpen())\n      underlyingTransport.open();\n\n    try {\n      // Negotiate a SASL mechanism. The client also sends its\n      // initial response, or an empty one.\n      handleSaslStartMessage();\n      readSaslHeader = true;\n      LOGGER.debug(\"{}: Start message handled\", getRole());\n\n      SaslResponse message = null;\n      while (!sasl.isComplete()) {\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE &&\n            message.status != NegotiationStatus.OK) {\n          throw new TTransportException(\"Expected COMPLETE or OK, got \" + message.status);\n        }\n\n        byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);\n\n        // If we are the client, and the server indicates COMPLETE, we don't need to\n        // send back any further response.\n        if (message.status == NegotiationStatus.COMPLETE &&\n            getRole() == SaslRole.CLIENT) {\n          LOGGER.debug(\"{}: All done!\", getRole());\n          break;\n        }\n\n        sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,\n                        challenge);\n      }\n      LOGGER.debug(\"{}: Main negotiation loop complete\", getRole());\n\n      assert sasl.isComplete();\n\n      // If we're the client, and we're complete, but the server isn't\n      // complete yet, we need to wait for its response. This will occur\n      // with ANONYMOUS auth, for example, where we send an initial response\n      // and are immediately complete.\n      if (getRole() == SaslRole.CLIENT &&\n          (message == null || message.status == NegotiationStatus.OK)) {\n        LOGGER.debug(\"{}: SASL Client receiving last message\", getRole());\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE) {\n          throw new TTransportException(\n            \"Expected SASL COMPLETE, but got \" + message.status);\n        }\n      }\n    } catch (SaslException e) {\n      try {\n        LOGGER.error(\"SASL negotiation failure\", e);\n        throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());\n      } finally {\n        underlyingTransport.close();\n      }\n    } catch (TTransportException e) {\n      /*\n       * If there is no-data or no-sasl header in the stream, throw a different\n       * type of exception so we can handle this scenario differently.\n       */\n      if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {\n        underlyingTransport.close();\n        LOGGER.debug(\"No data or no sasl data in the stream\");\n        throw new TSaslTransportException(\"No data or no sasl data in the stream\");\n      }\n      throw e;\n    }\n\n    String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null && !qop.equalsIgnoreCase(\"auth\"))\n      shouldWrap = true;\n  }",
        "method_after": "  public void open() throws TTransportException {\n    /*\n     * readSaslHeader is used to tag whether the SASL header has been read properly.\n     * If there is a problem in reading the header, there might not be any\n     * data in the stream, possibly a TCP health check from load balancer.\n     */\n    boolean readSaslHeader = false;\n\n    LOGGER.debug(\"opening transport {}\", this);\n    if (sasl != null && sasl.isComplete())\n      throw new TTransportException(\"SASL transport already open\");\n\n    if (!underlyingTransport.isOpen())\n      underlyingTransport.open();\n\n    try {\n      // Negotiate a SASL mechanism. The client also sends its\n      // initial response, or an empty one.\n      handleSaslStartMessage();\n      readSaslHeader = true;\n      LOGGER.debug(\"{}: Start message handled\", getRole());\n\n      SaslResponse message = null;\n      while (!sasl.isComplete()) {\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE &&\n            message.status != NegotiationStatus.OK) {\n          throw new TTransportException(\"Expected COMPLETE or OK, got \" + message.status);\n        }\n\n        byte[] challenge = sasl.evaluateChallengeOrResponse(message.payload);\n\n        // If we are the client, and the server indicates COMPLETE, we don't need to\n        // send back any further response.\n        if (message.status == NegotiationStatus.COMPLETE &&\n            getRole() == SaslRole.CLIENT) {\n          LOGGER.debug(\"{}: All done!\", getRole());\n          continue;\n        }\n\n        sendSaslMessage(sasl.isComplete() ? NegotiationStatus.COMPLETE : NegotiationStatus.OK,\n                        challenge);\n      }\n      LOGGER.debug(\"{}: Main negotiation loop complete\", getRole());\n\n      // If we're the client, and we're complete, but the server isn't\n      // complete yet, we need to wait for its response. This will occur\n      // with ANONYMOUS auth, for example, where we send an initial response\n      // and are immediately complete.\n      if (getRole() == SaslRole.CLIENT &&\n          (message == null || message.status == NegotiationStatus.OK)) {\n        LOGGER.debug(\"{}: SASL Client receiving last message\", getRole());\n        message = receiveSaslMessage();\n        if (message.status != NegotiationStatus.COMPLETE) {\n          throw new TTransportException(\n            \"Expected SASL COMPLETE, but got \" + message.status);\n        }\n      }\n    } catch (SaslException e) {\n      try {\n        LOGGER.error(\"SASL negotiation failure\", e);\n        throw sendAndThrowMessage(NegotiationStatus.BAD, e.getMessage());\n      } finally {\n        underlyingTransport.close();\n      }\n    } catch (TTransportException e) {\n      /*\n       * If there is no-data or no-sasl header in the stream, throw a different\n       * type of exception so we can handle this scenario differently.\n       */\n      if (!readSaslHeader && e.getType() == TTransportException.END_OF_FILE) {\n        underlyingTransport.close();\n        LOGGER.debug(\"No data or no sasl data in the stream\");\n        throw new TSaslTransportException(\"No data or no sasl data in the stream\");\n      }\n      throw e;\n    }\n\n    String qop = (String) sasl.getNegotiatedProperty(Sasl.QOP);\n    if (qop != null && !qop.equalsIgnoreCase(\"auth\"))\n      shouldWrap = true;\n  }"
    },
    {
        "idx": "910",
        "vuln_id": "CVE-2018-18389",
        "desc": "Due to incorrect access control in Neo4j Enterprise Database Server 3.4.x before 3.4.9, the setting of LDAP for authentication with STARTTLS, and System Account for authorization, allows an attacker to log into the server by sending any valid username with an arbitrary password.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/neo4j/neo4j",
        "commit": "46de5d01ae2741ffe04c36270fc62c6d490f65c9",
        "method_before": "    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }",
        "method_after": "    private LdapContext getLdapContextUsingStartTls( LdapContextFactory ldapContextFactory,\n            Object principal, Object credentials ) throws NamingException\n    {\n        JndiLdapContextFactory jndiLdapContextFactory = (JndiLdapContextFactory) ldapContextFactory;\n        Hashtable<String, Object> env = new Hashtable<>();\n        env.put( Context.INITIAL_CONTEXT_FACTORY, jndiLdapContextFactory.getContextFactoryClassName() );\n        env.put( Context.PROVIDER_URL, jndiLdapContextFactory.getUrl() );\n\n        LdapContext ctx = null;\n\n        try\n        {\n            ctx = new InitialLdapContext( env, null );\n\n            StartTlsRequest startTlsRequest = new StartTlsRequest();\n            StartTlsResponse tls = (StartTlsResponse) ctx.extendedOperation( startTlsRequest );\n\n            tls.negotiate();\n\n            ctx.addToEnvironment( Context.SECURITY_AUTHENTICATION,\n                    jndiLdapContextFactory.getAuthenticationMechanism() );\n            ctx.addToEnvironment( Context.SECURITY_PRINCIPAL, principal );\n            ctx.addToEnvironment( Context.SECURITY_CREDENTIALS, credentials );\n\n            // do a lookup of the user to trigger authentication\n            ctx.lookup( principal.toString() );\n\n            return ctx;\n        }\n        catch ( IOException e )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Failed to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), e ) );\n            throw new CommunicationException( e.getMessage() );\n        }\n        catch ( Throwable t )\n        {\n            LdapUtils.closeContext( ctx );\n            securityLog.error( withRealm( \"Unexpected failure to negotiate TLS connection with '%s': \",\n                    server( jndiLdapContextFactory ), t ) );\n            throw t;\n        }\n    }"
    },
    {
        "idx": "1038",
        "vuln_id": "CVE-2019-12402",
        "desc": "The file name encoding algorithm used internally in Apache Commons Compress 1.15 to 1.18 can get into an infinite loop when faced with specially crafted inputs. This can lead to a denial of service attack if an attacker can choose the file names inside of an archive created by Compress.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/commons-compress",
        "commit": "4ad5d80a6272e007f64a6ac66829ca189a8093b9",
        "method_before": "    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    // if the destination buffer isn't over sized, assume that the presence of one\n                    // unmappable character makes it likely that there will be more. Find all the\n                    // un-encoded characters and allocate space based on those estimates.\n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n            }\n        }\n        // tell the encoder we are done\n        enc.encode(cb, out, true);\n        // may have caused underflow, but that's been ignored traditionally\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }",
        "method_after": "    public ByteBuffer encode(final String name) {\n        final CharsetEncoder enc = newEncoder();\n\n        final CharBuffer cb = CharBuffer.wrap(name);\n        CharBuffer tmp = null;\n        ByteBuffer out = ByteBuffer.allocate(estimateInitialBufferSize(enc, cb.remaining()));\n\n        while (cb.remaining() > 0) {\n            final CoderResult res = enc.encode(cb, out, false);\n\n            if (res.isUnmappable() || res.isMalformed()) {\n\n                // write the unmappable characters in utf-16\n                // pseudo-URL encoding style to ByteBuffer.\n\n                int spaceForSurrogate = estimateIncrementalEncodingSize(enc, 6 * res.length());\n                if (spaceForSurrogate > out.remaining()) {\n                    // if the destination buffer isn't over sized, assume that the presence of one\n                    // unmappable character makes it likely that there will be more. Find all the\n                    // un-encoded characters and allocate space based on those estimates.\n                    int charCount = 0;\n                    for (int i = cb.position() ; i < cb.limit(); i++) {\n                        charCount += !enc.canEncode(cb.get(i)) ? 6 : 1;\n                    }\n                    int totalExtraSpace = estimateIncrementalEncodingSize(enc, charCount);\n                    out = ZipEncodingHelper.growBufferBy(out, totalExtraSpace - out.remaining());\n                }\n                if (tmp == null) {\n                    tmp = CharBuffer.allocate(6);\n                }\n                for (int i = 0; i < res.length(); ++i) {\n                    out = encodeFully(enc, encodeSurrogate(tmp, cb.get()), out);\n                }\n\n            } else if (res.isOverflow()) {\n                int increment = estimateIncrementalEncodingSize(enc, cb.remaining());\n                out = ZipEncodingHelper.growBufferBy(out, increment);\n\n            } else if (res.isUnderflow() || res.isError()) {\n                break;\n            }\n        }\n        // tell the encoder we are done\n        enc.encode(cb, out, true);\n        // may have caused underflow, but that's been ignored traditionally\n\n        out.limit(out.position());\n        out.rewind();\n        return out;\n    }"
    },
    {
        "idx": "1102",
        "vuln_id": "CVE-2020-12480",
        "desc": "In Play Framework 2.6.0 through 2.8.1, the CSRF filter can be bypassed by making CORS simple requests with content types that contain parameters that can't be parsed.",
        "cwe_id": "CWE-352",
        "cwe_name": "Cross-Site Request Forgery (CSRF)",
        "repo": "https://github.com/playframework/playframework",
        "commit": "681d8ee3f785a6105b0595d8f10a8ee5718e6d7b",
        "method_before": "  public CompletionStage<Result> call(Http.Request req) {\n\n    CSRFActionHelper csrfActionHelper =\n        new CSRFActionHelper(sessionConfiguration, config, tokenSigner, tokenProvider);\n\n    RequestHeader taggedRequest = csrfActionHelper.tagRequestFromHeader(req.asScala());\n    // Check for bypass\n    if (!csrfActionHelper.requiresCsrfCheck(taggedRequest)) {\n      return delegate.call(req);\n    } else {\n      // Get token from cookie/session\n      Option<String> headerToken = csrfActionHelper.getTokenToValidate(taggedRequest);\n      if (headerToken.isDefined()) {\n        String tokenToCheck = null;\n\n        // Get token from query string\n        Option<String> queryStringToken = csrfActionHelper.getHeaderToken(taggedRequest);\n        if (queryStringToken.isDefined()) {\n          tokenToCheck = queryStringToken.get();\n        } else {\n\n          // Get token from body\n          if (req.body().asFormUrlEncoded() != null) {\n            String[] values = req.body().asFormUrlEncoded().get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          } else if (req.body().asMultipartFormData() != null) {\n            Map<String, String[]> form = req.body().asMultipartFormData().asFormUrlEncoded();\n            String[] values = form.get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          }\n        }\n\n        if (tokenToCheck != null) {\n          if (tokenProvider.compareTokens(tokenToCheck, headerToken.get())) {\n            return delegate.call(req);\n          } else {\n            return handleTokenError(req, taggedRequest, \"CSRF tokens don't match\");\n          }\n        } else {\n          return handleTokenError(\n              req, taggedRequest, \"CSRF token not found in body or query string\");\n        }\n      } else {\n        return handleTokenError(req, taggedRequest, \"CSRF token not found in session\");\n      }\n    }\n  }",
        "method_after": "  public CompletionStage<Result> call(Http.Request req) {\n\n    CSRFActionHelper csrfActionHelper =\n        new CSRFActionHelper(sessionConfiguration, config, tokenSigner, tokenProvider);\n\n    RequestHeader taggedRequest = csrfActionHelper.tagRequestFromHeader(req.asScala());\n    // Check for bypass\n    if (!csrfActionHelper.requiresCsrfCheck(taggedRequest)\n        || (config.checkContentType().apply(req.asScala().contentType()) != Boolean.TRUE\n            && !csrfActionHelper.hasInvalidContentType(req.asScala()))) {\n      return delegate.call(req);\n    } else {\n      // Get token from cookie/session\n      Option<String> headerToken = csrfActionHelper.getTokenToValidate(taggedRequest);\n      if (headerToken.isDefined()) {\n        String tokenToCheck = null;\n\n        // Get token from query string\n        Option<String> queryStringToken = csrfActionHelper.getHeaderToken(taggedRequest);\n        if (queryStringToken.isDefined()) {\n          tokenToCheck = queryStringToken.get();\n        } else {\n\n          // Get token from body\n          if (req.body().asFormUrlEncoded() != null) {\n            String[] values = req.body().asFormUrlEncoded().get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          } else if (req.body().asMultipartFormData() != null) {\n            Map<String, String[]> form = req.body().asMultipartFormData().asFormUrlEncoded();\n            String[] values = form.get(config.tokenName());\n            if (values != null && values.length > 0) {\n              tokenToCheck = values[0];\n            }\n          }\n        }\n\n        if (tokenToCheck != null) {\n          if (tokenProvider.compareTokens(tokenToCheck, headerToken.get())) {\n            return delegate.call(req);\n          } else {\n            return handleTokenError(req, taggedRequest, \"CSRF tokens don't match\");\n          }\n        } else {\n          return handleTokenError(\n              req, taggedRequest, \"CSRF token not found in body or query string\");\n        }\n      } else {\n        return handleTokenError(req, taggedRequest, \"CSRF token not found in session\");\n      }\n    }\n  }"
    },
    {
        "idx": "232",
        "vuln_id": "CVE-2014-0086",
        "desc": "The doFilter function in webapp/PushHandlerFilter.java in JBoss RichFaces 4.3.4, 4.3.5, and 5.x allows remote attackers to cause a denial of service (memory consumption and out-of-memory error) via a large number of malformed atmosphere push requests.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/pslegr/core-1",
        "commit": "8131f15003f5bec73d475d2b724472e4b87d0757",
        "method_before": "    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }",
        "method_after": "    public void doFilter(ServletRequest request, ServletResponse response, FilterChain chain) throws IOException,\n            ServletException {\n        if (request instanceof HttpServletRequest && response instanceof HttpServletResponse) {\n            HttpServletRequest httpReq = (HttpServletRequest) request;\n            HttpServletResponse httpResp = (HttpServletResponse) response;\n\n            if (\"GET\".equals(httpReq.getMethod())) {\n                String pushSessionId = httpReq.getParameter(PUSH_SESSION_ID_PARAM);\n\n                Session session = null;\n\n                if (pushSessionId != null) {\n                    ensureServletContextAvailable(request);\n                    PushContext pushContext = (PushContext) servletContext.getAttribute(PushContext.INSTANCE_KEY_NAME);\n                    session = pushContext.getSessionManager().getPushSession(pushSessionId);\n                }\n\n                if (session == null) {\n                    if (LOGGER.isDebugEnabled()) {\n                        LOGGER.debug(MessageFormat.format(\"Session {0} was not found\", pushSessionId));\n                    }\n                    httpResp.sendError(HttpServletResponse.SC_BAD_REQUEST);\n                    return;\n                }\n\n                httpResp.setContentType(\"text/plain\");\n\n                Meteor meteor = Meteor.build(httpReq, SCOPE.REQUEST, Collections.<BroadcastFilter>emptyList(), null);\n\n                try {\n                    Request pushRequest = new RequestImpl(meteor, session);\n\n                    httpReq.setAttribute(SESSION_ATTRIBUTE_NAME, session);\n                    httpReq.setAttribute(REQUEST_ATTRIBUTE_NAME, pushRequest);\n\n                    pushRequest.suspend();\n                } catch (Exception e) {\n                    LOGGER.error(e.getMessage(), e);\n                }\n\n                return;\n            }\n        }\n    }"
    },
    {
        "idx": "305",
        "vuln_id": "CVE-2015-0899",
        "desc": "The MultiPageValidator implementation in Apache Struts 1 1.1 through 1.3.10 allows remote attackers to bypass intended access restrictions via a modified page parameter.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/kawasima/struts1-forever",
        "commit": "212bb0f7c57617b7b9c44cb1e056bd1e597c8e16",
        "method_before": "    protected void initOther() throws ServletException {\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }",
        "method_after": "    protected void initOther() throws ServletException {\n        PropertyUtils.addBeanIntrospector(\n                SuppressPropertiesBeanIntrospector.SUPPRESS_CLASS);\n        PropertyUtils.clearDescriptors();\n\n        String value = null;\n        value = getServletConfig().getInitParameter(\"config\");\n        if (value != null) {\n            config = value;\n        }\n\n        // Backwards compatibility for form beans of Java wrapper classes\n        // Set to true for strict Struts 1.0 compatibility\n        value = getServletConfig().getInitParameter(\"convertNull\");\n        if (\"true\".equalsIgnoreCase(value)\n            || \"yes\".equalsIgnoreCase(value)\n            || \"on\".equalsIgnoreCase(value)\n            || \"y\".equalsIgnoreCase(value)\n            || \"1\".equalsIgnoreCase(value)) {\n\n            convertNull = true;\n        }\n\n        if (convertNull) {\n            ConvertUtils.deregister();\n            ConvertUtils.register(new BigDecimalConverter(null), BigDecimal.class);\n            ConvertUtils.register(new BigIntegerConverter(null), BigInteger.class);\n            ConvertUtils.register(new BooleanConverter(null), Boolean.class);\n            ConvertUtils.register(new ByteConverter(null), Byte.class);\n            ConvertUtils.register(new CharacterConverter(null), Character.class);\n            ConvertUtils.register(new DoubleConverter(null), Double.class);\n            ConvertUtils.register(new FloatConverter(null), Float.class);\n            ConvertUtils.register(new IntegerConverter(null), Integer.class);\n            ConvertUtils.register(new LongConverter(null), Long.class);\n            ConvertUtils.register(new ShortConverter(null), Short.class);\n        }\n\n    }"
    },
    {
        "idx": "541",
        "vuln_id": "CVE-2017-1000388",
        "desc": "Jenkins Dependency Graph Viewer plugin 0.12 and earlier did not perform permission checks for the API endpoint that modifies the dependency graph, allowing anyone with Overall/Read permission to modify this data.",
        "cwe_id": "CWE-862",
        "cwe_name": "Missing Authorization",
        "repo": "https://github.com/jenkinsci/depgraph-view-plugin",
        "commit": "d442ff671965c279770b28e37dc63a6ab73c0f0e",
        "method_before": "    public EdgeOperation(String sourceJobName, String targetJobName) {\n        this.source = Jenkins.getInstance().getItemByFullName(sourceJobName.trim(), AbstractProject.class);\n        this.target = Jenkins.getInstance().getItemByFullName(targetJobName, AbstractProject.class);\n    }",
        "method_after": "    public EdgeOperation(String sourceJobName, String targetJobName) {\n        this.source = Jenkins.getInstance().getItemByFullName(sourceJobName.trim(), AbstractProject.class);\n        this.target = Jenkins.getInstance().getItemByFullName(targetJobName, AbstractProject.class);\n        source.checkPermission(Permission.CONFIGURE);\n        target.checkPermission(Permission.CONFIGURE);\n    }"
    },
    {
        "idx": "721",
        "vuln_id": "CVE-2018-1000089",
        "desc": "Anymail django-anymail version version 0.2 through 1.3 contains a CWE-532, CWE-209 vulnerability in WEBHOOK_AUTHORIZATION setting value that can result in An attacker with access to error logs could fabricate email tracking events. This attack appear to be exploitable via If you have exposed your Django error reports, an attacker could discover your ANYMAIL_WEBHOOK setting and use this to post fabricated or malicious Anymail tracking/inbound events to your app. This vulnerability appears to have been fixed in v1.4.",
        "cwe_id": "CWE-532",
        "cwe_name": "Insertion of Sensitive Information into Log File",
        "repo": "https://github.com/jenkinsci/pipeline-build-step-plugin",
        "commit": "3dfefdec1f7b2a4ee0ef8902afdea720b1572cb3",
        "method_before": "    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }",
        "method_after": "    public boolean start() throws Exception {\n        String job = step.getJob();\n        Item item = Jenkins.getActiveInstance().getItem(job, invokingRun.getParent(), Item.class);\n        if (item == null) {\n            throw new AbortException(\"No item named \" + job + \" found\");\n        }\n        item.checkPermission(Item.BUILD);\n        if (step.getWait() && !(item instanceof Job)) {\n            // TODO find some way of allowing ComputedFolders to hook into the listener code\n            throw new AbortException(\"Waiting for non-job items is not supported\");\n        }\n        if (item instanceof ParameterizedJobMixIn.ParameterizedJob) {\n            final ParameterizedJobMixIn.ParameterizedJob project = (ParameterizedJobMixIn.ParameterizedJob) item;\n            listener.getLogger().println(\"Scheduling project: \" + ModelHyperlinkNote.encodeTo(project));\n\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(project.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{project, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            List<ParameterValue> parameters = step.getParameters();\n            if (parameters != null) {\n                parameters = completeDefaultParameters(parameters, (Job) project);\n                actions.add(new ParametersAction(parameters));\n            }\n            Integer quietPeriod = step.getQuietPeriod();\n            // TODO use new convenience method in 1.621\n            if (quietPeriod == null) {\n                quietPeriod = project.getQuietPeriod();\n            }\n            QueueTaskFuture<?> f = new ParameterizedJobMixIn() {\n                @Override\n                protected Job asJob() {\n                    return (Job) project;\n                }\n            }.scheduleBuild2(quietPeriod, actions.toArray(new Action[actions.size()]));\n            if (f == null) {\n                throw new AbortException(\"Failed to trigger build of \" + project.getFullName());\n            }\n        } else if (item instanceof Queue.Task){\n            if (step.getParameters() != null && !step.getParameters().isEmpty()) {\n                throw new AbortException(\"Item type does not support parameters\");\n            }\n            Queue.Task task = (Queue.Task) item;\n            listener.getLogger().println(\"Scheduling item: \" + ModelHyperlinkNote.encodeTo(item));\n            node.addAction(new LabelAction(Messages.BuildTriggerStepExecution_building_(task.getFullDisplayName())));\n            List<Action> actions = new ArrayList<>();\n            if (step.getWait()) {\n                StepContext context = getContext();\n                actions.add(new BuildTriggerAction(context, step.isPropagate()));\n                LOGGER.log(Level.FINER, \"scheduling a build of {0} from {1}\", new Object[]{task, context});\n            }\n            actions.add(new CauseAction(new Cause.UpstreamCause(invokingRun)));\n            Integer quietPeriod = step.getQuietPeriod();\n            if (quietPeriod == null) {\n                try {\n                    Method getQuietPeriod = task.getClass().getMethod(\"getQuietPeriod\");\n                    if (getQuietPeriod.getReturnType().equals(int.class)) {\n                        quietPeriod = (Integer) getQuietPeriod.invoke(task);\n                    }\n                } catch (NoSuchMethodException e) {\n                    // ignore, best effort only\n                } catch (IllegalAccessError | IllegalArgumentException | InvocationTargetException e) {\n                    LOGGER.log(Level.WARNING, \"Could not determine quiet period of \" + item.getFullName(), e);\n                }\n            }\n            if (quietPeriod == null) {\n                quietPeriod = Jenkins.getActiveInstance().getQuietPeriod();\n            }\n            ScheduleResult scheduleResult = Jenkins.getActiveInstance().getQueue().schedule2(task, quietPeriod,actions);\n            if (scheduleResult.isRefused()) {\n                throw new AbortException(\"Failed to trigger build of \" + item.getFullName());\n            }\n        } else {\n            throw new AbortException(\"The item named \" + job + \" is a \"\n                    + (item instanceof Describable\n                    ? ((Describable) item).getDescriptor().getDisplayName()\n                    : item.getClass().getName())\n                    + \" which is not something that can be built\");\n        }\n        if (step.getWait()) {\n            return false;\n        } else {\n            getContext().onSuccess(null);\n            return true;\n        }\n    }"
    },
    {
        "idx": "786",
        "vuln_id": "CVE-2018-11784",
        "desc": "When the default servlet in Apache Tomcat versions 9.0.0.M1 to 9.0.11, 8.5.0 to 8.5.33 and 7.0.23 to 7.0.90 returned a redirect to a directory (e.g. redirecting to '/foo/' when the user requested '/foo') a specially crafted URL could be used to cause the redirect to be generated to any URI of the attackers choice.",
        "cwe_id": "CWE-601",
        "cwe_name": "URL Redirection to Untrusted Site ('Open Redirect')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "efb860b3ff8ebcf606199b8d0d432f76898040da",
        "method_before": "    private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        StringBuilder location = new StringBuilder(request.getRequestURI());\n        location.append('/');\n        if (request.getQueryString() != null) {\n            location.append('?');\n            location.append(request.getQueryString());\n        }\n        response.sendRedirect(response.encodeRedirectURL(location.toString()));\n    }",
        "method_after": "    private void doDirectoryRedirect(HttpServletRequest request, HttpServletResponse response)\n            throws IOException {\n        StringBuilder location = new StringBuilder(request.getRequestURI());\n        location.append('/');\n        if (request.getQueryString() != null) {\n            location.append('?');\n            location.append(request.getQueryString());\n        }\n        // Avoid protocol relative redirects\n        while (location.length() > 1 && location.charAt(1) == '/') {\n            location.deleteCharAt(0);\n        }\n        response.sendRedirect(response.encodeRedirectURL(location.toString()));\n    }"
    },
    {
        "idx": "969",
        "vuln_id": "CVE-2018-8030",
        "desc": "A Denial of Service vulnerability was found in Apache Qpid Broker-J versions 7.0.0-7.0.4 when AMQP protocols 0-8, 0-9 or 0-91 are used to publish messages with size greater than allowed maximum message size limit (100MB by default). The broker crashes due to the defect. AMQP protocols 0-10 and 1.0 are not affected.",
        "cwe_id": "CWE-20",
        "cwe_name": "Improper Input Validation",
        "repo": "https://github.com/apache/qpid-broker-j",
        "commit": "025b48f3193e2b10b1c41d2bc3bcfc9cfc238a27",
        "method_before": "    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            publishContentHeader(new ContentHeaderBody(properties, bodySize));\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }",
        "method_after": "    public void receiveMessageHeader(final BasicContentHeaderProperties properties, final long bodySize)\n    {\n        if(LOGGER.isDebugEnabled())\n        {\n            LOGGER.debug(\"RECV[\" + _channelId + \"] MessageHeader[ properties: {\" + properties + \"} bodySize: \" + bodySize + \" ]\");\n        }\n\n        if(hasCurrentMessage())\n        {\n            if(bodySize > _connection.getMaxMessageSize())\n            {\n                properties.dispose();\n                closeChannel(ErrorCodes.MESSAGE_TOO_LARGE,\n                             \"Message size of \" + bodySize + \" greater than allowed maximum of \" + _connection.getMaxMessageSize());\n            }\n            else\n            {\n                publishContentHeader(new ContentHeaderBody(properties, bodySize));\n            }\n        }\n        else\n        {\n            properties.dispose();\n            _connection.sendConnectionClose(ErrorCodes.COMMAND_INVALID,\n                                            \"Attempt to send a content header without first sending a publish frame\",\n                                            _channelId);\n        }\n    }"
    },
    {
        "idx": "981",
        "vuln_id": "CVE-2018-8718",
        "desc": "Cross-site request forgery (CSRF) vulnerability in the Mailer Plugin 1.20 for Jenkins 2.111 allows remote authenticated users to send unauthorized mail as an arbitrary user via a /descriptorByName/hudson.tasks.Mailer/sendTestMail request.",
        "cwe_id": "CWE-352",
        "cwe_name": "Cross-Site Request Forgery (CSRF)",
        "repo": "https://github.com/jenkinsci/mailer-plugin",
        "commit": "98e79cf904769907f83894e29f50ed6b3e7eb135",
        "method_before": "        public DescriptorImpl() {\n            load();\n            DESCRIPTOR = this;\n        }\n\n        public String getDisplayName() {\n            return Messages.Mailer_DisplayName();\n        }\n\n        public String getDefaultSuffix() {\n            return defaultSuffix;\n        }\n\n        public String getReplyToAddress() {\n            return replyToAddress;\n        }\n\n        public void setReplyToAddress(String address) {\n            this.replyToAddress = Util.fixEmpty(address);\n        }\n\n        /** JavaMail session. */\n        public Session createSession() {\n            return createSession(smtpHost,smtpPort,useSsl,smtpAuthUsername,smtpAuthPassword);\n        }\n        private static Session createSession(String smtpHost, String smtpPort, boolean useSsl, String smtpAuthUserName, Secret smtpAuthPassword) {\n            smtpPort = fixEmptyAndTrim(smtpPort);\n            smtpAuthUserName = fixEmptyAndTrim(smtpAuthUserName);\n\n            Properties props = new Properties(System.getProperties());\n            if(fixEmptyAndTrim(smtpHost)!=null)\n                props.put(\"mail.smtp.host\",smtpHost);\n            if (smtpPort!=null) {\n                props.put(\"mail.smtp.port\", smtpPort);\n            }\n            if (useSsl) {\n            \t/* This allows the user to override settings by setting system properties but\n            \t * also allows us to use the default SMTPs port of 465 if no port is already set.\n            \t * It would be cleaner to use smtps, but that's done by calling session.getTransport()...\n            \t * and thats done in mail sender, and it would be a bit of a hack to get it all to\n            \t * coordinate, and we can make it work through setting mail.smtp properties.\n            \t */\n            \tif (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                    String port = smtpPort==null?\"465\":smtpPort;\n                    props.put(\"mail.smtp.port\", port);\n                    props.put(\"mail.smtp.socketFactory.port\", port);\n            \t}\n            \tif (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n            \t\tprops.put(\"mail.smtp.socketFactory.class\",\"javax.net.ssl.SSLSocketFactory\");\n            \t}\n\t\t\t\tprops.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\t\t\t}\n            if(smtpAuthUserName!=null)\n                props.put(\"mail.smtp.auth\",\"true\");\n\n            // avoid hang by setting some timeout. \n            props.put(\"mail.smtp.timeout\",\"60000\");\n            props.put(\"mail.smtp.connectiontimeout\",\"60000\");\n\n            return Session.getInstance(props,getAuthenticator(smtpAuthUserName,Secret.toString(smtpAuthPassword)));\n        }\n\n        private static Authenticator getAuthenticator(final String smtpAuthUserName, final String smtpAuthPassword) {\n            if(smtpAuthUserName==null)    return null;\n            return new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(smtpAuthUserName,smtpAuthPassword);\n                }\n            };\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject json) throws FormException {\n            // this code is brain dead\n            smtpHost = nullify(json.getString(\"smtpServer\"));\n            setReplyToAddress(json.getString(\"replyToAddress\"));\n\n            defaultSuffix = nullify(json.getString(\"defaultSuffix\"));\n\n            if(json.has(\"useSMTPAuth\")) {\n                JSONObject auth = json.getJSONObject(\"useSMTPAuth\");\n                smtpAuthUsername = nullify(auth.getString(\"smtpAuthUserName\"));\n                smtpAuthPassword = Secret.fromString(nullify(auth.getString(\"smtpAuthPasswordSecret\")));\n            } else {\n                smtpAuthUsername = null;\n                smtpAuthPassword = null;\n            }\n            smtpPort = nullify(json.getString(\"smtpPort\"));\n            useSsl = json.getBoolean(\"useSsl\");\n            charset = json.getString(\"charset\");\n            if (charset == null || charset.length() == 0)\n            \tcharset = \"UTF-8\";\n            \n            save();\n            return true;\n        }\n\n        private String nullify(String v) {\n            if(v!=null && v.length()==0)    v=null;\n            return v;\n        }\n\n        public String getSmtpServer() {\n            return smtpHost;\n        }\n\n        /**\n         * Method added to pass findbugs verification when compiling against 1.642.1\n         * @return The JenkinsLocationConfiguration object.\n         * @throws IllegalStateException if the object is not available (e.g., Jenkins not fully initialized).\n         */\n        @SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n            justification = \"False positive. See https://sourceforge.net/p/findbugs/bugs/1411/\")\n        private JenkinsLocationConfiguration getJenkinsLocationConfiguration() {\n            final JenkinsLocationConfiguration jlc = JenkinsLocationConfiguration.get();\n            if (jlc == null) {\n                throw new IllegalStateException(\"JenkinsLocationConfiguration not available\");\n            }\n            return jlc;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getAdminAddress() {\n            return getJenkinsLocationConfiguration().getAdminAddress();\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getUrl() {\n            return getJenkinsLocationConfiguration().getUrl();\n        }\n\n        public String getSmtpAuthUserName() {\n            return smtpAuthUsername;\n        }\n\n        public String getSmtpAuthPassword() {\n            if (smtpAuthPassword==null) return null;\n            return Secret.toString(smtpAuthPassword);\n        }\n\n        public Secret getSmtpAuthPasswordSecret() {\n            return smtpAuthPassword;\n        }\n\n        public boolean getUseSsl() {\n        \treturn useSsl;\n        }\n\n        public String getSmtpPort() {\n        \treturn smtpPort;\n        }\n        \n        public String getCharset() {\n        \tString c = charset;\n        \tif (c == null || c.length() == 0)\tc = \"UTF-8\";\n        \treturn c;\n        }\n\n        public void setDefaultSuffix(String defaultSuffix) {\n            this.defaultSuffix = defaultSuffix;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setHudsonUrl(String hudsonUrl) {\n            getJenkinsLocationConfiguration().setUrl(hudsonUrl);\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setAdminAddress(String adminAddress) {\n            getJenkinsLocationConfiguration().setAdminAddress(adminAddress);\n        }\n\n        public void setSmtpHost(String smtpHost) {\n            this.smtpHost = smtpHost;\n        }\n\n        public void setUseSsl(boolean useSsl) {\n            this.useSsl = useSsl;\n        }\n\n        public void setSmtpPort(String smtpPort) {\n            this.smtpPort = smtpPort;\n        }\n        \n        public void setCharset(String chaset) {\n            this.charset = chaset;\n        }\n\n        public void setSmtpAuth(String userName, String password) {\n            this.smtpAuthUsername = userName;\n            this.smtpAuthPassword = Secret.fromString(password);\n        }\n\n        @Override\n        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            Mailer m = (Mailer)super.newInstance(req, formData);\n\n            if(hudsonUrl==null) {\n                // if Hudson URL is not configured yet, infer some default\n                hudsonUrl = Functions.inferHudsonURL(req);\n                save();\n            }\n\n            return m;\n        }\n\n        public FormValidation doAddressCheck(@QueryParameter String value) {\n            try {\n                new InternetAddress(value);\n                return FormValidation.ok();\n            } catch (AddressException e) {\n                return FormValidation.error(e.getMessage());\n            }\n        }\n\n        public FormValidation doCheckSmtpServer(@QueryParameter String value) {\n            try {\n                if (fixEmptyAndTrim(value)!=null)\n                    InetAddress.getByName(value);\n                return FormValidation.ok();\n            } catch (UnknownHostException e) {\n                return FormValidation.error(Messages.Mailer_Unknown_Host_Name()+value);\n            }\n        }\n\n        public FormValidation doCheckDefaultSuffix(@QueryParameter String value) {\n            if (value.matches(\"@[A-Za-z0-9.\\\\-]+\") || fixEmptyAndTrim(value)==null)\n                return FormValidation.ok();\n            else\n                return FormValidation.error(Messages.Mailer_Suffix_Error());\n        }\n\n        /**\n         * Send an email to the admin address\n         * @throws IOException\n         * @throws ServletException\n         * @throws InterruptedException\n         */\n        public FormValidation doSendTestMail(\n                @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n            try {\n                // TODO 1.590+ Jenkins.getActiveInstance\n                final Jenkins jenkins = Jenkins.getInstance();\n                if (jenkins == null) {\n                    throw new IOException(\"Jenkins instance is not ready\");\n                }\n                \n                if (!useSMTPAuth) {\n                    smtpAuthUserName = null;\n                    smtpAuthPasswordSecret = null;\n                }\n                \n                MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                msg.setFrom(stringToAddress(adminAddress, charset));\n                if (StringUtils.isNotBlank(replyToAddress)) {\n                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                }\n                msg.setSentDate(new Date());\n                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n\n                Transport.send(msg);                \n                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n            } catch (MessagingException e) {\n                return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n            }\n        }",
        "method_after": "        public DescriptorImpl() {\n            load();\n            DESCRIPTOR = this;\n        }\n\n        public String getDisplayName() {\n            return Messages.Mailer_DisplayName();\n        }\n\n        public String getDefaultSuffix() {\n            return defaultSuffix;\n        }\n\n        public String getReplyToAddress() {\n            return replyToAddress;\n        }\n\n        public void setReplyToAddress(String address) {\n            this.replyToAddress = Util.fixEmpty(address);\n        }\n\n        /** JavaMail session. */\n        public Session createSession() {\n            return createSession(smtpHost,smtpPort,useSsl,smtpAuthUsername,smtpAuthPassword);\n        }\n        private static Session createSession(String smtpHost, String smtpPort, boolean useSsl, String smtpAuthUserName, Secret smtpAuthPassword) {\n            smtpPort = fixEmptyAndTrim(smtpPort);\n            smtpAuthUserName = fixEmptyAndTrim(smtpAuthUserName);\n\n            Properties props = new Properties(System.getProperties());\n            if(fixEmptyAndTrim(smtpHost)!=null)\n                props.put(\"mail.smtp.host\",smtpHost);\n            if (smtpPort!=null) {\n                props.put(\"mail.smtp.port\", smtpPort);\n            }\n            if (useSsl) {\n            \t/* This allows the user to override settings by setting system properties but\n            \t * also allows us to use the default SMTPs port of 465 if no port is already set.\n            \t * It would be cleaner to use smtps, but that's done by calling session.getTransport()...\n            \t * and thats done in mail sender, and it would be a bit of a hack to get it all to\n            \t * coordinate, and we can make it work through setting mail.smtp properties.\n            \t */\n            \tif (props.getProperty(\"mail.smtp.socketFactory.port\") == null) {\n                    String port = smtpPort==null?\"465\":smtpPort;\n                    props.put(\"mail.smtp.port\", port);\n                    props.put(\"mail.smtp.socketFactory.port\", port);\n            \t}\n            \tif (props.getProperty(\"mail.smtp.socketFactory.class\") == null) {\n            \t\tprops.put(\"mail.smtp.socketFactory.class\",\"javax.net.ssl.SSLSocketFactory\");\n            \t}\n\t\t\t\tprops.put(\"mail.smtp.socketFactory.fallback\", \"false\");\n\t\t\t}\n            if(smtpAuthUserName!=null)\n                props.put(\"mail.smtp.auth\",\"true\");\n\n            // avoid hang by setting some timeout. \n            props.put(\"mail.smtp.timeout\",\"60000\");\n            props.put(\"mail.smtp.connectiontimeout\",\"60000\");\n\n            return Session.getInstance(props,getAuthenticator(smtpAuthUserName,Secret.toString(smtpAuthPassword)));\n        }\n\n        private static Authenticator getAuthenticator(final String smtpAuthUserName, final String smtpAuthPassword) {\n            if(smtpAuthUserName==null)    return null;\n            return new Authenticator() {\n                @Override\n                protected PasswordAuthentication getPasswordAuthentication() {\n                    return new PasswordAuthentication(smtpAuthUserName,smtpAuthPassword);\n                }\n            };\n        }\n\n        @Override\n        public boolean configure(StaplerRequest req, JSONObject json) throws FormException {\n            // this code is brain dead\n            smtpHost = nullify(json.getString(\"smtpServer\"));\n            setReplyToAddress(json.getString(\"replyToAddress\"));\n\n            defaultSuffix = nullify(json.getString(\"defaultSuffix\"));\n\n            if(json.has(\"useSMTPAuth\")) {\n                JSONObject auth = json.getJSONObject(\"useSMTPAuth\");\n                smtpAuthUsername = nullify(auth.getString(\"smtpAuthUserName\"));\n                smtpAuthPassword = Secret.fromString(nullify(auth.getString(\"smtpAuthPasswordSecret\")));\n            } else {\n                smtpAuthUsername = null;\n                smtpAuthPassword = null;\n            }\n            smtpPort = nullify(json.getString(\"smtpPort\"));\n            useSsl = json.getBoolean(\"useSsl\");\n            charset = json.getString(\"charset\");\n            if (charset == null || charset.length() == 0)\n            \tcharset = \"UTF-8\";\n            \n            save();\n            return true;\n        }\n\n        private String nullify(String v) {\n            if(v!=null && v.length()==0)    v=null;\n            return v;\n        }\n\n        public String getSmtpServer() {\n            return smtpHost;\n        }\n\n        /**\n         * Method added to pass findbugs verification when compiling against 1.642.1\n         * @return The JenkinsLocationConfiguration object.\n         * @throws IllegalStateException if the object is not available (e.g., Jenkins not fully initialized).\n         */\n        @SuppressFBWarnings(value = \"NP_NULL_ON_SOME_PATH_FROM_RETURN_VALUE\",\n            justification = \"False positive. See https://sourceforge.net/p/findbugs/bugs/1411/\")\n        private JenkinsLocationConfiguration getJenkinsLocationConfiguration() {\n            final JenkinsLocationConfiguration jlc = JenkinsLocationConfiguration.get();\n            if (jlc == null) {\n                throw new IllegalStateException(\"JenkinsLocationConfiguration not available\");\n            }\n            return jlc;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getAdminAddress() {\n            return getJenkinsLocationConfiguration().getAdminAddress();\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public String getUrl() {\n            return getJenkinsLocationConfiguration().getUrl();\n        }\n\n        public String getSmtpAuthUserName() {\n            return smtpAuthUsername;\n        }\n\n        public String getSmtpAuthPassword() {\n            if (smtpAuthPassword==null) return null;\n            return Secret.toString(smtpAuthPassword);\n        }\n\n        public Secret getSmtpAuthPasswordSecret() {\n            return smtpAuthPassword;\n        }\n\n        public boolean getUseSsl() {\n        \treturn useSsl;\n        }\n\n        public String getSmtpPort() {\n        \treturn smtpPort;\n        }\n        \n        public String getCharset() {\n        \tString c = charset;\n        \tif (c == null || c.length() == 0)\tc = \"UTF-8\";\n        \treturn c;\n        }\n\n        public void setDefaultSuffix(String defaultSuffix) {\n            this.defaultSuffix = defaultSuffix;\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setHudsonUrl(String hudsonUrl) {\n            getJenkinsLocationConfiguration().setUrl(hudsonUrl);\n        }\n\n        /**\n         * @deprecated as of 1.4\n         *      Use {@link JenkinsLocationConfiguration}\n         */\n        public void setAdminAddress(String adminAddress) {\n            getJenkinsLocationConfiguration().setAdminAddress(adminAddress);\n        }\n\n        public void setSmtpHost(String smtpHost) {\n            this.smtpHost = smtpHost;\n        }\n\n        public void setUseSsl(boolean useSsl) {\n            this.useSsl = useSsl;\n        }\n\n        public void setSmtpPort(String smtpPort) {\n            this.smtpPort = smtpPort;\n        }\n        \n        public void setCharset(String chaset) {\n            this.charset = chaset;\n        }\n\n        public void setSmtpAuth(String userName, String password) {\n            this.smtpAuthUsername = userName;\n            this.smtpAuthPassword = Secret.fromString(password);\n        }\n\n        @Override\n        public Publisher newInstance(StaplerRequest req, JSONObject formData) throws FormException {\n            Mailer m = (Mailer)super.newInstance(req, formData);\n\n            if(hudsonUrl==null) {\n                // if Hudson URL is not configured yet, infer some default\n                hudsonUrl = Functions.inferHudsonURL(req);\n                save();\n            }\n\n            return m;\n        }\n\n        public FormValidation doAddressCheck(@QueryParameter String value) {\n            try {\n                new InternetAddress(value);\n                return FormValidation.ok();\n            } catch (AddressException e) {\n                return FormValidation.error(e.getMessage());\n            }\n        }\n\n        public FormValidation doCheckSmtpServer(@QueryParameter String value) {\n            try {\n                if (fixEmptyAndTrim(value)!=null)\n                    InetAddress.getByName(value);\n                return FormValidation.ok();\n            } catch (UnknownHostException e) {\n                return FormValidation.error(Messages.Mailer_Unknown_Host_Name()+value);\n            }\n        }\n\n        public FormValidation doCheckDefaultSuffix(@QueryParameter String value) {\n            if (value.matches(\"@[A-Za-z0-9.\\\\-]+\") || fixEmptyAndTrim(value)==null)\n                return FormValidation.ok();\n            else\n                return FormValidation.error(Messages.Mailer_Suffix_Error());\n        }\n\n        /**\n         * Send an email to the admin address\n         * @throws IOException\n         * @throws ServletException\n         * @throws InterruptedException\n         */\n        @RequirePOST\n        public FormValidation doSendTestMail(\n                @QueryParameter String smtpServer, @QueryParameter String adminAddress, @QueryParameter boolean useSMTPAuth,\n                @QueryParameter String smtpAuthUserName, @QueryParameter Secret smtpAuthPasswordSecret,\n                @QueryParameter boolean useSsl, @QueryParameter String smtpPort, @QueryParameter String charset,\n                @QueryParameter String sendTestMailTo) throws IOException, ServletException, InterruptedException {\n            try {\n                // TODO 1.590+ Jenkins.getActiveInstance\n                final Jenkins jenkins = Jenkins.getInstance();\n                if (jenkins == null) {\n                    throw new IOException(\"Jenkins instance is not ready\");\n                }\n\n                jenkins.checkPermission(Jenkins.ADMINISTER);\n                \n                if (!useSMTPAuth) {\n                    smtpAuthUserName = null;\n                    smtpAuthPasswordSecret = null;\n                }\n                \n                MimeMessage msg = new MimeMessage(createSession(smtpServer, smtpPort, useSsl, smtpAuthUserName, smtpAuthPasswordSecret));\n                msg.setSubject(Messages.Mailer_TestMail_Subject(testEmailCount.incrementAndGet()), charset);\n                msg.setText(Messages.Mailer_TestMail_Content(testEmailCount.get(), jenkins.getDisplayName()), charset);\n                msg.setFrom(stringToAddress(adminAddress, charset));\n                if (StringUtils.isNotBlank(replyToAddress)) {\n                    msg.setReplyTo(new Address[]{stringToAddress(replyToAddress, charset)});\n                }\n                msg.setSentDate(new Date());\n                msg.setRecipient(Message.RecipientType.TO, stringToAddress(sendTestMailTo, charset));\n\n                Transport.send(msg);                \n                return FormValidation.ok(Messages.Mailer_EmailSentSuccessfully());\n            } catch (MessagingException e) {\n                return FormValidation.errorWithMarkup(\"<p>\"+Messages.Mailer_FailedToSendEmail()+\"</p><pre>\"+Util.escape(Functions.printThrowable(e))+\"</pre>\");\n            }\n        }"
    },
    {
        "idx": "1064",
        "vuln_id": "CVE-2019-3775",
        "desc": "Cloud Foundry UAA, versions prior to v70.0, allows a user to update their own email address. A remote authenticated user can impersonate a different user by changing their email address to that of a different user.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/cloudfoundry/uaa",
        "commit": "daeedbe499453b06856556f5e9f7e80d2d1ceb03",
        "method_before": "    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }",
        "method_after": "    public boolean isAllowed(HttpServletRequest request) throws IOException {\n        String requestBody = IOUtils.toString(request.getReader());\n        ScimUser scimUserFromRequest = JsonUtils.readValue(requestBody, ScimUser.class);\n\n        String id = UaaUrlUtils.extractPathVariableFromUrl(USER_ID_PATH_PARAMETER_INDEX, UaaUrlUtils.getRequestPath(request));\n        String zoneId = IdentityZoneHolder.get().getId();\n        ScimUser scimUserFromDb;\n\n        try {\n            scimUserFromDb = scimUserProvisioning.retrieve(id, zoneId);\n        } catch (ScimResourceNotFoundException e) {\n            return true;\n        }\n\n        if (!scimUserFromDb.getPrimaryEmail().equals(scimUserFromRequest.getPrimaryEmail())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getEmails().containsAll(scimUserFromRequest.getEmails())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getUserName().equals(scimUserFromRequest.getUserName())) {\n            return false;\n        }\n\n        if (scimUserFromDb.isVerified() != scimUserFromRequest.isVerified()) {\n            return false;\n        }\n\n        if (scimUserFromDb.isActive() != (scimUserFromRequest.isActive())) {\n            return false;\n        }\n\n        if (!scimUserFromDb.getOrigin().equals(scimUserFromRequest.getOrigin())) {\n            return false;\n        }\n\n\n        return true;\n    }"
    },
    {
        "idx": "1520",
        "vuln_id": "CVE-2019-19999",
        "desc": "Halo before 1.2.0-beta.1 allows Server Side Template Injection (SSTI) because TemplateClassResolver.SAFER_RESOLVER is not used in the FreeMarker configuration.",
        "cwe_id": "CWE-918",
        "cwe_name": "Server-Side Request Forgery (SSRF)",
        "repo": "https://github.com/halo-dev/halo",
        "commit": "dc3a73ee02ca183c509dedf703db28c80219c41c",
        "method_before": "    public FreeMarkerConfigurer freemarkerConfig(HaloProperties haloProperties) throws IOException, TemplateException {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPaths(FILE_PROTOCOL + haloProperties.getWorkDir() + \"templates/\", \"classpath:/templates/\");\n        configurer.setDefaultEncoding(\"UTF-8\");\n\n        Properties properties = new Properties();\n        properties.setProperty(\"auto_import\", \"/common/macro/common_macro.ftl as common,/common/macro/global_macro.ftl as global\");\n\n        configurer.setFreemarkerSettings(properties);\n\n        // Predefine configuration\n        freemarker.template.Configuration configuration = configurer.createConfiguration();\n        if (haloProperties.isProductionEnv()) {\n            configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n        }\n\n        // Set predefined freemarker configuration\n        configurer.setConfiguration(configuration);\n\n        return configurer;\n    }",
        "method_after": "    public FreeMarkerConfigurer freemarkerConfig(HaloProperties haloProperties) throws IOException, TemplateException {\n        FreeMarkerConfigurer configurer = new FreeMarkerConfigurer();\n        configurer.setTemplateLoaderPaths(FILE_PROTOCOL + haloProperties.getWorkDir() + \"templates/\", \"classpath:/templates/\");\n        configurer.setDefaultEncoding(\"UTF-8\");\n\n        Properties properties = new Properties();\n        properties.setProperty(\"auto_import\", \"/common/macro/common_macro.ftl as common,/common/macro/global_macro.ftl as global\");\n\n        configurer.setFreemarkerSettings(properties);\n\n        // Predefine configuration\n        freemarker.template.Configuration configuration = configurer.createConfiguration();\n\n        configuration.setNewBuiltinClassResolver(TemplateClassResolver.SAFER_RESOLVER);\n\n        if (haloProperties.isProductionEnv()) {\n            configuration.setTemplateExceptionHandler(TemplateExceptionHandler.RETHROW_HANDLER);\n        }\n\n        // Set predefined freemarker configuration\n        configurer.setConfiguration(configuration);\n\n        return configurer;\n    }"
    },
    {
        "idx": "1527",
        "vuln_id": "CVE-2019-3559",
        "desc": "Java Facebook Thrift servers would not error upon receiving messages with containers of fields of unknown type. As a result, malicious clients could send short messages which would take a long time for the server to parse, potentially leading to denial of service. This issue affects Facebook Thrift prior to v2019.02.18.00.",
        "cwe_id": "CWE-755",
        "cwe_name": "Improper Handling of Exceptional Conditions",
        "repo": "https://github.com/facebook/fbthrift",
        "commit": "a56346ceacad28bf470017a6bda1d5518d0bd943",
        "method_before": "  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      break;\n    }\n  }",
        "method_after": "  public static void skip(TProtocol prot, byte type, int maxDepth)\n  throws TException {\n    if (maxDepth <= 0) {\n      throw new TException(\"Maximum skip depth exceeded\");\n    }\n    switch (type) {\n    case TType.BOOL:\n      {\n        prot.readBool();\n        break;\n      }\n    case TType.BYTE:\n      {\n        prot.readByte();\n        break;\n      }\n    case TType.I16:\n      {\n        prot.readI16();\n        break;\n      }\n    case TType.I32:\n      {\n        prot.readI32();\n        break;\n      }\n    case TType.I64:\n      {\n        prot.readI64();\n        break;\n      }\n    case TType.DOUBLE:\n      {\n        prot.readDouble();\n        break;\n      }\n    case TType.FLOAT:\n      {\n        prot.readFloat();\n        break;\n      }\n    case TType.STRING:\n      {\n        prot.readBinary();\n        break;\n      }\n    case TType.STRUCT:\n      {\n        prot.readStructBegin(\n            Collections.<Integer, com.facebook.thrift.meta_data.FieldMetaData>emptyMap());\n        while (true) {\n          TField field = prot.readFieldBegin();\n          if (field.type == TType.STOP) {\n            break;\n          }\n          skip(prot, field.type, maxDepth - 1);\n          prot.readFieldEnd();\n        }\n        prot.readStructEnd();\n        break;\n      }\n    case TType.MAP:\n      {\n        TMap map = prot.readMapBegin();\n        for (int i = 0;\n             (map.size < 0) ? prot.peekMap() : (i < map.size);\n             i++) {\n          skip(prot, map.keyType, maxDepth - 1);\n          skip(prot, map.valueType, maxDepth - 1);\n        }\n        prot.readMapEnd();\n        break;\n      }\n    case TType.SET:\n      {\n        TSet set = prot.readSetBegin();\n        for (int i = 0;\n             (set.size < 0) ? prot.peekSet() : (i < set.size);\n             i++) {\n          skip(prot, set.elemType, maxDepth - 1);\n        }\n        prot.readSetEnd();\n        break;\n      }\n    case TType.LIST:\n      {\n        TList list = prot.readListBegin();\n        for (int i = 0;\n             (list.size < 0) ? prot.peekList() : (i < list.size);\n             i++) {\n          skip(prot, list.elemType, maxDepth - 1);\n        }\n        prot.readListEnd();\n        break;\n      }\n    default:\n      {\n        throw new TProtocolException(\n              TProtocolException.INVALID_DATA, \"Invalid type encountered during skipping: \" + type);\n      }\n    }\n  }"
    },
    {
        "idx": "309",
        "vuln_id": "CVE-2015-1772",
        "desc": "The LDAP implementation in HiveServer2 in Apache Hive before 1.0.1 and 1.1.x before 1.1.1, as used in IBM InfoSphere BigInsights 3.0, 3.0.0.1, and 3.0.0.2 and other products, mishandles simple unauthenticated and anonymous bind configurations, which allows remote attackers to bypass authentication via a crafted LDAP request.",
        "cwe_id": "CWE-287",
        "cwe_name": "Improper Authentication",
        "repo": "https://github.com/apache/hive",
        "commit": "6929846a8120eaf094b914b4ca8af80b65f891c8",
        "method_before": "  public void Authenticate(String user, String password) throws AuthenticationException {\n\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n    env.put(Context.PROVIDER_URL, ldapURL);\n\n    // If the domain is available in the config, then append it unless domain is\n    // already part of the username. LDAP providers like Active Directory use a\n    // fully qualified user name like foo@bar.com.\n    if (!hasDomain(user) && ldapDomain != null) {\n      user  = user + \"@\" + ldapDomain;\n    }\n\n    // setup the security principal\n    String bindDN;\n    if (baseDN == null) {\n      bindDN = user;\n    } else {\n      bindDN = \"uid=\" + user + \",\" + baseDN;\n    }\n    env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n    env.put(Context.SECURITY_PRINCIPAL, bindDN);\n    env.put(Context.SECURITY_CREDENTIALS, password);\n\n    try {\n      // Create initial context\n      Context ctx = new InitialDirContext(env);\n      ctx.close();\n    } catch (NamingException e) {\n      throw new AuthenticationException(\"Error validating LDAP user\", e);\n    }\n  }",
        "method_after": "  public void Authenticate(String user, String password) throws AuthenticationException {\n\n    Hashtable<String, Object> env = new Hashtable<String, Object>();\n    env.put(Context.INITIAL_CONTEXT_FACTORY, \"com.sun.jndi.ldap.LdapCtxFactory\");\n    env.put(Context.PROVIDER_URL, ldapURL);\n\n    // If the domain is available in the config, then append it unless domain is\n    // already part of the username. LDAP providers like Active Directory use a\n    // fully qualified user name like foo@bar.com.\n    if (!hasDomain(user) && ldapDomain != null) {\n      user  = user + \"@\" + ldapDomain;\n    }\n\n    if (password == null || password.isEmpty()) {\n      throw new AuthenticationException(\"Error validating LDAP user:\" +\n          \" a null or blank password has been provided\");\n    }\n\n    // setup the security principal\n    String bindDN;\n    if (baseDN == null) {\n      bindDN = user;\n    } else {\n      bindDN = \"uid=\" + user + \",\" + baseDN;\n    }\n    env.put(Context.SECURITY_AUTHENTICATION, \"simple\");\n    env.put(Context.SECURITY_PRINCIPAL, bindDN);\n    env.put(Context.SECURITY_CREDENTIALS, password);\n\n    try {\n      // Create initial context\n      Context ctx = new InitialDirContext(env);\n      ctx.close();\n    } catch (NamingException e) {\n      throw new AuthenticationException(\"Error validating LDAP user\", e);\n    }\n  }"
    },
    {
        "idx": "546",
        "vuln_id": "CVE-2017-1000395",
        "desc": "Jenkins 2.73.1 and earlier, 2.83 and earlier provides information about Jenkins user accounts which is generally available to anyone with Overall/Read permissions via the /user/(username)/api remote API. This included e.g. Jenkins users' email addresses if the Mailer Plugin is installed. The remote API now no longer includes information beyond the most basic (user ID and name) unless the user requesting it is a Jenkins administrator.",
        "cwe_id": "CWE-200",
        "cwe_name": "Exposure of Sensitive Information to an Unauthorized Actor",
        "repo": "https://github.com/jenkinsci/jenkins",
        "commit": "7b1f8e96a8d97dd09e5e093fcdb010b3295acc77",
        "method_before": "    public List<UserProperty> getAllProperties() {\n        return Collections.unmodifiableList(properties);\n    }",
        "method_after": "    public List<UserProperty> getAllProperties() {\n        if (hasPermission(Jenkins.ADMINISTER)) {\n            return Collections.unmodifiableList(properties);\n        }\n\n        return Collections.emptyList();\n    }"
    },
    {
        "idx": "660",
        "vuln_id": "CVE-2017-5650",
        "desc": "In Apache Tomcat 9.0.0.M1 to 9.0.0.M18 and 8.5.0 to 8.5.12, the handling of an HTTP/2 GOAWAY frame for a connection did not close streams associated with that connection that were currently waiting for a WINDOW_UPDATE before allowing the application to write more data. These waiting streams each consumed a thread. A malicious client could therefore construct a series of HTTP/2 requests that would consume all available processing threads.",
        "cwe_id": "CWE-404",
        "cwe_name": "Improper Resource Shutdown or Release",
        "repo": "https://github.com/apache/tomcat",
        "commit": "5496e193a89b8b8b3177e516358df2f07ab852b3",
        "method_before": "    private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }",
        "method_after": "    private void close() {\n        connectionState.set(ConnectionState.CLOSED);\n        for (Stream stream : streams.values()) {\n            // The connection is closing. Close the associated streams as no\n            // longer required.\n            stream.receiveReset(Http2Error.CANCEL.getCode());\n        }\n        try {\n            socketWrapper.close();\n        } catch (IOException ioe) {\n            log.debug(sm.getString(\"upgradeHandler.socketCloseFailed\"), ioe);\n        }\n    }"
    },
    {
        "idx": "777",
        "vuln_id": "CVE-2018-11758",
        "desc": "This affects Apache Cayenne 4.1.M1, 3.2.M1, 4.0.M2 to 4.0.M5, 4.0.B1, 4.0.B2, 4.0.RC1, 3.1, 3.1.1, 3.1.2. CayenneModeler is a desktop GUI tool shipped with Apache Cayenne and intended for editing Cayenne ORM models stored as XML files. If an attacker tricks a user of CayenneModeler into opening a malicious XML file, the attacker will be able to instruct the XML parser built into CayenneModeler to transfer files from a local machine to a remote machine controlled by the attacker. The cause of the issue is XML parser processing XML External Entity (XXE) declarations included in XML. The vulnerability is addressed in Cayenne by disabling XXE processing in all operations that require XML parsing.",
        "cwe_id": "CWE-611",
        "cwe_name": "Improper Restriction of XML External Entity Reference",
        "repo": "https://github.com/apache/cayenne",
        "commit": "6fc896b65ed871be33dcf453cde924bf73cf83db",
        "method_before": "\tpublic static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\n\t\t// Create a JAXP SAXParser\n\t\tSAXParser saxParser = spf.newSAXParser();\n\n\t\t// Get the encapsulated SAX XMLReader\n\t\tXMLReader reader = saxParser.getXMLReader();\n\n\t\t// set default features\n\t\treader.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\treturn reader;\n\t}",
        "method_after": "\tpublic static XMLReader createXmlReader() throws SAXException, ParserConfigurationException {\n\t\tSAXParserFactory spf = SAXParserFactory.newInstance();\n\t\tspf.setFeature(\"http://apache.org/xml/features/disallow-doctype-decl\", true);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-general-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/external-parameter-entities\", false);\n\t\tspf.setFeature(\"http://xml.org/sax/features/namespaces\", true);\n\n\t\t// Create a JAXP SAXParser\n\t\tSAXParser saxParser = spf.newSAXParser();\n\n\t\t// Get the encapsulated SAX XMLReader\n\t\treturn saxParser.getXMLReader();\n\t}"
    },
    {
        "idx": "873",
        "vuln_id": "CVE-2018-1336",
        "desc": "An improper handing of overflow in the UTF-8 decoder with supplementary characters can lead to an infinite loop in the decoder causing a Denial of Service. Versions Affected: Apache Tomcat 9.0.0.M9 to 9.0.7, 8.5.0 to 8.5.30, 8.0.0.RC1 to 8.0.51, and 7.0.28 to 7.0.86.",
        "cwe_id": "CWE-835",
        "cwe_name": "Loop with Unreachable Exit Condition ('Infinite Loop')",
        "repo": "https://github.com/apache/tomcat",
        "commit": "92cd494555598e99dd691712e8ee426a2f9c2e93",
        "method_before": "    private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                // If first byte is invalid, tail will be set to -1\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                // Additional checks to detect invalid sequences ASAP\n                // Checks derived from Unicode 6.2, Chapter 3, Table 3-7\n                // Check 2nd byte\n                int tailAvailable = inIndexLimit - inIndex - 1;\n                if (tailAvailable > 0) {\n                    // First byte C2..DF, second byte 80..BF\n                    if (jchar > 0x41 && jchar < 0x60 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E0, second byte A0..BF\n                    if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E1..EC, second byte 80..BF\n                    if (jchar > 0x60 && jchar < 0x6D &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte ED, second byte 80..9F\n                    if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte EE..EF, second byte 80..BF\n                    if (jchar > 0x6D && jchar < 0x70 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F0, second byte 90..BF\n                    if (jchar == 0x70 &&\n                            ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                            (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F1..F3, second byte 80..BF\n                    if (jchar > 0x70 && jchar < 0x74 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F4, second byte 80..8F\n                    if (jchar == 0x74 &&\n                            (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                }\n                // Check third byte if present and expected\n                if (tailAvailable > 1 && tail > 1) {\n                    if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(2);\n                    }\n                }\n                // Check fourth byte if present and expected\n                if (tailAvailable > 2 && tail > 2) {\n                    if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(3);\n                    }\n                }\n                if (tailAvailable < tail) {\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                CoderResult.OVERFLOW :\n                CoderResult.UNDERFLOW;\n    }",
        "method_after": "    private CoderResult decodeHasArray(ByteBuffer in, CharBuffer out) {\n        int outRemaining = out.remaining();\n        int pos = in.position();\n        int limit = in.limit();\n        final byte[] bArr = in.array();\n        final char[] cArr = out.array();\n        final int inIndexLimit = limit + in.arrayOffset();\n        int inIndex = pos + in.arrayOffset();\n        int outIndex = out.position() + out.arrayOffset();\n        // if someone would change the limit in process,\n        // he would face consequences\n        for (; inIndex < inIndexLimit && outRemaining > 0; inIndex++) {\n            int jchar = bArr[inIndex];\n            if (jchar < 0) {\n                jchar = jchar & 0x7F;\n                // If first byte is invalid, tail will be set to -1\n                int tail = remainingBytes[jchar];\n                if (tail == -1) {\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                // Additional checks to detect invalid sequences ASAP\n                // Checks derived from Unicode 6.2, Chapter 3, Table 3-7\n                // Check 2nd byte\n                int tailAvailable = inIndexLimit - inIndex - 1;\n                if (tailAvailable > 0) {\n                    // First byte C2..DF, second byte 80..BF\n                    if (jchar > 0x41 && jchar < 0x60 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E0, second byte A0..BF\n                    if (jchar == 0x60 && (bArr[inIndex + 1] & 0xE0) != 0xA0) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte E1..EC, second byte 80..BF\n                    if (jchar > 0x60 && jchar < 0x6D &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte ED, second byte 80..9F\n                    if (jchar == 0x6D && (bArr[inIndex + 1] & 0xE0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte EE..EF, second byte 80..BF\n                    if (jchar > 0x6D && jchar < 0x70 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F0, second byte 90..BF\n                    if (jchar == 0x70 &&\n                            ((bArr[inIndex + 1] & 0xFF) < 0x90 ||\n                            (bArr[inIndex + 1] & 0xFF) > 0xBF)) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F1..F3, second byte 80..BF\n                    if (jchar > 0x70 && jchar < 0x74 &&\n                            (bArr[inIndex + 1] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                    // First byte F4, second byte 80..8F\n                    if (jchar == 0x74 &&\n                            (bArr[inIndex + 1] & 0xF0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1);\n                    }\n                }\n                // Check third byte if present and expected\n                if (tailAvailable > 1 && tail > 1) {\n                    if ((bArr[inIndex + 2] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(2);\n                    }\n                }\n                // Check fourth byte if present and expected\n                if (tailAvailable > 2 && tail > 2) {\n                    if ((bArr[inIndex + 3] & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(3);\n                    }\n                }\n                if (tailAvailable < tail) {\n                    break;\n                }\n                for (int i = 0; i < tail; i++) {\n                    int nextByte = bArr[inIndex + i + 1] & 0xFF;\n                    if ((nextByte & 0xC0) != 0x80) {\n                        in.position(inIndex - in.arrayOffset());\n                        out.position(outIndex - out.arrayOffset());\n                        return CoderResult.malformedForLength(1 + i);\n                    }\n                    jchar = (jchar << 6) + nextByte;\n                }\n                jchar -= remainingNumbers[tail];\n                if (jchar < lowerEncodingLimit[tail]) {\n                    // Should have been encoded in fewer octets\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.malformedForLength(1);\n                }\n                inIndex += tail;\n            }\n            // Apache Tomcat added test\n            if (jchar >= 0xD800 && jchar <= 0xDFFF) {\n                return CoderResult.unmappableForLength(3);\n            }\n            // Apache Tomcat added test\n            if (jchar > 0x10FFFF) {\n                return CoderResult.unmappableForLength(4);\n            }\n            if (jchar <= 0xffff) {\n                cArr[outIndex++] = (char) jchar;\n                outRemaining--;\n            } else {\n                if (outRemaining < 2) {\n                    // Encoded with 4 bytes. inIndex currently points\n                    // to the final byte. Move it back to first byte.\n                    inIndex -= 3;\n                    in.position(inIndex - in.arrayOffset());\n                    out.position(outIndex - out.arrayOffset());\n                    return CoderResult.OVERFLOW;\n                }\n                cArr[outIndex++] = (char) ((jchar >> 0xA) + 0xD7C0);\n                cArr[outIndex++] = (char) ((jchar & 0x3FF) + 0xDC00);\n                outRemaining -= 2;\n            }\n        }\n        in.position(inIndex - in.arrayOffset());\n        out.position(outIndex - out.arrayOffset());\n        return (outRemaining == 0 && inIndex < inIndexLimit) ?\n                CoderResult.OVERFLOW :\n                CoderResult.UNDERFLOW;\n    }"
    },
    {
        "idx": "916",
        "vuln_id": "CVE-2018-19859",
        "desc": "OpenRefine before 3.2 beta allows directory traversal via a relative pathname in a ZIP archive.",
        "cwe_id": "CWE-22",
        "cwe_name": "Improper Limitation of a Pathname to a Restricted Directory ('Path Traversal')",
        "repo": "https://github.com/OpenRefine/OpenRefine",
        "commit": "e243e73e4064de87a913946bd320fbbe246da656",
        "method_before": "    static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }",
        "method_after": "    static public File allocateFile(File dir, String name) {\n        int q = name.indexOf('?');\n        if (q > 0) {\n            name = name.substring(0, q);\n        }\n        \n        File file = new File(dir, name);     \n        // For CVE-2018-19859, issue #1840\n        if (!file.toPath().normalize().startsWith(dir.toPath().normalize())) {\n        \tthrow new IllegalArgumentException(\"Zip archives with files escaping their root directory are not allowed.\");\n        }\n        \n        int dot = name.indexOf('.');\n        String prefix = dot < 0 ? name : name.substring(0, dot);\n        String suffix = dot < 0 ? \"\" : name.substring(dot);\n        int index = 2;\n        while (file.exists()) {\n            file = new File(dir, prefix + \"-\" + index++ + suffix);\n        }\n        \n        file.getParentFile().mkdirs();\n        \n        return file;\n    }"
    },
    {
        "idx": "1015",
        "vuln_id": "CVE-2019-10219",
        "desc": "A vulnerability was found in Hibernate-Validator. The SafeHtml validator annotation fails to properly sanitize payloads consisting of potentially malicious code in HTML comments and instructions. This vulnerability can result in an XSS attack.",
        "cwe_id": "CWE-79",
        "cwe_name": "Improper Neutralization of Input During Web Page Generation ('Cross-site Scripting')",
        "repo": "https://github.com/hibernate/hibernate-validator",
        "commit": "124b7dd6d9a4ad24d4d49f74701f05a13e56ceee",
        "method_before": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tIterator<Element> nodes = fragment.children().iterator();\n\t\twhile ( nodes.hasNext() ) {\n\t\t\tdocument.body().appendChild( nodes.next() );\n\t\t}\n\n\t\treturn document;\n\t}",
        "method_after": "\tprivate Document getFragmentAsDocument(CharSequence value) {\n\t\t// using the XML parser ensures that all elements in the input are retained, also if they actually are not allowed at the given\n\t\t// location; E.g. a <td> element isn't allowed directly within the <body> element, so it would be used by the default HTML parser.\n\t\t// we need to retain it though to apply the given white list properly; See HV-873\n\t\tDocument fragment = Jsoup.parse( value.toString(), baseURI, Parser.xmlParser() );\n\t\tDocument document = Document.createShell( baseURI );\n\n\t\t// add the fragment's nodes to the body of resulting document\n\t\tList<Node> childNodes = fragment.childNodes();\n\t\tfor ( Node node : childNodes ) {\n\t\t\tdocument.body().appendChild( node.clone() );\n\t\t}\n\n\t\treturn document;\n\t}"
    },
    {
        "idx": "1603",
        "vuln_id": "CVE-2021-21244",
        "desc": "OneDev is an all-in-one devops platform. In OneDev before version 4.0.3, There is a vulnerability that enabled pre-auth server side template injection via Bean validation message tampering. Full details in the reference GHSA. This issue was fixed in 4.0.3 by disabling validation interpolation completely.",
        "cwe_id": "CWE-94",
        "cwe_name": "Improper Control of Generation of Code ('Code Injection')",
        "repo": "https://github.com/theonedev/onedev",
        "commit": "4f5dc6fb9e50f2c41c4929b0d8c5824b2cca3d65",
        "method_before": "\t\tsuper.configure();\n\t\t\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\n\t\t\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\n\t\t\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\n\n\t\t\t@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation.byDefaultProvider().configure();\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}\n\t\t\t\n\t\t}).in(Singleton.class);\n\t\t\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\n\n\t\t// configure markdown\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\t\t\n\t\t\n\t\tconfigurePersistence();\n\t\tconfigureRestServices();\n\t\tconfigureWeb();\n\t\tconfigureBuild();\n\t\t\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\n\n\t\t/*\n\t\t * Declare bindings explicitly instead of using ImplementedBy annotation as\n\t\t * HK2 to guice bridge can only search in explicit bindings in Guice   \n\t\t */\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\n\t\tbind(PullRequestNotificationManager.class);\n\t\tbind(CommitNotificationManager.class);\n\t\tbind(BuildNotificationManager.class);\n\t\tbind(IssueNotificationManager.class);\n\t\tbind(EntityReferenceManager.class);\n\t\tbind(CodeCommentNotificationManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\n\t\tbind(Session.class).toProvider(SessionProvider.class);\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\n\t\tbind(WebHookManager.class);\n\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\n\t    \n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\n\t\tbind(BasicAuthenticationFilter.class);\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\n\t\tbind(ShiroFilter.class);\n\t\tinstall(new ShiroAopModule());\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\n\n            @Override\n            public void configure(FilterChainManager filterChainManager) {\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\n            }\n            \n        });\n        contributeFromPackage(Authenticator.class, Authenticator.class);\n        \n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\n\n\t\t\t@Override\n\t\t\tpublic Class<?> getAbstractClass() {\n\t\t\t\treturn JobExecutor.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Collection<Class<?>> getImplementations() {\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\n        \n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\n\t\t\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\n\t\t\n\t\tbind(GitFilter.class);\n\t\tbind(GitPreReceiveCallback.class);\n\t\tbind(GitPostReceiveCallback.class);\n\t\t\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\n\n\t\t\t@Override\n\t\t\tpublic ExecutorService get() {\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, \n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t\tif (!isShutdown())\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t        };\n\t\t\t}\n\t    \t\n\t    }).in(Singleton.class);\n\t    \n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\n\n\t\t\t@Override\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable task) {\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, \n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t    });\n\t}",
        "method_after": "\t\tsuper.configure();\n\t\t\n\t\tbind(JettyRunner.class).to(DefaultJettyRunner.class);\n\t\tbind(ServletContextHandler.class).toProvider(DefaultJettyRunner.class);\n\t\t\n\t\tbind(ObjectMapper.class).toProvider(ObjectMapperProvider.class).in(Singleton.class);\n\t\t\n\t\tbind(ValidatorFactory.class).toProvider(new com.google.inject.Provider<ValidatorFactory>() {\n\n\t\t\t@Override\n\t\t\tpublic ValidatorFactory get() {\n\t\t\t\tConfiguration<?> configuration = Validation\n\t\t\t\t\t\t.byDefaultProvider()\n\t\t\t\t\t\t.configure()\n\t\t\t\t\t\t.messageInterpolator(new ParameterMessageInterpolator());\n\t\t\t\treturn configuration.buildValidatorFactory();\n\t\t\t}\n\t\t\t\n\t\t}).in(Singleton.class);\n\t\t\n\t\tbind(Validator.class).toProvider(ValidatorProvider.class).in(Singleton.class);\n\n\t\t// configure markdown\n\t\tbind(MarkdownManager.class).to(DefaultMarkdownManager.class);\t\t\n\t\t\n\t\tconfigurePersistence();\n\t\tconfigureRestServices();\n\t\tconfigureWeb();\n\t\tconfigureBuild();\n\t\t\n\t\tbind(GitConfig.class).toProvider(GitConfigProvider.class);\n\n\t\t/*\n\t\t * Declare bindings explicitly instead of using ImplementedBy annotation as\n\t\t * HK2 to guice bridge can only search in explicit bindings in Guice   \n\t\t */\n\t\tbind(StorageManager.class).to(DefaultStorageManager.class);\n\t\tbind(SettingManager.class).to(DefaultSettingManager.class);\n\t\tbind(DataManager.class).to(DefaultDataManager.class);\n\t\tbind(TaskScheduler.class).to(DefaultTaskScheduler.class);\n\t\tbind(PullRequestCommentManager.class).to(DefaultPullRequestCommentManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(PullRequestManager.class).to(DefaultPullRequestManager.class);\n\t\tbind(PullRequestUpdateManager.class).to(DefaultPullRequestUpdateManager.class);\n\t\tbind(ProjectManager.class).to(DefaultProjectManager.class);\n\t\tbind(UserManager.class).to(DefaultUserManager.class);\n\t\tbind(PullRequestReviewManager.class).to(DefaultPullRequestReviewManager.class);\n\t\tbind(BuildManager.class).to(DefaultBuildManager.class);\n\t\tbind(BuildDependenceManager.class).to(DefaultBuildDependenceManager.class);\n\t\tbind(JobManager.class).to(DefaultJobManager.class);\n\t\tbind(LogManager.class).to(DefaultLogManager.class);\n\t\tbind(PullRequestBuildManager.class).to(DefaultPullRequestBuildManager.class);\n\t\tbind(MailManager.class).to(DefaultMailManager.class);\n\t\tbind(IssueManager.class).to(DefaultIssueManager.class);\n\t\tbind(IssueFieldManager.class).to(DefaultIssueFieldManager.class);\n\t\tbind(BuildParamManager.class).to(DefaultBuildParamManager.class);\n\t\tbind(UserAuthorizationManager.class).to(DefaultUserAuthorizationManager.class);\n\t\tbind(GroupAuthorizationManager.class).to(DefaultGroupAuthorizationManager.class);\n\t\tbind(PullRequestWatchManager.class).to(DefaultPullRequestWatchManager.class);\n\t\tbind(RoleManager.class).to(DefaultRoleManager.class);\n\t\tbind(CommitInfoManager.class).to(DefaultCommitInfoManager.class);\n\t\tbind(UserInfoManager.class).to(DefaultUserInfoManager.class);\n\t\tbind(BatchWorkManager.class).to(DefaultBatchWorkManager.class);\n\t\tbind(GroupManager.class).to(DefaultGroupManager.class);\n\t\tbind(MembershipManager.class).to(DefaultMembershipManager.class);\n\t\tbind(PullRequestChangeManager.class).to(DefaultPullRequestChangeManager.class);\n\t\tbind(CodeCommentReplyManager.class).to(DefaultCodeCommentReplyManager.class);\n\t\tbind(AttachmentStorageManager.class).to(DefaultAttachmentStorageManager.class);\n\t\tbind(CodeCommentRelationInfoManager.class).to(DefaultCodeCommentRelationInfoManager.class);\n\t\tbind(CodeCommentRelationManager.class).to(DefaultCodeCommentRelationManager.class);\n\t\tbind(WorkExecutor.class).to(DefaultWorkExecutor.class);\n\t\tbind(PullRequestNotificationManager.class);\n\t\tbind(CommitNotificationManager.class);\n\t\tbind(BuildNotificationManager.class);\n\t\tbind(IssueNotificationManager.class);\n\t\tbind(EntityReferenceManager.class);\n\t\tbind(CodeCommentNotificationManager.class);\n\t\tbind(CodeCommentManager.class).to(DefaultCodeCommentManager.class);\n\t\tbind(IssueWatchManager.class).to(DefaultIssueWatchManager.class);\n\t\tbind(IssueChangeManager.class).to(DefaultIssueChangeManager.class);\n\t\tbind(IssueVoteManager.class).to(DefaultIssueVoteManager.class);\n\t\tbind(MilestoneManager.class).to(DefaultMilestoneManager.class);\n\t\tbind(Session.class).toProvider(SessionProvider.class);\n\t\tbind(EntityManager.class).toProvider(SessionProvider.class);\n\t\tbind(SessionFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(EntityManagerFactory.class).toProvider(SessionFactoryProvider.class);\n\t\tbind(IssueCommentManager.class).to(DefaultIssueCommentManager.class);\n\t\tbind(IssueQuerySettingManager.class).to(DefaultIssueQuerySettingManager.class);\n\t\tbind(PullRequestQuerySettingManager.class).to(DefaultPullRequestQuerySettingManager.class);\n\t\tbind(CodeCommentQuerySettingManager.class).to(DefaultCodeCommentQuerySettingManager.class);\n\t\tbind(CommitQuerySettingManager.class).to(DefaultCommitQuerySettingManager.class);\n\t\tbind(BuildQuerySettingManager.class).to(DefaultBuildQuerySettingManager.class);\n\t\tbind(WebHookManager.class);\n\n\t\tcontribute(ObjectMapperConfigurator.class, GitObjectMapperConfigurator.class);\n\t    contribute(ObjectMapperConfigurator.class, HibernateObjectMapperConfigurator.class);\n\t    \n\t\tbind(Realm.class).to(OneAuthorizingRealm.class);\n\t\tbind(RememberMeManager.class).to(OneRememberMeManager.class);\n\t\tbind(WebSecurityManager.class).to(OneWebSecurityManager.class);\n\t\tbind(FilterChainResolver.class).to(OneFilterChainResolver.class);\n\t\tbind(BasicAuthenticationFilter.class);\n\t\tbind(PasswordService.class).to(OnePasswordService.class);\n\t\tbind(ShiroFilter.class);\n\t\tinstall(new ShiroAopModule());\n        contribute(FilterChainConfigurator.class, new FilterChainConfigurator() {\n\n            @Override\n            public void configure(FilterChainManager filterChainManager) {\n                filterChainManager.createChain(\"/**/info/refs\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-upload-pack\", \"noSessionCreation, authcBasic\");\n                filterChainManager.createChain(\"/**/git-receive-pack\", \"noSessionCreation, authcBasic\");\n            }\n            \n        });\n        contributeFromPackage(Authenticator.class, Authenticator.class);\n        \n\t\tcontribute(ImplementationProvider.class, new ImplementationProvider() {\n\n\t\t\t@Override\n\t\t\tpublic Class<?> getAbstractClass() {\n\t\t\t\treturn JobExecutor.class;\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic Collection<Class<?>> getImplementations() {\n\t\t\t\treturn Sets.newHashSet(AutoDiscoveredJobExecutor.class);\n\t\t\t}\n\t\t\t\n\t\t});\n\t\t\n\t\tcontribute(CodePullAuthorizationSource.class, DefaultJobManager.class);\n        \n\t\tbind(IndexManager.class).to(DefaultIndexManager.class);\n\t\tbind(SearchManager.class).to(DefaultSearchManager.class);\n\t\t\n\t\tbind(EntityValidator.class).to(DefaultEntityValidator.class);\n\t\t\n\t\tbind(GitFilter.class);\n\t\tbind(GitPreReceiveCallback.class);\n\t\tbind(GitPostReceiveCallback.class);\n\t\t\n\t    bind(ExecutorService.class).toProvider(new Provider<ExecutorService>() {\n\n\t\t\t@Override\n\t\t\tpublic ExecutorService get() {\n\t\t        return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, \n\t\t        \t\tnew SynchronousQueue<Runnable>()) {\n\n\t\t\t\t\t@Override\n\t\t\t\t\tpublic void execute(Runnable command) {\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(command));\n\t\t\t\t\t\t} catch (RejectedExecutionException e) {\n\t\t\t\t\t\t\tif (!isShutdown())\n\t\t\t\t\t\t\t\tthrow ExceptionUtils.unchecked(e);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\n\t\t        };\n\t\t\t}\n\t    \t\n\t    }).in(Singleton.class);\n\t    \n\t    bind(ForkJoinPool.class).toInstance(new ForkJoinPool() {\n\n\t\t\t@Override\n\t\t\tpublic ForkJoinTask<?> submit(Runnable task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic void execute(Runnable task) {\n\t\t\t\tsuper.execute(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Callable<T> task) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> ForkJoinTask<T> submit(Runnable task, T result) {\n\t\t\t\treturn super.submit(SecurityUtils.inheritSubject(task), result);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n\t\t\t\t\tthrows InterruptedException, ExecutionException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> T invokeAny(Collection<? extends Callable<T>> tasks, long timeout, TimeUnit unit)\n\t\t\t\t\tthrows InterruptedException, ExecutionException, TimeoutException {\n\t\t\t\treturn super.invokeAny(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks, \n\t\t\t\t\tlong timeout, TimeUnit unit) throws InterruptedException {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks), timeout, unit);\n\t\t\t}\n\n\t\t\t@Override\n\t\t\tpublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks) {\n\t\t\t\treturn super.invokeAll(SecurityUtils.inheritSubject(tasks));\n\t\t\t}\n\n\t    });\n\t}"
    }
]